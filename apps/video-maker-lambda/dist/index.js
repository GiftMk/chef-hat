'use strict'
var X$ = Object.create
var Xl = Object.defineProperty
var Y$ = Object.getOwnPropertyDescriptor
var J$ = Object.getOwnPropertyNames
var Q$ = Object.getPrototypeOf,
	Z$ = Object.prototype.hasOwnProperty
var oe = (e, t) => () => (e && (t = e((e = 0))), t)
var E = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
	Sc = (e, t) => {
		for (var r in t) Xl(e, r, { get: t[r], enumerable: !0 })
	},
	jC = (e, t, r, n) => {
		if ((t && typeof t == 'object') || typeof t == 'function')
			for (let i of J$(t))
				!Z$.call(e, i) &&
					i !== r &&
					Xl(e, i, {
						get: () => t[i],
						enumerable: !(n = Y$(t, i)) || n.enumerable,
					})
		return e
	}
var Oe = (e, t, r) => (
		(r = e != null ? X$(Q$(e)) : {}),
		jC(
			t || !e || !e.__esModule
				? Xl(r, 'default', { value: e, enumerable: !0 })
				: r,
			e,
		)
	),
	ve = (e) => jC(Xl({}, '__esModule', { value: !0 }), e)
var $C = E((GPe, HC) => {
	HC.exports = zC
	zC.sync = t6
	var UC = require('fs')
	function e6(e, t) {
		var r = t.pathExt !== void 0 ? t.pathExt : process.env.PATHEXT
		if (!r || ((r = r.split(';')), r.indexOf('') !== -1)) return !0
		for (var n = 0; n < r.length; n++) {
			var i = r[n].toLowerCase()
			if (i && e.substr(-i.length).toLowerCase() === i) return !0
		}
		return !1
	}
	function GC(e, t, r) {
		return !e.isSymbolicLink() && !e.isFile() ? !1 : e6(t, r)
	}
	function zC(e, t, r) {
		UC.stat(e, function (n, i) {
			r(n, n ? !1 : GC(i, e, t))
		})
	}
	function t6(e, t) {
		return GC(UC.statSync(e), e, t)
	}
})
var YC = E((zPe, XC) => {
	XC.exports = KC
	KC.sync = r6
	var VC = require('fs')
	function KC(e, t, r) {
		VC.stat(e, function (n, i) {
			r(n, n ? !1 : WC(i, t))
		})
	}
	function r6(e, t) {
		return WC(VC.statSync(e), t)
	}
	function WC(e, t) {
		return e.isFile() && n6(e, t)
	}
	function n6(e, t) {
		var r = e.mode,
			n = e.uid,
			i = e.gid,
			o = t.uid !== void 0 ? t.uid : process.getuid && process.getuid(),
			s = t.gid !== void 0 ? t.gid : process.getgid && process.getgid(),
			c = parseInt('100', 8),
			l = parseInt('010', 8),
			u = parseInt('001', 8),
			m = c | l,
			f =
				r & u || (r & l && i === s) || (r & c && n === o) || (r & m && o === 0)
		return f
	}
})
var QC = E(($Pe, JC) => {
	var HPe = require('fs'),
		Yl
	process.platform === 'win32' || global.TESTING_WINDOWS
		? (Yl = $C())
		: (Yl = YC())
	JC.exports = Qp
	Qp.sync = i6
	function Qp(e, t, r) {
		if ((typeof t == 'function' && ((r = t), (t = {})), !r)) {
			if (typeof Promise != 'function')
				throw new TypeError('callback not provided')
			return new Promise(function (n, i) {
				Qp(e, t || {}, function (o, s) {
					o ? i(o) : n(s)
				})
			})
		}
		Yl(e, t || {}, function (n, i) {
			n &&
				(n.code === 'EACCES' || (t && t.ignoreErrors)) &&
				((n = null), (i = !1)),
				r(n, i)
		})
	}
	function i6(e, t) {
		try {
			return Yl.sync(e, t || {})
		} catch (r) {
			if ((t && t.ignoreErrors) || r.code === 'EACCES') return !1
			throw r
		}
	}
})
var o0 = E((VPe, i0) => {
	i0.exports = n0
	n0.sync = s6
	var Zp =
			process.platform === 'win32' ||
			process.env.OSTYPE === 'cygwin' ||
			process.env.OSTYPE === 'msys',
		ZC = require('path'),
		o6 = Zp ? ';' : ':',
		e0 = QC()
	function t0(e) {
		var t = new Error('not found: ' + e)
		return (t.code = 'ENOENT'), t
	}
	function r0(e, t) {
		var r = t.colon || o6,
			n = t.path || process.env.PATH || '',
			i = ['']
		n = n.split(r)
		var o = ''
		return (
			Zp &&
				(n.unshift(process.cwd()),
				(o = t.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'),
				(i = o.split(r)),
				e.indexOf('.') !== -1 && i[0] !== '' && i.unshift('')),
			(e.match(/\//) || (Zp && e.match(/\\/))) && (n = ['']),
			{ env: n, ext: i, extExe: o }
		)
	}
	function n0(e, t, r) {
		typeof t == 'function' && ((r = t), (t = {}))
		var n = r0(e, t),
			i = n.env,
			o = n.ext,
			s = n.extExe,
			c = []
		;(function l(u, m) {
			if (u === m) return t.all && c.length ? r(null, c) : r(t0(e))
			var f = i[u]
			f.charAt(0) === '"' && f.slice(-1) === '"' && (f = f.slice(1, -1))
			var p = ZC.join(f, e)
			!f && /^\.[\\\/]/.test(e) && (p = e.slice(0, 2) + p),
				(function g(v, _) {
					if (v === _) return l(u + 1, m)
					var y = o[v]
					e0(p + y, { pathExt: s }, function (P, x) {
						if (!P && x)
							if (t.all) c.push(p + y)
							else return r(null, p + y)
						return g(v + 1, _)
					})
				})(0, o.length)
		})(0, i.length)
	}
	function s6(e, t) {
		t = t || {}
		for (
			var r = r0(e, t),
				n = r.env,
				i = r.ext,
				o = r.extExe,
				s = [],
				c = 0,
				l = n.length;
			c < l;
			c++
		) {
			var u = n[c]
			u.charAt(0) === '"' && u.slice(-1) === '"' && (u = u.slice(1, -1))
			var m = ZC.join(u, e)
			!u && /^\.[\\\/]/.test(e) && (m = e.slice(0, 2) + m)
			for (var f = 0, p = i.length; f < p; f++) {
				var g = m + i[f],
					v
				try {
					if (((v = e0.sync(g, { pathExt: o })), v))
						if (t.all) s.push(g)
						else return g
				} catch {}
			}
		}
		if (t.all && s.length) return s
		if (t.nothrow) return null
		throw t0(e)
	}
})
var Cn = E((WPe, l0) => {
	'use strict'
	var KPe = require('child_process').exec,
		a6 = require('os')
			.platform()
			.match(/win(32|64)/),
		c6 = o0(),
		s0 = /\r\n|\r|\n/g,
		Cc = /^\[?(.*?)\]?$/,
		a0 = /[,]/,
		Jl = {}
	function l6(e) {
		var t = {}
		e = e.replace(/=\s+/g, '=').trim()
		for (var r = e.split(' '), n = 0; n < r.length; n++) {
			var i = r[n].split('=', 2),
				o = i[0],
				s = i[1]
			if (typeof s > 'u') return null
			t[o] = s
		}
		return t
	}
	var c0 = (l0.exports = {
		isWindows: a6,
		streamRegexp: Cc,
		copy: function (e, t) {
			Object.keys(e).forEach(function (r) {
				t[r] = e[r]
			})
		},
		args: function () {
			var e = [],
				t = function () {
					arguments.length === 1 && Array.isArray(arguments[0])
						? (e = e.concat(arguments[0]))
						: (e = e.concat([].slice.call(arguments)))
				}
			return (
				(t.clear = function () {
					e = []
				}),
				(t.get = function () {
					return e
				}),
				(t.find = function (r, n) {
					var i = e.indexOf(r)
					if (i !== -1) return e.slice(i + 1, i + 1 + (n || 0))
				}),
				(t.remove = function (r, n) {
					var i = e.indexOf(r)
					i !== -1 && e.splice(i, (n || 0) + 1)
				}),
				(t.clone = function () {
					var r = c0.args()
					return r(e), r
				}),
				t
			)
		},
		makeFilterStrings: function (e) {
			return e.map(function (t) {
				if (typeof t == 'string') return t
				var r = ''
				return (
					Array.isArray(t.inputs)
						? (r += t.inputs
								.map(function (n) {
									return n.replace(Cc, '[$1]')
								})
								.join(''))
						: typeof t.inputs == 'string' &&
							(r += t.inputs.replace(Cc, '[$1]')),
					(r += t.filter),
					t.options &&
						(typeof t.options == 'string' || typeof t.options == 'number'
							? (r += '=' + t.options)
							: Array.isArray(t.options)
								? (r +=
										'=' +
										t.options
											.map(function (n) {
												return typeof n == 'string' && n.match(a0)
													? "'" + n + "'"
													: n
											})
											.join(':'))
								: Object.keys(t.options).length &&
									(r +=
										'=' +
										Object.keys(t.options)
											.map(function (n) {
												var i = t.options[n]
												return (
													typeof i == 'string' &&
														i.match(a0) &&
														(i = "'" + i + "'"),
													n + '=' + i
												)
											})
											.join(':'))),
					Array.isArray(t.outputs)
						? (r += t.outputs
								.map(function (n) {
									return n.replace(Cc, '[$1]')
								})
								.join(''))
						: typeof t.outputs == 'string' &&
							(r += t.outputs.replace(Cc, '[$1]')),
					r
				)
			})
		},
		which: function (e, t) {
			if (e in Jl) return t(null, Jl[e])
			c6(e, function (r, n) {
				if (r) return t(null, (Jl[e] = ''))
				t(null, (Jl[e] = n))
			})
		},
		timemarkToSeconds: function (e) {
			if (typeof e == 'number') return e
			if (e.indexOf(':') === -1 && e.indexOf('.') >= 0) return Number(e)
			var t = e.split(':'),
				r = Number(t.pop())
			return (
				t.length && (r += Number(t.pop()) * 60),
				t.length && (r += Number(t.pop()) * 3600),
				r
			)
		},
		extractCodecData: function (e, t, r) {
			var n = /Input #[0-9]+, ([^ ]+),/,
				i = /Duration\: ([^,]+)/,
				o = /Audio\: (.*)/,
				s = /Video\: (.*)/
			'inputStack' in r ||
				((r.inputStack = []), (r.inputIndex = -1), (r.inInput = !1))
			var c = r.inputStack,
				l = r.inputIndex,
				u = r.inInput,
				m,
				f,
				p,
				g
			if ((m = t.match(n)))
				(u = r.inInput = !0),
					(l = r.inputIndex = r.inputIndex + 1),
					(c[l] = { format: m[1], audio: '', video: '', duration: '' })
			else if (u && (f = t.match(i))) c[l].duration = f[1]
			else if (u && (p = t.match(o)))
				(p = p[1].split(', ')), (c[l].audio = p[0]), (c[l].audio_details = p)
			else if (u && (g = t.match(s)))
				(g = g[1].split(', ')), (c[l].video = g[0]), (c[l].video_details = g)
			else if (/Output #\d+/.test(t)) u = r.inInput = !1
			else if (/Stream mapping:|Press (\[q\]|ctrl-c) to stop/.test(t))
				return e.emit.apply(e, ['codecData'].concat(c)), !0
			return !1
		},
		extractProgress: function (e, t) {
			var r = l6(t)
			if (r) {
				var n = {
					frames: parseInt(r.frame, 10),
					currentFps: parseInt(r.fps, 10),
					currentKbps: r.bitrate
						? parseFloat(r.bitrate.replace('kbits/s', ''))
						: 0,
					targetSize: parseInt(r.size || r.Lsize, 10),
					timemark: r.time,
				}
				if (
					e._ffprobeData &&
					e._ffprobeData.format &&
					e._ffprobeData.format.duration
				) {
					var i = Number(e._ffprobeData.format.duration)
					isNaN(i) || (n.percent = (c0.timemarkToSeconds(n.timemark) / i) * 100)
				}
				e.emit('progress', n)
			}
		},
		extractError: function (e) {
			return e
				.split(s0)
				.reduce(function (t, r) {
					return r.charAt(0) === ' ' || r.charAt(0) === '['
						? []
						: (t.push(r), t)
				}, [])
				.join(`
`)
		},
		linesRing: function (e) {
			var t = [],
				r = [],
				n = null,
				i = !1,
				o = e - 1
			function s(c) {
				t.forEach(function (l) {
					l(c)
				})
			}
			return {
				callback: function (c) {
					r.forEach(function (l) {
						c(l)
					}),
						t.push(c)
				},
				append: function (c) {
					if (
						!i &&
						(c instanceof Buffer && (c = '' + c), !(!c || c.length === 0))
					) {
						var l = c.split(s0)
						l.length === 1
							? n !== null
								? (n = n + l.shift())
								: (n = l.shift())
							: (n !== null && ((n = n + l.shift()), s(n), r.push(n)),
								(n = l.pop()),
								l.forEach(function (u) {
									s(u), r.push(u)
								}),
								o > -1 && r.length > o && r.splice(0, r.length - o))
					}
				},
				get: function () {
					return n !== null
						? r.concat([n]).join(`
`)
						: r.join(`
`)
				},
				close: function () {
					i ||
						(n !== null &&
							(s(n),
							r.push(n),
							o > -1 && r.length > o && r.shift(),
							(n = null)),
						(i = !0))
				},
			}
		},
	})
})
var u0 = E((XPe, d0) => {
	'use strict'
	var d6 = Cn()
	d0.exports = function (e) {
		;(e.mergeAdd =
			e.addInput =
			e.input =
				function (t) {
					var r = !1,
						n = !1
					if (typeof t != 'string') {
						if (!('readable' in t) || !t.readable)
							throw new Error('Invalid input')
						var i = this._inputs.some(function (s) {
							return s.isStream
						})
						if (i) throw new Error('Only one input stream is supported')
						;(n = !0), t.pause()
					} else {
						var o = t.match(/^([a-z]{2,}):/i)
						r = !o || o[0] === 'file'
					}
					return (
						this._inputs.push(
							(this._currentInput = {
								source: t,
								isFile: r,
								isStream: n,
								options: d6.args(),
							}),
						),
						this
					)
				}),
			(e.withInputFormat =
				e.inputFormat =
				e.fromFormat =
					function (t) {
						if (!this._currentInput) throw new Error('No input specified')
						return this._currentInput.options('-f', t), this
					}),
			(e.withInputFps =
				e.withInputFPS =
				e.withFpsInput =
				e.withFPSInput =
				e.inputFPS =
				e.inputFps =
				e.fpsInput =
				e.FPSInput =
					function (t) {
						if (!this._currentInput) throw new Error('No input specified')
						return this._currentInput.options('-r', t), this
					}),
			(e.nativeFramerate =
				e.withNativeFramerate =
				e.native =
					function () {
						if (!this._currentInput) throw new Error('No input specified')
						return this._currentInput.options('-re'), this
					}),
			(e.setStartTime = e.seekInput =
				function (t) {
					if (!this._currentInput) throw new Error('No input specified')
					return this._currentInput.options('-ss', t), this
				}),
			(e.loop = function (t) {
				if (!this._currentInput) throw new Error('No input specified')
				return (
					this._currentInput.options('-loop', '1'),
					typeof t < 'u' && this.duration(t),
					this
				)
			})
	}
})
var f0 = E((YPe, m0) => {
	'use strict'
	var u6 = Cn()
	m0.exports = function (e) {
		;(e.withNoAudio = e.noAudio =
			function () {
				return (
					this._currentOutput.audio.clear(),
					this._currentOutput.audioFilters.clear(),
					this._currentOutput.audio('-an'),
					this
				)
			}),
			(e.withAudioCodec = e.audioCodec =
				function (t) {
					return this._currentOutput.audio('-acodec', t), this
				}),
			(e.withAudioBitrate = e.audioBitrate =
				function (t) {
					return (
						this._currentOutput.audio('-b:a', ('' + t).replace(/k?$/, 'k')),
						this
					)
				}),
			(e.withAudioChannels = e.audioChannels =
				function (t) {
					return this._currentOutput.audio('-ac', t), this
				}),
			(e.withAudioFrequency = e.audioFrequency =
				function (t) {
					return this._currentOutput.audio('-ar', t), this
				}),
			(e.withAudioQuality = e.audioQuality =
				function (t) {
					return this._currentOutput.audio('-aq', t), this
				}),
			(e.withAudioFilter =
				e.withAudioFilters =
				e.audioFilter =
				e.audioFilters =
					function (t) {
						return (
							arguments.length > 1 && (t = [].slice.call(arguments)),
							Array.isArray(t) || (t = [t]),
							this._currentOutput.audioFilters(u6.makeFilterStrings(t)),
							this
						)
					})
	}
})
var g0 = E((JPe, p0) => {
	'use strict'
	var m6 = Cn()
	p0.exports = function (e) {
		;(e.withNoVideo = e.noVideo =
			function () {
				return (
					this._currentOutput.video.clear(),
					this._currentOutput.videoFilters.clear(),
					this._currentOutput.video('-vn'),
					this
				)
			}),
			(e.withVideoCodec = e.videoCodec =
				function (t) {
					return this._currentOutput.video('-vcodec', t), this
				}),
			(e.withVideoBitrate = e.videoBitrate =
				function (t, r) {
					return (
						(t = ('' + t).replace(/k?$/, 'k')),
						this._currentOutput.video('-b:v', t),
						r &&
							this._currentOutput.video(
								'-maxrate',
								t,
								'-minrate',
								t,
								'-bufsize',
								'3M',
							),
						this
					)
				}),
			(e.withVideoFilter =
				e.withVideoFilters =
				e.videoFilter =
				e.videoFilters =
					function (t) {
						return (
							arguments.length > 1 && (t = [].slice.call(arguments)),
							Array.isArray(t) || (t = [t]),
							this._currentOutput.videoFilters(m6.makeFilterStrings(t)),
							this
						)
					}),
			(e.withOutputFps =
				e.withOutputFPS =
				e.withFpsOutput =
				e.withFPSOutput =
				e.withFps =
				e.withFPS =
				e.outputFPS =
				e.outputFps =
				e.fpsOutput =
				e.FPSOutput =
				e.fps =
				e.FPS =
					function (t) {
						return this._currentOutput.video('-r', t), this
					}),
			(e.takeFrames =
				e.withFrames =
				e.frames =
					function (t) {
						return this._currentOutput.video('-vframes', t), this
					})
	}
})
var _0 = E((QPe, h0) => {
	'use strict'
	function v0(e, t, r, n) {
		return [
			{
				filter: 'scale',
				options: {
					w: 'if(gt(a,' + r + '),' + e + ',trunc(' + t + '*a/2)*2)',
					h: 'if(lt(a,' + r + '),' + t + ',trunc(' + e + '/a/2)*2)',
				},
			},
			{
				filter: 'pad',
				options: {
					w: e,
					h: t,
					x: 'if(gt(a,' + r + '),0,(' + e + '-iw)/2)',
					y: 'if(lt(a,' + r + '),0,(' + t + '-ih)/2)',
					color: n,
				},
			},
		]
	}
	function eg(e, t, r) {
		var n = (e.sizeData = e.sizeData || {})
		if (((n[t] = r), !('size' in n))) return []
		var i = n.size.match(/([0-9]+)x([0-9]+)/),
			o = n.size.match(/([0-9]+)x\?/),
			s = n.size.match(/\?x([0-9]+)/),
			c = n.size.match(/\b([0-9]{1,3})%/),
			l,
			u,
			m
		if (c) {
			var f = Number(c[1]) / 100
			return [
				{
					filter: 'scale',
					options: {
						w: 'trunc(iw*' + f + '/2)*2',
						h: 'trunc(ih*' + f + '/2)*2',
					},
				},
			]
		} else {
			if (i)
				return (
					(l = Math.round(Number(i[1]) / 2) * 2),
					(u = Math.round(Number(i[2]) / 2) * 2),
					(m = l / u),
					n.pad
						? v0(l, u, m, n.pad)
						: [{ filter: 'scale', options: { w: l, h: u } }]
				)
			if (o || s)
				return 'aspect' in n
					? ((l = o ? o[1] : Math.round(Number(s[1]) * n.aspect)),
						(u = s ? s[1] : Math.round(Number(o[1]) / n.aspect)),
						(l = Math.round(l / 2) * 2),
						(u = Math.round(u / 2) * 2),
						n.pad
							? v0(l, u, n.aspect, n.pad)
							: [{ filter: 'scale', options: { w: l, h: u } }])
					: o
						? [
								{
									filter: 'scale',
									options: {
										w: Math.round(Number(o[1]) / 2) * 2,
										h: 'trunc(ow/a/2)*2',
									},
								},
							]
						: [
								{
									filter: 'scale',
									options: {
										w: 'trunc(oh*a/2)*2',
										h: Math.round(Number(s[1]) / 2) * 2,
									},
								},
							]
			throw new Error('Invalid size specified: ' + n.size)
		}
	}
	h0.exports = function (e) {
		;(e.keepPixelAspect =
			e.keepDisplayAspect =
			e.keepDisplayAspectRatio =
			e.keepDAR =
				function () {
					return this.videoFilters([
						{
							filter: 'scale',
							options: {
								w: 'if(gt(sar,1),iw*sar,iw)',
								h: 'if(lt(sar,1),ih/sar,ih)',
							},
						},
						{ filter: 'setsar', options: '1' },
					])
				}),
			(e.withSize =
				e.setSize =
				e.size =
					function (t) {
						var r = eg(this._currentOutput, 'size', t)
						return (
							this._currentOutput.sizeFilters.clear(),
							this._currentOutput.sizeFilters(r),
							this
						)
					}),
			(e.withAspect =
				e.withAspectRatio =
				e.setAspect =
				e.setAspectRatio =
				e.aspect =
				e.aspectRatio =
					function (t) {
						var r = Number(t)
						if (isNaN(r)) {
							var n = t.match(/^(\d+):(\d+)$/)
							if (n) r = Number(n[1]) / Number(n[2])
							else throw new Error('Invalid aspect ratio: ' + t)
						}
						var i = eg(this._currentOutput, 'aspect', r)
						return (
							this._currentOutput.sizeFilters.clear(),
							this._currentOutput.sizeFilters(i),
							this
						)
					}),
			(e.applyAutopadding =
				e.applyAutoPadding =
				e.applyAutopad =
				e.applyAutoPad =
				e.withAutopadding =
				e.withAutoPadding =
				e.withAutopad =
				e.withAutoPad =
				e.autoPad =
				e.autopad =
					function (t, r) {
						typeof t == 'string' && ((r = t), (t = !0)),
							typeof t > 'u' && (t = !0)
						var n = eg(this._currentOutput, 'pad', t ? r || 'black' : !1)
						return (
							this._currentOutput.sizeFilters.clear(),
							this._currentOutput.sizeFilters(n),
							this
						)
					})
	}
})
var C0 = E((ZPe, S0) => {
	'use strict'
	var y0 = Cn()
	S0.exports = function (e) {
		;(e.addOutput = e.output =
			function (t, r) {
				var n = !1
				if (!t && this._currentOutput) throw new Error('Invalid output')
				if (t && typeof t != 'string') {
					if (!('writable' in t) || !t.writable)
						throw new Error('Invalid output')
				} else if (typeof t == 'string') {
					var i = t.match(/^([a-z]{2,}):/i)
					n = !i || i[0] === 'file'
				}
				if (t && !('target' in this._currentOutput))
					(this._currentOutput.target = t),
						(this._currentOutput.isFile = n),
						(this._currentOutput.pipeopts = r || {})
				else {
					if (t && typeof t != 'string') {
						var o = this._outputs.some(function (c) {
							return typeof c.target != 'string'
						})
						if (o) throw new Error('Only one output stream is supported')
					}
					this._outputs.push(
						(this._currentOutput = {
							target: t,
							isFile: n,
							flags: {},
							pipeopts: r || {},
						}),
					)
					var s = this
					;[
						'audio',
						'audioFilters',
						'video',
						'videoFilters',
						'sizeFilters',
						'options',
					].forEach(function (c) {
						s._currentOutput[c] = y0.args()
					}),
						t || delete this._currentOutput.target
				}
				return this
			}),
			(e.seekOutput = e.seek =
				function (t) {
					return this._currentOutput.options('-ss', t), this
				}),
			(e.withDuration =
				e.setDuration =
				e.duration =
					function (t) {
						return this._currentOutput.options('-t', t), this
					}),
			(e.toFormat =
				e.withOutputFormat =
				e.outputFormat =
				e.format =
					function (t) {
						return this._currentOutput.options('-f', t), this
					}),
			(e.map = function (t) {
				return (
					this._currentOutput.options(
						'-map',
						t.replace(y0.streamRegexp, '[$1]'),
					),
					this
				)
			}),
			(e.updateFlvMetadata = e.flvmeta =
				function () {
					return (this._currentOutput.flags.flvmeta = !0), this
				})
	}
})
var b0 = E((eAe, E0) => {
	'use strict'
	var tg = Cn()
	E0.exports = function (e) {
		;(e.addInputOption =
			e.addInputOptions =
			e.withInputOption =
			e.withInputOptions =
			e.inputOption =
			e.inputOptions =
				function (t) {
					if (!this._currentInput) throw new Error('No input specified')
					var r = !0
					return (
						arguments.length > 1 && ((t = [].slice.call(arguments)), (r = !1)),
						Array.isArray(t) || (t = [t]),
						this._currentInput.options(
							t.reduce(function (n, i) {
								var o = String(i).split(' ')
								return r && o.length === 2 ? n.push(o[0], o[1]) : n.push(i), n
							}, []),
						),
						this
					)
				}),
			(e.addOutputOption =
				e.addOutputOptions =
				e.addOption =
				e.addOptions =
				e.withOutputOption =
				e.withOutputOptions =
				e.withOption =
				e.withOptions =
				e.outputOption =
				e.outputOptions =
					function (t) {
						var r = !0
						return (
							arguments.length > 1 &&
								((t = [].slice.call(arguments)), (r = !1)),
							Array.isArray(t) || (t = [t]),
							this._currentOutput.options(
								t.reduce(function (n, i) {
									var o = String(i).split(' ')
									return r && o.length === 2 ? n.push(o[0], o[1]) : n.push(i), n
								}, []),
							),
							this
						)
					}),
			(e.filterGraph = e.complexFilter =
				function (t, r) {
					if (
						(this._complexFilters.clear(),
						Array.isArray(t) || (t = [t]),
						this._complexFilters(
							'-filter_complex',
							tg.makeFilterStrings(t).join(';'),
						),
						Array.isArray(r))
					) {
						var n = this
						r.forEach(function (i) {
							n._complexFilters('-map', i.replace(tg.streamRegexp, '[$1]'))
						})
					} else
						typeof r == 'string' &&
							this._complexFilters('-map', r.replace(tg.streamRegexp, '[$1]'))
					return this
				})
	}
})
var x0 = E((tAe, w0) => {
	'use strict'
	var f6 = require('path')
	w0.exports = function (e) {
		e.usingPreset = e.preset = function (t) {
			if (typeof t == 'function') t(this)
			else
				try {
					var r = f6.join(this.options.presets, t),
						n = require(r)
					if (typeof n.load == 'function') n.load(this)
					else throw new Error('preset ' + r + ' has no load() function')
				} catch (i) {
					throw new Error('preset ' + r + ' could not be loaded: ' + i.message)
				}
			return this
		}
	}
})
var Zl = E((rAe, Ql) => {
	;(function () {
		var e = {},
			t,
			r
		;(t = this),
			t != null && (r = t.async),
			(e.noConflict = function () {
				return (t.async = r), e
			})
		function n(w) {
			var b = !1
			return function () {
				if (b) throw new Error('Callback was already called.')
				;(b = !0), w.apply(t, arguments)
			}
		}
		var i = function (w, b) {
				if (w.forEach) return w.forEach(b)
				for (var A = 0; A < w.length; A += 1) b(w[A], A, w)
			},
			o = function (w, b) {
				if (w.map) return w.map(b)
				var A = []
				return (
					i(w, function (R, k, T) {
						A.push(b(R, k, T))
					}),
					A
				)
			},
			s = function (w, b, A) {
				return w.reduce
					? w.reduce(b, A)
					: (i(w, function (R, k, T) {
							A = b(A, R, k, T)
						}),
						A)
			},
			c = function (w) {
				if (Object.keys) return Object.keys(w)
				var b = []
				for (var A in w) w.hasOwnProperty(A) && b.push(A)
				return b
			}
		typeof process > 'u' || !process.nextTick
			? typeof setImmediate == 'function'
				? ((e.nextTick = function (w) {
						setImmediate(w)
					}),
					(e.setImmediate = e.nextTick))
				: ((e.nextTick = function (w) {
						setTimeout(w, 0)
					}),
					(e.setImmediate = e.nextTick))
			: ((e.nextTick = process.nextTick),
				typeof setImmediate < 'u'
					? (e.setImmediate = function (w) {
							setImmediate(w)
						})
					: (e.setImmediate = e.nextTick)),
			(e.each = function (w, b, A) {
				if (((A = A || function () {}), !w.length)) return A()
				var R = 0
				i(w, function (k) {
					b(
						k,
						n(function (T) {
							T
								? (A(T), (A = function () {}))
								: ((R += 1), R >= w.length && A(null))
						}),
					)
				})
			}),
			(e.forEach = e.each),
			(e.eachSeries = function (w, b, A) {
				if (((A = A || function () {}), !w.length)) return A()
				var R = 0,
					k = function () {
						b(w[R], function (T) {
							T
								? (A(T), (A = function () {}))
								: ((R += 1), R >= w.length ? A(null) : k())
						})
					}
				k()
			}),
			(e.forEachSeries = e.eachSeries),
			(e.eachLimit = function (w, b, A, R) {
				var k = l(b)
				k.apply(null, [w, A, R])
			}),
			(e.forEachLimit = e.eachLimit)
		var l = function (w) {
				return function (b, A, R) {
					if (((R = R || function () {}), !b.length || w <= 0)) return R()
					var k = 0,
						T = 0,
						K = 0
					;(function le() {
						if (k >= b.length) return R()
						for (; K < w && T < b.length; )
							(T += 1),
								(K += 1),
								A(b[T - 1], function (Ae) {
									Ae
										? (R(Ae), (R = function () {}))
										: ((k += 1), (K -= 1), k >= b.length ? R() : le())
								})
					})()
				}
			},
			u = function (w) {
				return function () {
					var b = Array.prototype.slice.call(arguments)
					return w.apply(null, [e.each].concat(b))
				}
			},
			m = function (w, b) {
				return function () {
					var A = Array.prototype.slice.call(arguments)
					return b.apply(null, [l(w)].concat(A))
				}
			},
			f = function (w) {
				return function () {
					var b = Array.prototype.slice.call(arguments)
					return w.apply(null, [e.eachSeries].concat(b))
				}
			},
			p = function (w, b, A, R) {
				var k = []
				;(b = o(b, function (T, K) {
					return { index: K, value: T }
				})),
					w(
						b,
						function (T, K) {
							A(T.value, function (le, Ae) {
								;(k[T.index] = Ae), K(le)
							})
						},
						function (T) {
							R(T, k)
						},
					)
			}
		;(e.map = u(p)),
			(e.mapSeries = f(p)),
			(e.mapLimit = function (w, b, A, R) {
				return g(b)(w, A, R)
			})
		var g = function (w) {
			return m(w, p)
		}
		;(e.reduce = function (w, b, A, R) {
			e.eachSeries(
				w,
				function (k, T) {
					A(b, k, function (K, le) {
						;(b = le), T(K)
					})
				},
				function (k) {
					R(k, b)
				},
			)
		}),
			(e.inject = e.reduce),
			(e.foldl = e.reduce),
			(e.reduceRight = function (w, b, A, R) {
				var k = o(w, function (T) {
					return T
				}).reverse()
				e.reduce(k, b, A, R)
			}),
			(e.foldr = e.reduceRight)
		var v = function (w, b, A, R) {
			var k = []
			;(b = o(b, function (T, K) {
				return { index: K, value: T }
			})),
				w(
					b,
					function (T, K) {
						A(T.value, function (le) {
							le && k.push(T), K()
						})
					},
					function (T) {
						R(
							o(
								k.sort(function (K, le) {
									return K.index - le.index
								}),
								function (K) {
									return K.value
								},
							),
						)
					},
				)
		}
		;(e.filter = u(v)),
			(e.filterSeries = f(v)),
			(e.select = e.filter),
			(e.selectSeries = e.filterSeries)
		var _ = function (w, b, A, R) {
			var k = []
			;(b = o(b, function (T, K) {
				return { index: K, value: T }
			})),
				w(
					b,
					function (T, K) {
						A(T.value, function (le) {
							le || k.push(T), K()
						})
					},
					function (T) {
						R(
							o(
								k.sort(function (K, le) {
									return K.index - le.index
								}),
								function (K) {
									return K.value
								},
							),
						)
					},
				)
		}
		;(e.reject = u(_)), (e.rejectSeries = f(_))
		var y = function (w, b, A, R) {
			w(
				b,
				function (k, T) {
					A(k, function (K) {
						K ? (R(k), (R = function () {})) : T()
					})
				},
				function (k) {
					R()
				},
			)
		}
		;(e.detect = u(y)),
			(e.detectSeries = f(y)),
			(e.some = function (w, b, A) {
				e.each(
					w,
					function (R, k) {
						b(R, function (T) {
							T && (A(!0), (A = function () {})), k()
						})
					},
					function (R) {
						A(!1)
					},
				)
			}),
			(e.any = e.some),
			(e.every = function (w, b, A) {
				e.each(
					w,
					function (R, k) {
						b(R, function (T) {
							T || (A(!1), (A = function () {})), k()
						})
					},
					function (R) {
						A(!0)
					},
				)
			}),
			(e.all = e.every),
			(e.sortBy = function (w, b, A) {
				e.map(
					w,
					function (R, k) {
						b(R, function (T, K) {
							T ? k(T) : k(null, { value: R, criteria: K })
						})
					},
					function (R, k) {
						if (R) return A(R)
						var T = function (K, le) {
							var Ae = K.criteria,
								st = le.criteria
							return Ae < st ? -1 : Ae > st ? 1 : 0
						}
						A(
							null,
							o(k.sort(T), function (K) {
								return K.value
							}),
						)
					},
				)
			}),
			(e.auto = function (w, b) {
				b = b || function () {}
				var A = c(w)
				if (!A.length) return b(null)
				var R = {},
					k = [],
					T = function (Ae) {
						k.unshift(Ae)
					},
					K = function (Ae) {
						for (var st = 0; st < k.length; st += 1)
							if (k[st] === Ae) {
								k.splice(st, 1)
								return
							}
					},
					le = function () {
						i(k.slice(0), function (Ae) {
							Ae()
						})
					}
				T(function () {
					c(R).length === A.length && (b(null, R), (b = function () {}))
				}),
					i(A, function (Ae) {
						var st = w[Ae] instanceof Function ? [w[Ae]] : w[Ae],
							oo = function (Wl) {
								var so = Array.prototype.slice.call(arguments, 1)
								if ((so.length <= 1 && (so = so[0]), Wl)) {
									var Jp = {}
									i(c(R), function (qC) {
										Jp[qC] = R[qC]
									}),
										(Jp[Ae] = so),
										b(Wl, Jp),
										(b = function () {})
								} else (R[Ae] = so), e.setImmediate(le)
							},
							W$ = st.slice(0, Math.abs(st.length - 1)) || [],
							FC = function () {
								return (
									s(
										W$,
										function (Wl, so) {
											return Wl && R.hasOwnProperty(so)
										},
										!0,
									) && !R.hasOwnProperty(Ae)
								)
							}
						if (FC()) st[st.length - 1](oo, R)
						else {
							var MC = function () {
								FC() && (K(MC), st[st.length - 1](oo, R))
							}
							T(MC)
						}
					})
			}),
			(e.waterfall = function (w, b) {
				if (((b = b || function () {}), w.constructor !== Array)) {
					var A = new Error(
						'First argument to waterfall must be an array of functions',
					)
					return b(A)
				}
				if (!w.length) return b()
				var R = function (k) {
					return function (T) {
						if (T) b.apply(null, arguments), (b = function () {})
						else {
							var K = Array.prototype.slice.call(arguments, 1),
								le = k.next()
							le ? K.push(R(le)) : K.push(b),
								e.setImmediate(function () {
									k.apply(null, K)
								})
						}
					}
				}
				R(e.iterator(w))()
			})
		var P = function (w, b, A) {
			if (((A = A || function () {}), b.constructor === Array))
				w.map(
					b,
					function (k, T) {
						k &&
							k(function (K) {
								var le = Array.prototype.slice.call(arguments, 1)
								le.length <= 1 && (le = le[0]), T.call(null, K, le)
							})
					},
					A,
				)
			else {
				var R = {}
				w.each(
					c(b),
					function (k, T) {
						b[k](function (K) {
							var le = Array.prototype.slice.call(arguments, 1)
							le.length <= 1 && (le = le[0]), (R[k] = le), T(K)
						})
					},
					function (k) {
						A(k, R)
					},
				)
			}
		}
		;(e.parallel = function (w, b) {
			P({ map: e.map, each: e.each }, w, b)
		}),
			(e.parallelLimit = function (w, b, A) {
				P({ map: g(b), each: l(b) }, w, A)
			}),
			(e.series = function (w, b) {
				if (((b = b || function () {}), w.constructor === Array))
					e.mapSeries(
						w,
						function (R, k) {
							R &&
								R(function (T) {
									var K = Array.prototype.slice.call(arguments, 1)
									K.length <= 1 && (K = K[0]), k.call(null, T, K)
								})
						},
						b,
					)
				else {
					var A = {}
					e.eachSeries(
						c(w),
						function (R, k) {
							w[R](function (T) {
								var K = Array.prototype.slice.call(arguments, 1)
								K.length <= 1 && (K = K[0]), (A[R] = K), k(T)
							})
						},
						function (R) {
							b(R, A)
						},
					)
				}
			}),
			(e.iterator = function (w) {
				var b = function (A) {
					var R = function () {
						return w.length && w[A].apply(null, arguments), R.next()
					}
					return (
						(R.next = function () {
							return A < w.length - 1 ? b(A + 1) : null
						}),
						R
					)
				}
				return b(0)
			}),
			(e.apply = function (w) {
				var b = Array.prototype.slice.call(arguments, 1)
				return function () {
					return w.apply(null, b.concat(Array.prototype.slice.call(arguments)))
				}
			})
		var x = function (w, b, A, R) {
			var k = []
			w(
				b,
				function (T, K) {
					A(T, function (le, Ae) {
						;(k = k.concat(Ae || [])), K(le)
					})
				},
				function (T) {
					R(T, k)
				},
			)
		}
		;(e.concat = u(x)),
			(e.concatSeries = f(x)),
			(e.whilst = function (w, b, A) {
				w()
					? b(function (R) {
							if (R) return A(R)
							e.whilst(w, b, A)
						})
					: A()
			}),
			(e.doWhilst = function (w, b, A) {
				w(function (R) {
					if (R) return A(R)
					b() ? e.doWhilst(w, b, A) : A()
				})
			}),
			(e.until = function (w, b, A) {
				w()
					? A()
					: b(function (R) {
							if (R) return A(R)
							e.until(w, b, A)
						})
			}),
			(e.doUntil = function (w, b, A) {
				w(function (R) {
					if (R) return A(R)
					b() ? A() : e.doUntil(w, b, A)
				})
			}),
			(e.queue = function (w, b) {
				b === void 0 && (b = 1)
				function A(T, K, le, Ae) {
					K.constructor !== Array && (K = [K]),
						i(K, function (st) {
							var oo = {
								data: st,
								callback: typeof Ae == 'function' ? Ae : null,
							}
							le ? T.tasks.unshift(oo) : T.tasks.push(oo),
								T.saturated && T.tasks.length === b && T.saturated(),
								e.setImmediate(T.process)
						})
				}
				var R = 0,
					k = {
						tasks: [],
						concurrency: b,
						saturated: null,
						empty: null,
						drain: null,
						push: function (T, K) {
							A(k, T, !1, K)
						},
						unshift: function (T, K) {
							A(k, T, !0, K)
						},
						process: function () {
							if (R < k.concurrency && k.tasks.length) {
								var T = k.tasks.shift()
								k.empty && k.tasks.length === 0 && k.empty(), (R += 1)
								var K = function () {
										;(R -= 1),
											T.callback && T.callback.apply(T, arguments),
											k.drain && k.tasks.length + R === 0 && k.drain(),
											k.process()
									},
									le = n(K)
								w(T.data, le)
							}
						},
						length: function () {
							return k.tasks.length
						},
						running: function () {
							return R
						},
					}
				return k
			}),
			(e.cargo = function (w, b) {
				var A = !1,
					R = [],
					k = {
						tasks: R,
						payload: b,
						saturated: null,
						empty: null,
						drain: null,
						push: function (T, K) {
							T.constructor !== Array && (T = [T]),
								i(T, function (le) {
									R.push({
										data: le,
										callback: typeof K == 'function' ? K : null,
									}),
										k.saturated && R.length === b && k.saturated()
								}),
								e.setImmediate(k.process)
						},
						process: function T() {
							if (!A) {
								if (R.length === 0) {
									k.drain && k.drain()
									return
								}
								var K = typeof b == 'number' ? R.splice(0, b) : R.splice(0),
									le = o(K, function (Ae) {
										return Ae.data
									})
								k.empty && k.empty(),
									(A = !0),
									w(le, function () {
										A = !1
										var Ae = arguments
										i(K, function (st) {
											st.callback && st.callback.apply(null, Ae)
										}),
											T()
									})
							}
						},
						length: function () {
							return R.length
						},
						running: function () {
							return A
						},
					}
				return k
			})
		var W = function (w) {
			return function (b) {
				var A = Array.prototype.slice.call(arguments, 1)
				b.apply(
					null,
					A.concat([
						function (R) {
							var k = Array.prototype.slice.call(arguments, 1)
							typeof console < 'u' &&
								(R
									? console.error && console.error(R)
									: console[w] &&
										i(k, function (T) {
											console[w](T)
										}))
						},
					]),
				)
			}
		}
		;(e.log = W('log')),
			(e.dir = W('dir')),
			(e.memoize = function (w, b) {
				var A = {},
					R = {}
				b =
					b ||
					function (T) {
						return T
					}
				var k = function () {
					var T = Array.prototype.slice.call(arguments),
						K = T.pop(),
						le = b.apply(null, T)
					le in A
						? K.apply(null, A[le])
						: le in R
							? R[le].push(K)
							: ((R[le] = [K]),
								w.apply(
									null,
									T.concat([
										function () {
											A[le] = arguments
											var Ae = R[le]
											delete R[le]
											for (var st = 0, oo = Ae.length; st < oo; st++)
												Ae[st].apply(null, arguments)
										},
									]),
								))
				}
				return (k.memo = A), (k.unmemoized = w), k
			}),
			(e.unmemoize = function (w) {
				return function () {
					return (w.unmemoized || w).apply(null, arguments)
				}
			}),
			(e.times = function (w, b, A) {
				for (var R = [], k = 0; k < w; k++) R.push(k)
				return e.map(R, b, A)
			}),
			(e.timesSeries = function (w, b, A) {
				for (var R = [], k = 0; k < w; k++) R.push(k)
				return e.mapSeries(R, b, A)
			}),
			(e.compose = function () {
				var w = Array.prototype.reverse.call(arguments)
				return function () {
					var b = this,
						A = Array.prototype.slice.call(arguments),
						R = A.pop()
					e.reduce(
						w,
						A,
						function (k, T, K) {
							T.apply(
								b,
								k.concat([
									function () {
										var le = arguments[0],
											Ae = Array.prototype.slice.call(arguments, 1)
										K(le, Ae)
									},
								]),
							)
						},
						function (k, T) {
							R.apply(b, [k].concat(T))
						},
					)
				}
			})
		var X = function (w, b) {
			var A = function () {
				var k = this,
					T = Array.prototype.slice.call(arguments),
					K = T.pop()
				return w(
					b,
					function (le, Ae) {
						le.apply(k, T.concat([Ae]))
					},
					K,
				)
			}
			if (arguments.length > 2) {
				var R = Array.prototype.slice.call(arguments, 2)
				return A.apply(this, R)
			} else return A
		}
		;(e.applyEach = u(X)),
			(e.applyEachSeries = f(X)),
			(e.forever = function (w, b) {
				function A(R) {
					if (R) {
						if (b) return b(R)
						throw R
					}
					w(A)
				}
				A()
			}),
			typeof define < 'u' && define.amd
				? define([], function () {
						return e
					})
				: typeof Ql < 'u' && Ql.exports
					? (Ql.exports = e)
					: (t.async = e)
	})()
})
var R0 = E((oAe, O0) => {
	'use strict'
	var rg = require('child_process').spawn,
		nAe = require('path'),
		iAe = require('fs'),
		P0 = Zl(),
		di = Cn()
	function A0(e) {
		e._inputs[0].isStream ||
			e.ffprobe(0, function (r, n) {
				e._ffprobeData = n
			})
	}
	O0.exports = function (e) {
		;(e._spawnFfmpeg = function (t, r, n, i) {
			typeof r == 'function' && ((i = n), (n = r), (r = {})),
				typeof i > 'u' && ((i = n), (n = function () {}))
			var o = 'stdoutLines' in r ? r.stdoutLines : this.options.stdoutLines
			this._getFfmpegPath(function (s, c) {
				if (s) return i(s)
				if (!c || c.length === 0) return i(new Error('Cannot find ffmpeg'))
				r.niceness &&
					r.niceness !== 0 &&
					!di.isWindows &&
					(t.unshift('-n', r.niceness, c), (c = 'nice'))
				var l = di.linesRing(o),
					u = !1,
					m = di.linesRing(o),
					f = !1,
					p = rg(c, t, r)
				p.stderr && p.stderr.setEncoding('utf8'),
					p.on('error', function (y) {
						i(y)
					})
				var g = null
				function v(y) {
					y && (g = y), _ && (u || !r.captureStdout) && f && i(g, l, m)
				}
				var _ = !1
				p.on('exit', function (y, P) {
					;(_ = !0),
						P
							? v(new Error('ffmpeg was killed with signal ' + P))
							: y
								? v(new Error('ffmpeg exited with code ' + y))
								: v()
				}),
					r.captureStdout &&
						(p.stdout.on('data', function (y) {
							l.append(y)
						}),
						p.stdout.on('close', function () {
							l.close(), (u = !0), v()
						})),
					p.stderr.on('data', function (y) {
						m.append(y)
					}),
					p.stderr.on('close', function () {
						m.close(), (f = !0), v()
					}),
					n(p, l, m)
			})
		}),
			(e._getArguments = function () {
				var t = this._complexFilters.get(),
					r = this._outputs.some(function (n) {
						return n.isFile
					})
				return [].concat(
					this._inputs.reduce(function (n, i) {
						var o = typeof i.source == 'string' ? i.source : 'pipe:0'
						return n.concat(i.options.get(), ['-i', o])
					}, []),
					this._global.get(),
					r ? ['-y'] : [],
					t,
					this._outputs.reduce(function (n, i) {
						var o = di.makeFilterStrings(i.sizeFilters.get()),
							s = i.audioFilters.get(),
							c = i.videoFilters.get().concat(o),
							l
						return (
							i.target
								? typeof i.target == 'string'
									? (l = [i.target])
									: (l = ['pipe:1'])
								: (l = []),
							n.concat(
								i.audio.get(),
								s.length ? ['-filter:a', s.join(',')] : [],
								i.video.get(),
								c.length ? ['-filter:v', c.join(',')] : [],
								i.options.get(),
								l,
							)
						)
					}, []),
				)
			}),
			(e._prepare = function (t, r) {
				var n = this
				P0.waterfall(
					[
						function (i) {
							n._checkCapabilities(i)
						},
						function (i) {
							if (!r) return i()
							n.ffprobe(0, function (o, s) {
								o || (n._ffprobeData = s), i()
							})
						},
						function (i) {
							var o = n._outputs.some(function (s) {
								return (
									s.flags.flvmeta &&
										!s.isFile &&
										(n.logger.warn(
											'Updating flv metadata is only supported for files',
										),
										(s.flags.flvmeta = !1)),
									s.flags.flvmeta
								)
							})
							o
								? n._getFlvtoolPath(function (s) {
										i(s)
									})
								: i()
						},
						function (i) {
							var o
							try {
								o = n._getArguments()
							} catch (s) {
								return i(s)
							}
							i(null, o)
						},
						function (i, o) {
							n.availableEncoders(function (s, c) {
								for (var l = 0; l < i.length; l++)
									(i[l] === '-acodec' || i[l] === '-vcodec') &&
										(l++,
										i[l] in c &&
											c[i[l]].experimental &&
											(i.splice(l + 1, 0, '-strict', 'experimental'), (l += 2)))
								o(null, i)
							})
						},
					],
					t,
				),
					r ||
						(this.listeners('progress').length > 0
							? A0(this)
							: this.once('newListener', function (i) {
									i === 'progress' && A0(this)
								}))
			}),
			(e.exec =
				e.execute =
				e.run =
					function () {
						var t = this,
							r = this._outputs.some(function (c) {
								return 'target' in c
							})
						if (!r) throw new Error('No output specified')
						var n = this._outputs.filter(function (c) {
								return typeof c.target != 'string'
							})[0],
							i = this._inputs.filter(function (c) {
								return typeof c.source != 'string'
							})[0],
							o = !1
						function s(c, l, u) {
							o ||
								((o = !0), c ? t.emit('error', c, l, u) : t.emit('end', l, u))
						}
						return (
							t._prepare(function (c, l) {
								if (c) return s(c)
								t._spawnFfmpeg(
									l,
									{
										captureStdout: !n,
										niceness: t.options.niceness,
										cwd: t.options.cwd,
										windowsHide: !0,
									},
									function (m, f, p) {
										if (
											((t.ffmpegProc = m),
											t.emit('start', 'ffmpeg ' + l.join(' ')),
											i &&
												(i.source.on('error', function (_) {
													var y = new Error('Input stream error: ' + _.message)
													;(y.inputStreamError = _), s(y), m.kill()
												}),
												i.source.resume(),
												i.source.pipe(m.stdin),
												m.stdin.on('error', function () {})),
											t.options.timeout &&
												(t.processTimer = setTimeout(function () {
													var _ =
														'process ran into a timeout (' +
														t.options.timeout +
														's)'
													s(new Error(_), f.get(), p.get()), m.kill()
												}, t.options.timeout * 1e3)),
											n &&
												(m.stdout.pipe(n.target, n.pipeopts),
												n.target.on('close', function () {
													t.logger.debug(
														'Output stream closed, scheduling kill for ffmpeg process',
													),
														setTimeout(function () {
															s(new Error('Output stream closed')), m.kill()
														}, 20)
												}),
												n.target.on('error', function (_) {
													t.logger.debug(
														'Output stream error, killing ffmpeg process',
													)
													var y = new Error('Output stream error: ' + _.message)
													;(y.outputStreamError = _),
														s(y, f.get(), p.get()),
														m.kill('SIGKILL')
												})),
											p)
										) {
											if (
												(t.listeners('stderr').length &&
													p.callback(function (_) {
														t.emit('stderr', _)
													}),
												t.listeners('codecData').length)
											) {
												var g = !1,
													v = {}
												p.callback(function (_) {
													g || (g = di.extractCodecData(t, _, v))
												})
											}
											t.listeners('progress').length &&
												p.callback(function (_) {
													di.extractProgress(t, _)
												})
										}
									},
									function (m, f, p) {
										if ((clearTimeout(t.processTimer), delete t.ffmpegProc, m))
											m.message.match(/ffmpeg exited with code/) &&
												(m.message += ': ' + di.extractError(p.get())),
												s(m, f.get(), p.get())
										else {
											var g = t._outputs.filter(function (v) {
												return v.flags.flvmeta
											})
											g.length
												? t._getFlvtoolPath(function (v, _) {
														if (v) return s(v)
														P0.each(
															g,
															function (y, P) {
																rg(_, ['-U', y.target], { windowsHide: !0 })
																	.on('error', function (x) {
																		P(
																			new Error(
																				'Error running ' +
																					_ +
																					' on ' +
																					y.target +
																					': ' +
																					x.message,
																			),
																		)
																	})
																	.on('exit', function (x, W) {
																		x !== 0 || W
																			? P(
																					new Error(
																						_ +
																							' ' +
																							(W
																								? 'received signal ' + W
																								: 'exited with code ' + x),
																					) +
																						' when running on ' +
																						y.target,
																				)
																			: P()
																	})
															},
															function (y) {
																y ? s(y) : s(null, f.get(), p.get())
															},
														)
													})
												: s(null, f.get(), p.get())
										}
									},
								)
							}),
							this
						)
					}),
			(e.renice = function (t) {
				if (
					!di.isWindows &&
					((t = t || 0),
					(t < -20 || t > 20) &&
						this.logger.warn(
							'Invalid niceness value: ' + t + ', must be between -20 and 20',
						),
					(t = Math.min(20, Math.max(-20, t))),
					(this.options.niceness = t),
					this.ffmpegProc)
				) {
					var r = this.logger,
						n = this.ffmpegProc.pid,
						i = rg('renice', [t, '-p', n], { windowsHide: !0 })
					i.on('error', function (o) {
						r.warn('could not renice process ' + n + ': ' + o.message)
					}),
						i.on('exit', function (o, s) {
							s
								? r.warn(
										'could not renice process ' +
											n +
											': renice was killed by signal ' +
											s,
									)
								: o
									? r.warn(
											'could not renice process ' +
												n +
												': renice exited with ' +
												o,
										)
									: r.info(
											'successfully reniced process ' +
												n +
												' to ' +
												t +
												' niceness',
										)
						})
				}
				return this
			}),
			(e.kill = function (t) {
				return (
					this.ffmpegProc
						? this.ffmpegProc.kill(t || 'SIGKILL')
						: this.logger.warn('No running ffmpeg process, cannot send signal'),
					this
				)
			})
	}
})
var T0 = E((sAe, I0) => {
	'use strict'
	var Ec = require('fs'),
		k0 = require('path'),
		ed = Zl(),
		ui = Cn(),
		p6 = /^\s*([D ])([E ])([VAS])([S ])([D ])([T ]) ([^ ]+) +(.*)$/,
		g6 = /^\s*([D\.])([E\.])([VAS])([I\.])([L\.])([S\.]) ([^ ]+) +(.*)$/,
		v6 = /\(encoders:([^\)]+)\)/,
		h6 = /\(decoders:([^\)]+)\)/,
		_6 = /^\s*([VAS\.])([F\.])([S\.])([X\.])([B\.])([D\.]) ([^ ]+) +(.*)$/,
		y6 = /^\s*([D ])([E ])\s+([^ ]+)\s+(.*)$/,
		ng = /\r\n|\r|\n/,
		S6 = /^(?: [T\.][S\.][C\.] )?([^ ]+) +(AA?|VV?|\|)->(AA?|VV?|\|) +(.*)$/,
		Ge = {}
	I0.exports = function (e) {
		;(e.setFfmpegPath = function (t) {
			return (Ge.ffmpegPath = t), this
		}),
			(e.setFfprobePath = function (t) {
				return (Ge.ffprobePath = t), this
			}),
			(e.setFlvtoolPath = function (t) {
				return (Ge.flvtoolPath = t), this
			}),
			(e._forgetPaths = function () {
				delete Ge.ffmpegPath, delete Ge.ffprobePath, delete Ge.flvtoolPath
			}),
			(e._getFfmpegPath = function (t) {
				if ('ffmpegPath' in Ge) return t(null, Ge.ffmpegPath)
				ed.waterfall(
					[
						function (r) {
							process.env.FFMPEG_PATH
								? Ec.exists(process.env.FFMPEG_PATH, function (n) {
										n ? r(null, process.env.FFMPEG_PATH) : r(null, '')
									})
								: r(null, '')
						},
						function (r, n) {
							if (r.length) return n(null, r)
							ui.which('ffmpeg', function (i, o) {
								n(i, o)
							})
						},
					],
					function (r, n) {
						r ? t(r) : t(null, (Ge.ffmpegPath = n || ''))
					},
				)
			}),
			(e._getFfprobePath = function (t) {
				var r = this
				if ('ffprobePath' in Ge) return t(null, Ge.ffprobePath)
				ed.waterfall(
					[
						function (n) {
							process.env.FFPROBE_PATH
								? Ec.exists(process.env.FFPROBE_PATH, function (i) {
										n(null, i ? process.env.FFPROBE_PATH : '')
									})
								: n(null, '')
						},
						function (n, i) {
							if (n.length) return i(null, n)
							ui.which('ffprobe', function (o, s) {
								i(o, s)
							})
						},
						function (n, i) {
							if (n.length) return i(null, n)
							r._getFfmpegPath(function (o, s) {
								if (o) i(o)
								else if (s.length) {
									var c = ui.isWindows ? 'ffprobe.exe' : 'ffprobe',
										l = k0.join(k0.dirname(s), c)
									Ec.exists(l, function (u) {
										i(null, u ? l : '')
									})
								} else i(null, '')
							})
						},
					],
					function (n, i) {
						n ? t(n) : t(null, (Ge.ffprobePath = i || ''))
					},
				)
			}),
			(e._getFlvtoolPath = function (t) {
				if ('flvtoolPath' in Ge) return t(null, Ge.flvtoolPath)
				ed.waterfall(
					[
						function (r) {
							process.env.FLVMETA_PATH
								? Ec.exists(process.env.FLVMETA_PATH, function (n) {
										r(null, n ? process.env.FLVMETA_PATH : '')
									})
								: r(null, '')
						},
						function (r, n) {
							if (r.length) return n(null, r)
							process.env.FLVTOOL2_PATH
								? Ec.exists(process.env.FLVTOOL2_PATH, function (i) {
										n(null, i ? process.env.FLVTOOL2_PATH : '')
									})
								: n(null, '')
						},
						function (r, n) {
							if (r.length) return n(null, r)
							ui.which('flvmeta', function (i, o) {
								n(i, o)
							})
						},
						function (r, n) {
							if (r.length) return n(null, r)
							ui.which('flvtool2', function (i, o) {
								n(i, o)
							})
						},
					],
					function (r, n) {
						r ? t(r) : t(null, (Ge.flvtoolPath = n || ''))
					},
				)
			}),
			(e.availableFilters = e.getAvailableFilters =
				function (t) {
					if ('filters' in Ge) return t(null, Ge.filters)
					this._spawnFfmpeg(
						['-filters'],
						{ captureStdout: !0, stdoutLines: 0 },
						function (r, n) {
							if (r) return t(r)
							var i = n.get(),
								o = i.split(`
`),
								s = {},
								c = { A: 'audio', V: 'video', '|': 'none' }
							o.forEach(function (l) {
								var u = l.match(S6)
								u &&
									(s[u[1]] = {
										description: u[4],
										input: c[u[2].charAt(0)],
										multipleInputs: u[2].length > 1,
										output: c[u[3].charAt(0)],
										multipleOutputs: u[3].length > 1,
									})
							}),
								t(null, (Ge.filters = s))
						},
					)
				}),
			(e.availableCodecs = e.getAvailableCodecs =
				function (t) {
					if ('codecs' in Ge) return t(null, Ge.codecs)
					this._spawnFfmpeg(
						['-codecs'],
						{ captureStdout: !0, stdoutLines: 0 },
						function (r, n) {
							if (r) return t(r)
							var i = n.get(),
								o = i.split(ng),
								s = {}
							o.forEach(function (c) {
								var l = c.match(p6)
								if (
									(l &&
										l[7] !== '=' &&
										(s[l[7]] = {
											type: { V: 'video', A: 'audio', S: 'subtitle' }[l[3]],
											description: l[8],
											canDecode: l[1] === 'D',
											canEncode: l[2] === 'E',
											drawHorizBand: l[4] === 'S',
											directRendering: l[5] === 'D',
											weirdFrameTruncation: l[6] === 'T',
										}),
									(l = c.match(g6)),
									l && l[7] !== '=')
								) {
									var u = (s[l[7]] = {
											type: { V: 'video', A: 'audio', S: 'subtitle' }[l[3]],
											description: l[8],
											canDecode: l[1] === 'D',
											canEncode: l[2] === 'E',
											intraFrameOnly: l[4] === 'I',
											isLossy: l[5] === 'L',
											isLossless: l[6] === 'S',
										}),
										m = u.description.match(v6)
									m = m ? m[1].trim().split(' ') : []
									var f = u.description.match(h6)
									if (
										((f = f ? f[1].trim().split(' ') : []),
										m.length || f.length)
									) {
										var p = {}
										ui.copy(u, p),
											delete p.canEncode,
											delete p.canDecode,
											m.forEach(function (g) {
												;(s[g] = {}), ui.copy(p, s[g]), (s[g].canEncode = !0)
											}),
											f.forEach(function (g) {
												g in s || ((s[g] = {}), ui.copy(p, s[g])),
													(s[g].canDecode = !0)
											})
									}
								}
							}),
								t(null, (Ge.codecs = s))
						},
					)
				}),
			(e.availableEncoders = e.getAvailableEncoders =
				function (t) {
					if ('encoders' in Ge) return t(null, Ge.encoders)
					this._spawnFfmpeg(
						['-encoders'],
						{ captureStdout: !0, stdoutLines: 0 },
						function (r, n) {
							if (r) return t(r)
							var i = n.get(),
								o = i.split(ng),
								s = {}
							o.forEach(function (c) {
								var l = c.match(_6)
								l &&
									l[7] !== '=' &&
									(s[l[7]] = {
										type: { V: 'video', A: 'audio', S: 'subtitle' }[l[1]],
										description: l[8],
										frameMT: l[2] === 'F',
										sliceMT: l[3] === 'S',
										experimental: l[4] === 'X',
										drawHorizBand: l[5] === 'B',
										directRendering: l[6] === 'D',
									})
							}),
								t(null, (Ge.encoders = s))
						},
					)
				}),
			(e.availableFormats = e.getAvailableFormats =
				function (t) {
					if ('formats' in Ge) return t(null, Ge.formats)
					this._spawnFfmpeg(
						['-formats'],
						{ captureStdout: !0, stdoutLines: 0 },
						function (r, n) {
							if (r) return t(r)
							var i = n.get(),
								o = i.split(ng),
								s = {}
							o.forEach(function (c) {
								var l = c.match(y6)
								l &&
									l[3].split(',').forEach(function (u) {
										u in s ||
											(s[u] = { description: l[4], canDemux: !1, canMux: !1 }),
											l[1] === 'D' && (s[u].canDemux = !0),
											l[2] === 'E' && (s[u].canMux = !0)
									})
							}),
								t(null, (Ge.formats = s))
						},
					)
				}),
			(e._checkCapabilities = function (t) {
				var r = this
				ed.waterfall(
					[
						function (n) {
							r.availableFormats(n)
						},
						function (n, i) {
							var o
							if (
								((o = r._outputs.reduce(function (s, c) {
									var l = c.options.find('-f', 1)
									return l && (!(l[0] in n) || !n[l[0]].canMux) && s.push(l), s
								}, [])),
								o.length === 1)
							)
								return i(
									new Error('Output format ' + o[0] + ' is not available'),
								)
							if (o.length > 1)
								return i(
									new Error(
										'Output formats ' + o.join(', ') + ' are not available',
									),
								)
							if (
								((o = r._inputs.reduce(function (s, c) {
									var l = c.options.find('-f', 1)
									return (
										l && (!(l[0] in n) || !n[l[0]].canDemux) && s.push(l[0]), s
									)
								}, [])),
								o.length === 1)
							)
								return i(
									new Error('Input format ' + o[0] + ' is not available'),
								)
							if (o.length > 1)
								return i(
									new Error(
										'Input formats ' + o.join(', ') + ' are not available',
									),
								)
							i()
						},
						function (n) {
							r.availableEncoders(n)
						},
						function (n, i) {
							var o
							if (
								((o = r._outputs.reduce(function (s, c) {
									var l = c.audio.find('-acodec', 1)
									return (
										l &&
											l[0] !== 'copy' &&
											(!(l[0] in n) || n[l[0]].type !== 'audio') &&
											s.push(l[0]),
										s
									)
								}, [])),
								o.length === 1)
							)
								return i(new Error('Audio codec ' + o[0] + ' is not available'))
							if (o.length > 1)
								return i(
									new Error(
										'Audio codecs ' + o.join(', ') + ' are not available',
									),
								)
							if (
								((o = r._outputs.reduce(function (s, c) {
									var l = c.video.find('-vcodec', 1)
									return (
										l &&
											l[0] !== 'copy' &&
											(!(l[0] in n) || n[l[0]].type !== 'video') &&
											s.push(l[0]),
										s
									)
								}, [])),
								o.length === 1)
							)
								return i(new Error('Video codec ' + o[0] + ' is not available'))
							if (o.length > 1)
								return i(
									new Error(
										'Video codecs ' + o.join(', ') + ' are not available',
									),
								)
							i()
						},
					],
					t,
				)
			})
	}
})
var N0 = E((aAe, B0) => {
	'use strict'
	var C6 = require('child_process').spawn
	function E6(e) {
		return e.match(/^TAG:/)
	}
	function b6(e) {
		return e.match(/^DISPOSITION:/)
	}
	function w6(e) {
		var t = e.split(/\r\n|\r|\n/)
		t = t.filter(function (c) {
			return c.length > 0
		})
		var r = { streams: [], format: {}, chapters: [] }
		function n(c) {
			for (var l = {}, u = t.shift(); typeof u < 'u'; ) {
				if (u.toLowerCase() == '[/' + c + ']') return l
				if (u.match(/^\[/)) {
					u = t.shift()
					continue
				}
				var m = u.match(/^([^=]+)=(.*)$/)
				m &&
					(!m[1].match(/^TAG:/) && m[2].match(/^[0-9]+(\.[0-9]+)?$/)
						? (l[m[1]] = Number(m[2]))
						: (l[m[1]] = m[2])),
					(u = t.shift())
			}
			return l
		}
		for (var i = t.shift(); typeof i < 'u'; ) {
			if (i.match(/^\[stream/i)) {
				var o = n('stream')
				r.streams.push(o)
			} else if (i.match(/^\[chapter/i)) {
				var s = n('chapter')
				r.chapters.push(s)
			} else i.toLowerCase() === '[format]' && (r.format = n('format'))
			i = t.shift()
		}
		return r
	}
	B0.exports = function (e) {
		e.ffprobe = function () {
			var t,
				r = null,
				n = [],
				i,
				i = arguments[arguments.length - 1],
				o = !1
			function s(c, l) {
				o || ((o = !0), i(c, l))
			}
			switch (arguments.length) {
				case 3:
					;(r = arguments[0]), (n = arguments[1])
					break
				case 2:
					typeof arguments[0] == 'number'
						? (r = arguments[0])
						: Array.isArray(arguments[0]) && (n = arguments[0])
					break
			}
			if (r === null) {
				if (!this._currentInput) return s(new Error('No input specified'))
				t = this._currentInput
			} else if (((t = this._inputs[r]), !t))
				return s(new Error('Invalid input index'))
			this._getFfprobePath(function (c, l) {
				if (c) return s(c)
				if (!l) return s(new Error('Cannot find ffprobe'))
				var u = '',
					m = !1,
					f = '',
					p = !1,
					g = t.isStream ? 'pipe:0' : t.source,
					v = C6(l, ['-show_streams', '-show_format'].concat(n, g), {
						windowsHide: !0,
					})
				t.isStream &&
					(v.stdin.on('error', function (x) {
						;['ECONNRESET', 'EPIPE', 'EOF'].indexOf(x.code) >= 0 || s(x)
					}),
					v.stdin.on('close', function () {
						t.source.pause(), t.source.unpipe(v.stdin)
					}),
					t.source.pipe(v.stdin)),
					v.on('error', i)
				var _ = null
				function y(x) {
					if ((x && (_ = x), P && m && p)) {
						if (_)
							return (
								f &&
									(_.message +=
										`
` + f),
								s(_)
							)
						var W = w6(u)
						;[W.format].concat(W.streams).forEach(function (X) {
							if (X) {
								var w = Object.keys(X).filter(E6)
								w.length &&
									((X.tags = X.tags || {}),
									w.forEach(function (A) {
										;(X.tags[A.substr(4)] = X[A]), delete X[A]
									}))
								var b = Object.keys(X).filter(b6)
								b.length &&
									((X.disposition = X.disposition || {}),
									b.forEach(function (A) {
										;(X.disposition[A.substr(12)] = X[A]), delete X[A]
									}))
							}
						}),
							s(null, W)
					}
				}
				var P = !1
				v.on('exit', function (x, W) {
					;(P = !0),
						x
							? y(new Error('ffprobe exited with code ' + x))
							: W
								? y(new Error('ffprobe was killed with signal ' + W))
								: y()
				}),
					v.stdout.on('data', function (x) {
						u += x
					}),
					v.stdout.on('close', function () {
						;(m = !0), y()
					}),
					v.stderr.on('data', function (x) {
						f += x
					}),
					v.stderr.on('close', function () {
						;(p = !0), y()
					})
			})
		}
	}
})
var M0 = E((cAe, F0) => {
	'use strict'
	var D0 = require('fs'),
		mi = require('path'),
		x6 = require('stream').PassThrough,
		P6 = Zl(),
		L0 = Cn()
	F0.exports = function (t) {
		;(t.saveToFile = t.save =
			function (r) {
				return this.output(r).run(), this
			}),
			(t.writeToStream =
				t.pipe =
				t.stream =
					function (r, n) {
						if ((r && !('writable' in r) && ((n = r), (r = void 0)), !r)) {
							if (process.version.match(/v0\.8\./))
								throw new Error(
									'PassThrough stream is not supported on node v0.8',
								)
							r = new x6()
						}
						return this.output(r, n).run(), r
					}),
			(t.takeScreenshots =
				t.thumbnail =
				t.thumbnails =
				t.screenshot =
				t.screenshots =
					function (r, n) {
						var i = this,
							o = this._currentInput.source
						if (
							((r = r || { count: 1 }),
							typeof r == 'number' && (r = { count: r }),
							'folder' in r || (r.folder = n || '.'),
							'timestamps' in r && (r.timemarks = r.timestamps),
							!('timemarks' in r))
						) {
							if (!r.count)
								throw new Error(
									'Cannot take screenshots: neither a count nor a timemark list are specified',
								)
							var s = 100 / (1 + r.count)
							r.timemarks = []
							for (var c = 0; c < r.count; c++)
								r.timemarks.push(s * (c + 1) + '%')
						}
						if ('size' in r) {
							var l = r.size.match(/^(\d+)x(\d+)$/),
								u = r.size.match(/^(\d+)x\?$/),
								m = r.size.match(/^\?x(\d+)$/),
								f = r.size.match(/^(\d+)%$/)
							if (!l && !u && !m && !f)
								throw new Error('Invalid size parameter: ' + r.size)
						}
						var p
						function g(v) {
							p
								? v(null, p)
								: i.ffprobe(function (_, y) {
										;(p = y), v(_, y)
									})
						}
						return (
							P6.waterfall(
								[
									function (_) {
										if (
											r.timemarks.some(function (y) {
												return ('' + y).match(/^[\d.]+%$/)
											})
										) {
											if (typeof o != 'string')
												return _(
													new Error(
														'Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks',
													),
												)
											g(function (y, P) {
												if (y) _(y)
												else {
													var x = P.streams.reduce(
														function (X, w) {
															return w.codec_type === 'video' &&
																w.width * w.height > X.width * X.height
																? w
																: X
														},
														{ width: 0, height: 0 },
													)
													if (x.width === 0)
														return _(
															new Error(
																'No video stream in input, cannot take screenshots',
															),
														)
													var W = Number(x.duration)
													if (
														(isNaN(W) && (W = Number(P.format.duration)),
														isNaN(W))
													)
														return _(
															new Error(
																'Could not get input duration, please specify fixed timemarks',
															),
														)
													;(r.timemarks = r.timemarks.map(function (X) {
														return ('' + X).match(/^([\d.]+)%$/)
															? (W * parseFloat(X)) / 100
															: X
													})),
														_()
												}
											})
										} else _()
									},
									function (_) {
										;(r.timemarks = r.timemarks
											.map(function (y) {
												return L0.timemarkToSeconds(y)
											})
											.sort(function (y, P) {
												return y - P
											})),
											_()
									},
									function (_) {
										var y = r.filename || 'tn.png'
										if (
											(y.indexOf('.') === -1 && (y += '.png'),
											r.timemarks.length > 1 && !y.match(/%(s|0*i)/))
										) {
											var P = mi.extname(y)
											y = mi.join(mi.dirname(y), mi.basename(y, P) + '_%i' + P)
										}
										_(null, y)
									},
									function (_, y) {
										if (_.match(/%[bf]/)) {
											if (typeof o != 'string')
												return y(
													new Error(
														'Cannot replace %f or %b when using an input stream',
													),
												)
											_ = _.replace(/%f/g, mi.basename(o)).replace(
												/%b/g,
												mi.basename(o, mi.extname(o)),
											)
										}
										y(null, _)
									},
									function (_, y) {
										if (_.match(/%[whr]/)) {
											if (l) return y(null, _, l[1], l[2])
											g(function (P, x) {
												if (P)
													return y(
														new Error(
															'Could not determine video resolution to replace %w, %h or %r',
														),
													)
												var W = x.streams.reduce(
													function (b, A) {
														return A.codec_type === 'video' &&
															A.width * A.height > b.width * b.height
															? A
															: b
													},
													{ width: 0, height: 0 },
												)
												if (W.width === 0)
													return y(
														new Error(
															'No video stream in input, cannot replace %w, %h or %r',
														),
													)
												var X = W.width,
													w = W.height
												u
													? ((w = (w * Number(u[1])) / X), (X = Number(u[1])))
													: m
														? ((X = (X * Number(m[1])) / w), (w = Number(m[1])))
														: f &&
															((X = (X * Number(f[1])) / 100),
															(w = (w * Number(f[1])) / 100)),
													y(
														null,
														_,
														Math.round(X / 2) * 2,
														Math.round(w / 2) * 2,
													)
											})
										} else y(null, _, -1, -1)
									},
									function (_, y, P, x) {
										;(_ = _.replace(/%r/g, '%wx%h')
											.replace(/%w/g, y)
											.replace(/%h/g, P)),
											x(null, _)
									},
									function (_, y) {
										var P = r.timemarks.map(function (x, W) {
											return _.replace(/%s/g, L0.timemarkToSeconds(x)).replace(
												/%(0*)i/g,
												function (X, w) {
													var b = '' + (W + 1)
													return (
														w.substr(0, Math.max(0, w.length + 1 - b.length)) +
														b
													)
												},
											)
										})
										i.emit('filenames', P), y(null, P)
									},
									function (_, y) {
										D0.exists(r.folder, function (P) {
											P
												? y(null, _)
												: D0.mkdir(r.folder, function (x) {
														x ? y(x) : y(null, _)
													})
										})
									},
								],
								function (_, y) {
									if (_) return i.emit('error', _)
									var P = r.timemarks.length,
										x,
										W = [(x = { filter: 'split', options: P, outputs: [] })]
									if ('size' in r) {
										i.size(r.size)
										var X = i._currentOutput.sizeFilters
											.get()
											.map(function (R, k) {
												return (
													k > 0 && (R.inputs = 'size' + (k - 1)),
													(R.outputs = 'size' + k),
													R
												)
											})
										;(x.inputs = 'size' + (X.length - 1)),
											(W = X.concat(W)),
											i._currentOutput.sizeFilters.clear()
									}
									for (var w = 0, b = 0; b < P; b++) {
										var A = 'screen' + b
										x.outputs.push(A),
											b === 0 && ((w = r.timemarks[b]), i.seekInput(w)),
											i.output(mi.join(r.folder, y[b])).frames(1).map(A),
											b > 0 && i.seek(r.timemarks[b] - w)
									}
									i.complexFilter(W), i.run()
								},
							),
							this
						)
					}),
			(t.mergeToFile =
				t.concatenate =
				t.concat =
					function (r, n) {
						var i = this._inputs.filter(function (s) {
								return !s.isStream
							})[0],
							o = this
						return (
							this.ffprobe(this._inputs.indexOf(i), function (s, c) {
								if (s) return o.emit('error', s)
								var l = c.streams.some(function (m) {
										return m.codec_type === 'audio'
									}),
									u = c.streams.some(function (m) {
										return m.codec_type === 'video'
									})
								o.output(r, n)
									.complexFilter({
										filter: 'concat',
										options: {
											n: o._inputs.length,
											v: u ? 1 : 0,
											a: l ? 1 : 0,
										},
									})
									.run()
							}),
							this
						)
					})
	}
})
var U0 = E((lAe, j0) => {
	'use strict'
	var A6 = require('path'),
		O6 = require('util'),
		q0 = require('events').EventEmitter,
		ig = Cn()
	function be(e, t) {
		if (!(this instanceof be)) return new be(e, t)
		q0.call(this),
			typeof e == 'object' && !('readable' in e)
				? (t = e)
				: ((t = t || {}), (t.source = e)),
			(this._inputs = []),
			t.source && this.input(t.source),
			(this._outputs = []),
			this.output()
		var r = this
		;['_global', '_complexFilters'].forEach(function (n) {
			r[n] = ig.args()
		}),
			(t.stdoutLines = 'stdoutLines' in t ? t.stdoutLines : 100),
			(t.presets = t.presets || t.preset || A6.join(__dirname, 'presets')),
			(t.niceness = t.niceness || t.priority || 0),
			(this.options = t),
			(this.logger = t.logger || {
				debug: function () {},
				info: function () {},
				warn: function () {},
				error: function () {},
			})
	}
	O6.inherits(be, q0)
	j0.exports = be
	be.prototype.clone = function () {
		var e = new be(),
			t = this
		return (
			(e.options = this.options),
			(e.logger = this.logger),
			(e._inputs = this._inputs.map(function (r) {
				return { source: r.source, options: r.options.clone() }
			})),
			'target' in this._outputs[0]
				? ((e._outputs = []), e.output())
				: ((e._outputs = [(e._currentOutput = { flags: {} })]),
					[
						'audio',
						'audioFilters',
						'video',
						'videoFilters',
						'sizeFilters',
						'options',
					].forEach(function (r) {
						e._currentOutput[r] = t._currentOutput[r].clone()
					}),
					this._currentOutput.sizeData &&
						((e._currentOutput.sizeData = {}),
						ig.copy(this._currentOutput.sizeData, e._currentOutput.sizeData)),
					ig.copy(this._currentOutput.flags, e._currentOutput.flags)),
			['_global', '_complexFilters'].forEach(function (r) {
				e[r] = t[r].clone()
			}),
			e
		)
	}
	u0()(be.prototype)
	f0()(be.prototype)
	g0()(be.prototype)
	_0()(be.prototype)
	C0()(be.prototype)
	b0()(be.prototype)
	x0()(be.prototype)
	R0()(be.prototype)
	T0()(be.prototype)
	be.setFfmpegPath = function (e) {
		new be().setFfmpegPath(e)
	}
	be.setFfprobePath = function (e) {
		new be().setFfprobePath(e)
	}
	be.setFlvtoolPath = function (e) {
		new be().setFlvtoolPath(e)
	}
	be.availableFilters = be.getAvailableFilters = function (e) {
		new be().availableFilters(e)
	}
	be.availableCodecs = be.getAvailableCodecs = function (e) {
		new be().availableCodecs(e)
	}
	be.availableFormats = be.getAvailableFormats = function (e) {
		new be().availableFormats(e)
	}
	be.availableEncoders = be.getAvailableEncoders = function (e) {
		new be().availableEncoders(e)
	}
	N0()(be.prototype)
	be.ffprobe = function (e) {
		var t = new be(e)
		t.ffprobe.apply(t, Array.prototype.slice.call(arguments, 1))
	}
	M0()(be.prototype)
})
var z0 = E((dAe, G0) => {
	G0.exports = U0()
})
var en = E((mAe, tE) => {
	var td = Object.defineProperty,
		R6 = Object.getOwnPropertyDescriptor,
		k6 = Object.getOwnPropertyNames,
		I6 = Object.prototype.hasOwnProperty,
		rd = (e, t) => td(e, 'name', { value: t, configurable: !0 }),
		T6 = (e, t) => {
			for (var r in t) td(e, r, { get: t[r], enumerable: !0 })
		},
		B6 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of k6(t))
					!I6.call(e, i) &&
						i !== r &&
						td(e, i, {
							get: () => t[i],
							enumerable: !(n = R6(t, i)) || n.enumerable,
						})
			return e
		},
		N6 = (e) => B6(td({}, '__esModule', { value: !0 }), e),
		K0 = {}
	T6(K0, {
		AlgorithmId: () => J0,
		EndpointURLScheme: () => Y0,
		FieldPosition: () => Q0,
		HttpApiKeyAuthLocation: () => X0,
		HttpAuthLocation: () => W0,
		IniSectionType: () => Z0,
		RequestHandlerProtocol: () => eE,
		SMITHY_CONTEXT_KEY: () => q6,
		getDefaultClientConfiguration: () => F6,
		resolveDefaultRuntimeConfig: () => M6,
	})
	tE.exports = N6(K0)
	var W0 = ((e) => ((e.HEADER = 'header'), (e.QUERY = 'query'), e))(W0 || {}),
		X0 = ((e) => ((e.HEADER = 'header'), (e.QUERY = 'query'), e))(X0 || {}),
		Y0 = ((e) => ((e.HTTP = 'http'), (e.HTTPS = 'https'), e))(Y0 || {}),
		J0 = ((e) => (
			(e.MD5 = 'md5'),
			(e.CRC32 = 'crc32'),
			(e.CRC32C = 'crc32c'),
			(e.SHA1 = 'sha1'),
			(e.SHA256 = 'sha256'),
			e
		))(J0 || {}),
		D6 = rd((e) => {
			let t = []
			return (
				e.sha256 !== void 0 &&
					t.push({
						algorithmId: () => 'sha256',
						checksumConstructor: () => e.sha256,
					}),
				e.md5 != null &&
					t.push({
						algorithmId: () => 'md5',
						checksumConstructor: () => e.md5,
					}),
				{
					_checksumAlgorithms: t,
					addChecksumAlgorithm(r) {
						this._checksumAlgorithms.push(r)
					},
					checksumAlgorithms() {
						return this._checksumAlgorithms
					},
				}
			)
		}, 'getChecksumConfiguration'),
		L6 = rd((e) => {
			let t = {}
			return (
				e.checksumAlgorithms().forEach((r) => {
					t[r.algorithmId()] = r.checksumConstructor()
				}),
				t
			)
		}, 'resolveChecksumRuntimeConfig'),
		F6 = rd((e) => ({ ...D6(e) }), 'getDefaultClientConfiguration'),
		M6 = rd((e) => ({ ...L6(e) }), 'resolveDefaultRuntimeConfig'),
		Q0 = ((e) => (
			(e[(e.HEADER = 0)] = 'HEADER'), (e[(e.TRAILER = 1)] = 'TRAILER'), e
		))(Q0 || {}),
		q6 = '__smithy_context',
		Z0 = ((e) => (
			(e.PROFILE = 'profile'),
			(e.SSO_SESSION = 'sso-session'),
			(e.SERVICES = 'services'),
			e
		))(Z0 || {}),
		eE = ((e) => (
			(e.HTTP_0_9 = 'http/0.9'),
			(e.HTTP_1_0 = 'http/1.0'),
			(e.TDS_8_0 = 'tds/8.0'),
			e
		))(eE || {})
})
var Xe = E((vAe, dE) => {
	var nd = Object.defineProperty,
		j6 = Object.getOwnPropertyDescriptor,
		U6 = Object.getOwnPropertyNames,
		G6 = Object.prototype.hasOwnProperty,
		fi = (e, t) => nd(e, 'name', { value: t, configurable: !0 }),
		z6 = (e, t) => {
			for (var r in t) nd(e, r, { get: t[r], enumerable: !0 })
		},
		H6 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of U6(t))
					!G6.call(e, i) &&
						i !== r &&
						nd(e, i, {
							get: () => t[i],
							enumerable: !(n = j6(t, i)) || n.enumerable,
						})
			return e
		},
		$6 = (e) => H6(nd({}, '__esModule', { value: !0 }), e),
		rE = {}
	z6(rE, {
		Field: () => W6,
		Fields: () => X6,
		HttpRequest: () => Y6,
		HttpResponse: () => J6,
		IHttpRequest: () => nE.HttpRequest,
		getHttpHandlerExtensionConfiguration: () => V6,
		isValidHostname: () => lE,
		resolveHttpHandlerRuntimeConfig: () => K6,
	})
	dE.exports = $6(rE)
	var V6 = fi((e) => {
			let t = e.httpHandler
			return {
				setHttpHandler(r) {
					t = r
				},
				httpHandler() {
					return t
				},
				updateHttpClientConfig(r, n) {
					t.updateHttpClientConfig(r, n)
				},
				httpHandlerConfigs() {
					return t.httpHandlerConfigs()
				},
			}
		}, 'getHttpHandlerExtensionConfiguration'),
		K6 = fi(
			(e) => ({ httpHandler: e.httpHandler() }),
			'resolveHttpHandlerRuntimeConfig',
		),
		nE = en(),
		iE = class {
			constructor({
				name: t,
				kind: r = nE.FieldPosition.HEADER,
				values: n = [],
			}) {
				;(this.name = t), (this.kind = r), (this.values = n)
			}
			add(t) {
				this.values.push(t)
			}
			set(t) {
				this.values = t
			}
			remove(t) {
				this.values = this.values.filter((r) => r !== t)
			}
			toString() {
				return this.values
					.map((t) => (t.includes(',') || t.includes(' ') ? `"${t}"` : t))
					.join(', ')
			}
			get() {
				return this.values
			}
		}
	fi(iE, 'Field')
	var W6 = iE,
		oE = class {
			constructor({ fields: t = [], encoding: r = 'utf-8' }) {
				;(this.entries = {}),
					t.forEach(this.setField.bind(this)),
					(this.encoding = r)
			}
			setField(t) {
				this.entries[t.name.toLowerCase()] = t
			}
			getField(t) {
				return this.entries[t.toLowerCase()]
			}
			removeField(t) {
				delete this.entries[t.toLowerCase()]
			}
			getByType(t) {
				return Object.values(this.entries).filter((r) => r.kind === t)
			}
		}
	fi(oE, 'Fields')
	var X6 = oE,
		sE = class og {
			constructor(t) {
				;(this.method = t.method || 'GET'),
					(this.hostname = t.hostname || 'localhost'),
					(this.port = t.port),
					(this.query = t.query || {}),
					(this.headers = t.headers || {}),
					(this.body = t.body),
					(this.protocol = t.protocol
						? t.protocol.slice(-1) !== ':'
							? `${t.protocol}:`
							: t.protocol
						: 'https:'),
					(this.path = t.path
						? t.path.charAt(0) !== '/'
							? `/${t.path}`
							: t.path
						: '/'),
					(this.username = t.username),
					(this.password = t.password),
					(this.fragment = t.fragment)
			}
			static clone(t) {
				let r = new og({ ...t, headers: { ...t.headers } })
				return r.query && (r.query = aE(r.query)), r
			}
			static isInstance(t) {
				if (!t) return !1
				let r = t
				return (
					'method' in r &&
					'protocol' in r &&
					'hostname' in r &&
					'path' in r &&
					typeof r.query == 'object' &&
					typeof r.headers == 'object'
				)
			}
			clone() {
				return og.clone(this)
			}
		}
	fi(sE, 'HttpRequest')
	var Y6 = sE
	function aE(e) {
		return Object.keys(e).reduce((t, r) => {
			let n = e[r]
			return { ...t, [r]: Array.isArray(n) ? [...n] : n }
		}, {})
	}
	fi(aE, 'cloneQuery')
	var cE = class {
		constructor(t) {
			;(this.statusCode = t.statusCode),
				(this.reason = t.reason),
				(this.headers = t.headers || {}),
				(this.body = t.body)
		}
		static isInstance(t) {
			if (!t) return !1
			let r = t
			return typeof r.statusCode == 'number' && typeof r.headers == 'object'
		}
	}
	fi(cE, 'HttpResponse')
	var J6 = cE
	function lE(e) {
		return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(e)
	}
	fi(lE, 'isValidHostname')
})
var gE = E((hAe, pE) => {
	'use strict'
	var id = Object.defineProperty,
		Q6 = Object.getOwnPropertyDescriptor,
		Z6 = Object.getOwnPropertyNames,
		e4 = Object.prototype.hasOwnProperty,
		uE = (e, t) => id(e, 'name', { value: t, configurable: !0 }),
		t4 = (e, t) => {
			for (var r in t) id(e, r, { get: t[r], enumerable: !0 })
		},
		r4 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Z6(t))
					!e4.call(e, i) &&
						i !== r &&
						id(e, i, {
							get: () => t[i],
							enumerable: !(n = Q6(t, i)) || n.enumerable,
						})
			return e
		},
		n4 = (e) => r4(id({}, '__esModule', { value: !0 }), e),
		mE = {}
	t4(mE, {
		addExpectContinueMiddleware: () => sg,
		addExpectContinueMiddlewareOptions: () => fE,
		getAddExpectContinuePlugin: () => o4,
	})
	pE.exports = n4(mE)
	var i4 = Xe()
	function sg(e) {
		return (t) => async (r) => {
			var n, i
			let { request: o } = r
			return (
				i4.HttpRequest.isInstance(o) &&
					o.body &&
					e.runtime === 'node' &&
					((i = (n = e.requestHandler) == null ? void 0 : n.constructor) == null
						? void 0
						: i.name) !== 'FetchHttpHandler' &&
					(o.headers = { ...o.headers, Expect: '100-continue' }),
				t({ ...r, request: o })
			)
		}
	}
	uE(sg, 'addExpectContinueMiddleware')
	var fE = {
			step: 'build',
			tags: ['SET_EXPECT_HEADER', 'EXPECT_HEADER'],
			name: 'addExpectContinueMiddleware',
			override: !0,
		},
		o4 = uE(
			(e) => ({
				applyToStack: (t) => {
					t.add(sg(e), fE)
				},
			}),
			'getAddExpectContinuePlugin',
		)
})
var bc = E((_Ae, SE) => {
	'use strict'
	var od = Object.defineProperty,
		s4 = Object.getOwnPropertyDescriptor,
		a4 = Object.getOwnPropertyNames,
		c4 = Object.prototype.hasOwnProperty,
		ag = (e, t) => od(e, 'name', { value: t, configurable: !0 }),
		l4 = (e, t) => {
			for (var r in t) od(e, r, { get: t[r], enumerable: !0 })
		},
		d4 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of a4(t))
					!c4.call(e, i) &&
						i !== r &&
						od(e, i, {
							get: () => t[i],
							enumerable: !(n = s4(t, i)) || n.enumerable,
						})
			return e
		},
		u4 = (e) => d4(od({}, '__esModule', { value: !0 }), e),
		vE = {}
	l4(vE, {
		getHostHeaderPlugin: () => f4,
		hostHeaderMiddleware: () => _E,
		hostHeaderMiddlewareOptions: () => yE,
		resolveHostHeaderConfig: () => hE,
	})
	SE.exports = u4(vE)
	var m4 = Xe()
	function hE(e) {
		return e
	}
	ag(hE, 'resolveHostHeaderConfig')
	var _E = ag(
			(e) => (t) => async (r) => {
				if (!m4.HttpRequest.isInstance(r.request)) return t(r)
				let { request: n } = r,
					{ handlerProtocol: i = '' } = e.requestHandler.metadata || {}
				if (i.indexOf('h2') >= 0 && !n.headers[':authority'])
					delete n.headers.host,
						(n.headers[':authority'] =
							n.hostname + (n.port ? ':' + n.port : ''))
				else if (!n.headers.host) {
					let o = n.hostname
					n.port != null && (o += `:${n.port}`), (n.headers.host = o)
				}
				return t(r)
			},
			'hostHeaderMiddleware',
		),
		yE = {
			name: 'hostHeaderMiddleware',
			step: 'build',
			priority: 'low',
			tags: ['HOST'],
			override: !0,
		},
		f4 = ag(
			(e) => ({
				applyToStack: (t) => {
					t.add(_E(e), yE)
				},
			}),
			'getHostHeaderPlugin',
		)
})
var wc = E((yAe, xE) => {
	'use strict'
	var sd = Object.defineProperty,
		p4 = Object.getOwnPropertyDescriptor,
		g4 = Object.getOwnPropertyNames,
		v4 = Object.prototype.hasOwnProperty,
		CE = (e, t) => sd(e, 'name', { value: t, configurable: !0 }),
		h4 = (e, t) => {
			for (var r in t) sd(e, r, { get: t[r], enumerable: !0 })
		},
		_4 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of g4(t))
					!v4.call(e, i) &&
						i !== r &&
						sd(e, i, {
							get: () => t[i],
							enumerable: !(n = p4(t, i)) || n.enumerable,
						})
			return e
		},
		y4 = (e) => _4(sd({}, '__esModule', { value: !0 }), e),
		EE = {}
	h4(EE, {
		getLoggerPlugin: () => S4,
		loggerMiddleware: () => bE,
		loggerMiddlewareOptions: () => wE,
	})
	xE.exports = y4(EE)
	var bE = CE(
			() => (e, t) => async (r) => {
				var n, i
				try {
					let o = await e(r),
						{
							clientName: s,
							commandName: c,
							logger: l,
							dynamoDbDocumentClientOptions: u = {},
						} = t,
						{
							overrideInputFilterSensitiveLog: m,
							overrideOutputFilterSensitiveLog: f,
						} = u,
						p = m ?? t.inputFilterSensitiveLog,
						g = f ?? t.outputFilterSensitiveLog,
						{ $metadata: v, ..._ } = o.output
					return (
						(n = l?.info) == null ||
							n.call(l, {
								clientName: s,
								commandName: c,
								input: p(r.input),
								output: g(_),
								metadata: v,
							}),
						o
					)
				} catch (o) {
					let {
							clientName: s,
							commandName: c,
							logger: l,
							dynamoDbDocumentClientOptions: u = {},
						} = t,
						{ overrideInputFilterSensitiveLog: m } = u,
						f = m ?? t.inputFilterSensitiveLog
					throw (
						((i = l?.error) == null ||
							i.call(l, {
								clientName: s,
								commandName: c,
								input: f(r.input),
								error: o,
								metadata: o.$metadata,
							}),
						o)
					)
				}
			},
			'loggerMiddleware',
		),
		wE = {
			name: 'loggerMiddleware',
			tags: ['LOGGER'],
			step: 'initialize',
			override: !0,
		},
		S4 = CE(
			(e) => ({
				applyToStack: (t) => {
					t.add(bE(), wE)
				},
			}),
			'getLoggerPlugin',
		)
})
var xc = E((SAe, kE) => {
	'use strict'
	var ad = Object.defineProperty,
		C4 = Object.getOwnPropertyDescriptor,
		E4 = Object.getOwnPropertyNames,
		b4 = Object.prototype.hasOwnProperty,
		cg = (e, t) => ad(e, 'name', { value: t, configurable: !0 }),
		w4 = (e, t) => {
			for (var r in t) ad(e, r, { get: t[r], enumerable: !0 })
		},
		x4 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of E4(t))
					!b4.call(e, i) &&
						i !== r &&
						ad(e, i, {
							get: () => t[i],
							enumerable: !(n = C4(t, i)) || n.enumerable,
						})
			return e
		},
		P4 = (e) => x4(ad({}, '__esModule', { value: !0 }), e),
		AE = {}
	w4(AE, {
		addRecursionDetectionMiddlewareOptions: () => RE,
		getRecursionDetectionPlugin: () => k4,
		recursionDetectionMiddleware: () => OE,
	})
	kE.exports = P4(AE)
	var A4 = Xe(),
		PE = 'X-Amzn-Trace-Id',
		O4 = 'AWS_LAMBDA_FUNCTION_NAME',
		R4 = '_X_AMZN_TRACE_ID',
		OE = cg(
			(e) => (t) => async (r) => {
				let { request: n } = r
				if (
					!A4.HttpRequest.isInstance(n) ||
					e.runtime !== 'node' ||
					n.headers.hasOwnProperty(PE)
				)
					return t(r)
				let i = process.env[O4],
					o = process.env[R4],
					s = cg((c) => typeof c == 'string' && c.length > 0, 'nonEmptyString')
				return s(i) && s(o) && (n.headers[PE] = o), t({ ...r, request: n })
			},
			'recursionDetectionMiddleware',
		),
		RE = {
			step: 'build',
			tags: ['RECURSION_DETECTION'],
			name: 'recursionDetectionMiddleware',
			override: !0,
			priority: 'low',
		},
		k4 = cg(
			(e) => ({
				applyToStack: (t) => {
					t.add(OE(e), RE)
				},
			}),
			'getRecursionDetectionPlugin',
		)
})
var DE = E((CAe, NE) => {
	var cd = Object.defineProperty,
		I4 = Object.getOwnPropertyDescriptor,
		T4 = Object.getOwnPropertyNames,
		B4 = Object.prototype.hasOwnProperty,
		Ir = (e, t) => cd(e, 'name', { value: t, configurable: !0 }),
		N4 = (e, t) => {
			for (var r in t) cd(e, r, { get: t[r], enumerable: !0 })
		},
		D4 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of T4(t))
					!B4.call(e, i) &&
						i !== r &&
						cd(e, i, {
							get: () => t[i],
							enumerable: !(n = I4(t, i)) || n.enumerable,
						})
			return e
		},
		L4 = (e) => D4(cd({}, '__esModule', { value: !0 }), e),
		BE = {}
	N4(BE, { constructStack: () => lg })
	NE.exports = L4(BE)
	var ao = Ir((e, t) => {
			let r = []
			if ((e && r.push(e), t)) for (let n of t) r.push(n)
			return r
		}, 'getAllAliases'),
		pi = Ir(
			(e, t) =>
				`${e || 'anonymous'}${t && t.length > 0 ? ` (a.k.a. ${t.join(',')})` : ''}`,
			'getMiddlewareNameWithAliases',
		),
		lg = Ir(() => {
			let e = [],
				t = [],
				r = !1,
				n = new Set(),
				i = Ir(
					(f) =>
						f.sort(
							(p, g) =>
								IE[g.step] - IE[p.step] ||
								TE[g.priority || 'normal'] - TE[p.priority || 'normal'],
						),
					'sort',
				),
				o = Ir((f) => {
					let p = !1,
						g = Ir((v) => {
							let _ = ao(v.name, v.aliases)
							if (_.includes(f)) {
								p = !0
								for (let y of _) n.delete(y)
								return !1
							}
							return !0
						}, 'filterCb')
					return (e = e.filter(g)), (t = t.filter(g)), p
				}, 'removeByName'),
				s = Ir((f) => {
					let p = !1,
						g = Ir((v) => {
							if (v.middleware === f) {
								p = !0
								for (let _ of ao(v.name, v.aliases)) n.delete(_)
								return !1
							}
							return !0
						}, 'filterCb')
					return (e = e.filter(g)), (t = t.filter(g)), p
				}, 'removeByReference'),
				c = Ir((f) => {
					var p
					return (
						e.forEach((g) => {
							f.add(g.middleware, { ...g })
						}),
						t.forEach((g) => {
							f.addRelativeTo(g.middleware, { ...g })
						}),
						(p = f.identifyOnResolve) == null ||
							p.call(f, m.identifyOnResolve()),
						f
					)
				}, 'cloneTo'),
				l = Ir((f) => {
					let p = []
					return (
						f.before.forEach((g) => {
							g.before.length === 0 && g.after.length === 0
								? p.push(g)
								: p.push(...l(g))
						}),
						p.push(f),
						f.after.reverse().forEach((g) => {
							g.before.length === 0 && g.after.length === 0
								? p.push(g)
								: p.push(...l(g))
						}),
						p
					)
				}, 'expandRelativeMiddlewareList'),
				u = Ir((f = !1) => {
					let p = [],
						g = [],
						v = {}
					return (
						e.forEach((y) => {
							let P = { ...y, before: [], after: [] }
							for (let x of ao(P.name, P.aliases)) v[x] = P
							p.push(P)
						}),
						t.forEach((y) => {
							let P = { ...y, before: [], after: [] }
							for (let x of ao(P.name, P.aliases)) v[x] = P
							g.push(P)
						}),
						g.forEach((y) => {
							if (y.toMiddleware) {
								let P = v[y.toMiddleware]
								if (P === void 0) {
									if (f) return
									throw new Error(
										`${y.toMiddleware} is not found when adding ${pi(y.name, y.aliases)} middleware ${y.relation} ${y.toMiddleware}`,
									)
								}
								y.relation === 'after' && P.after.push(y),
									y.relation === 'before' && P.before.push(y)
							}
						}),
						i(p)
							.map(l)
							.reduce((y, P) => (y.push(...P), y), [])
					)
				}, 'getMiddlewareList'),
				m = {
					add: (f, p = {}) => {
						let { name: g, override: v, aliases: _ } = p,
							y = {
								step: 'initialize',
								priority: 'normal',
								middleware: f,
								...p,
							},
							P = ao(g, _)
						if (P.length > 0) {
							if (P.some((x) => n.has(x))) {
								if (!v)
									throw new Error(`Duplicate middleware name '${pi(g, _)}'`)
								for (let x of P) {
									let W = e.findIndex((w) => {
										var b
										return (
											w.name === x ||
											((b = w.aliases) == null
												? void 0
												: b.some((A) => A === x))
										)
									})
									if (W === -1) continue
									let X = e[W]
									if (X.step !== y.step || y.priority !== X.priority)
										throw new Error(
											`"${pi(X.name, X.aliases)}" middleware with ${X.priority} priority in ${X.step} step cannot be overridden by "${pi(g, _)}" middleware with ${y.priority} priority in ${y.step} step.`,
										)
									e.splice(W, 1)
								}
							}
							for (let x of P) n.add(x)
						}
						e.push(y)
					},
					addRelativeTo: (f, p) => {
						let { name: g, override: v, aliases: _ } = p,
							y = { middleware: f, ...p },
							P = ao(g, _)
						if (P.length > 0) {
							if (P.some((x) => n.has(x))) {
								if (!v)
									throw new Error(`Duplicate middleware name '${pi(g, _)}'`)
								for (let x of P) {
									let W = t.findIndex((w) => {
										var b
										return (
											w.name === x ||
											((b = w.aliases) == null
												? void 0
												: b.some((A) => A === x))
										)
									})
									if (W === -1) continue
									let X = t[W]
									if (
										X.toMiddleware !== y.toMiddleware ||
										X.relation !== y.relation
									)
										throw new Error(
											`"${pi(X.name, X.aliases)}" middleware ${X.relation} "${X.toMiddleware}" middleware cannot be overridden by "${pi(g, _)}" middleware ${y.relation} "${y.toMiddleware}" middleware.`,
										)
									t.splice(W, 1)
								}
							}
							for (let x of P) n.add(x)
						}
						t.push(y)
					},
					clone: () => c(lg()),
					use: (f) => {
						f.applyToStack(m)
					},
					remove: (f) => (typeof f == 'string' ? o(f) : s(f)),
					removeByTag: (f) => {
						let p = !1,
							g = Ir((v) => {
								let { tags: _, name: y, aliases: P } = v
								if (_ && _.includes(f)) {
									let x = ao(y, P)
									for (let W of x) n.delete(W)
									return (p = !0), !1
								}
								return !0
							}, 'filterCb')
						return (e = e.filter(g)), (t = t.filter(g)), p
					},
					concat: (f) => {
						var p
						let g = c(lg())
						return (
							g.use(f),
							g.identifyOnResolve(
								r ||
									g.identifyOnResolve() ||
									(((p = f.identifyOnResolve) == null ? void 0 : p.call(f)) ??
										!1),
							),
							g
						)
					},
					applyToStack: c,
					identify: () =>
						u(!0).map((f) => {
							let p = f.step ?? f.relation + ' ' + f.toMiddleware
							return pi(f.name, f.aliases) + ' - ' + p
						}),
					identifyOnResolve(f) {
						return typeof f == 'boolean' && (r = f), r
					},
					resolve: (f, p) => {
						for (let g of u()
							.map((v) => v.middleware)
							.reverse())
							f = g(f, p)
						return r && console.log(m.identify()), f
					},
				}
			return m
		}, 'constructStack'),
		IE = {
			initialize: 5,
			serialize: 4,
			build: 3,
			finalizeRequest: 2,
			deserialize: 1,
		},
		TE = { high: 3, normal: 2, low: 1 }
})
var dd = E((EAe, FE) => {
	var ld = Object.defineProperty,
		F4 = Object.getOwnPropertyDescriptor,
		M4 = Object.getOwnPropertyNames,
		q4 = Object.prototype.hasOwnProperty,
		j4 = (e, t) => ld(e, 'name', { value: t, configurable: !0 }),
		U4 = (e, t) => {
			for (var r in t) ld(e, r, { get: t[r], enumerable: !0 })
		},
		G4 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of M4(t))
					!q4.call(e, i) &&
						i !== r &&
						ld(e, i, {
							get: () => t[i],
							enumerable: !(n = F4(t, i)) || n.enumerable,
						})
			return e
		},
		z4 = (e) => G4(ld({}, '__esModule', { value: !0 }), e),
		LE = {}
	U4(LE, { isArrayBuffer: () => H4 })
	FE.exports = z4(LE)
	var H4 = j4(
		(e) =>
			(typeof ArrayBuffer == 'function' && e instanceof ArrayBuffer) ||
			Object.prototype.toString.call(e) === '[object ArrayBuffer]',
		'isArrayBuffer',
	)
})
var Cs = E((bAe, jE) => {
	var ud = Object.defineProperty,
		$4 = Object.getOwnPropertyDescriptor,
		V4 = Object.getOwnPropertyNames,
		K4 = Object.prototype.hasOwnProperty,
		ME = (e, t) => ud(e, 'name', { value: t, configurable: !0 }),
		W4 = (e, t) => {
			for (var r in t) ud(e, r, { get: t[r], enumerable: !0 })
		},
		X4 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of V4(t))
					!K4.call(e, i) &&
						i !== r &&
						ud(e, i, {
							get: () => t[i],
							enumerable: !(n = $4(t, i)) || n.enumerable,
						})
			return e
		},
		Y4 = (e) => X4(ud({}, '__esModule', { value: !0 }), e),
		qE = {}
	W4(qE, { fromArrayBuffer: () => Q4, fromString: () => Z4 })
	jE.exports = Y4(qE)
	var J4 = dd(),
		dg = require('buffer'),
		Q4 = ME((e, t = 0, r = e.byteLength - t) => {
			if (!(0, J4.isArrayBuffer)(e))
				throw new TypeError(
					`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`,
				)
			return dg.Buffer.from(e, t, r)
		}, 'fromArrayBuffer'),
		Z4 = ME((e, t) => {
			if (typeof e != 'string')
				throw new TypeError(
					`The "input" argument must be of type string. Received type ${typeof e} (${e})`,
				)
			return t ? dg.Buffer.from(e, t) : dg.Buffer.from(e)
		}, 'fromString')
})
var UE = E((md) => {
	'use strict'
	Object.defineProperty(md, '__esModule', { value: !0 })
	md.fromBase64 = void 0
	var eV = Cs(),
		tV = /^[A-Za-z0-9+/]*={0,2}$/,
		rV = (e) => {
			if ((e.length * 3) % 4 !== 0)
				throw new TypeError('Incorrect padding on base64 string.')
			if (!tV.exec(e)) throw new TypeError('Invalid base64 string.')
			let t = (0, eV.fromString)(e, 'base64')
			return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
		}
	md.fromBase64 = rV
})
var rr = E((xAe, $E) => {
	var fd = Object.defineProperty,
		nV = Object.getOwnPropertyDescriptor,
		iV = Object.getOwnPropertyNames,
		oV = Object.prototype.hasOwnProperty,
		ug = (e, t) => fd(e, 'name', { value: t, configurable: !0 }),
		sV = (e, t) => {
			for (var r in t) fd(e, r, { get: t[r], enumerable: !0 })
		},
		aV = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of iV(t))
					!oV.call(e, i) &&
						i !== r &&
						fd(e, i, {
							get: () => t[i],
							enumerable: !(n = nV(t, i)) || n.enumerable,
						})
			return e
		},
		cV = (e) => aV(fd({}, '__esModule', { value: !0 }), e),
		GE = {}
	sV(GE, { fromUtf8: () => HE, toUint8Array: () => lV, toUtf8: () => dV })
	$E.exports = cV(GE)
	var zE = Cs(),
		HE = ug((e) => {
			let t = (0, zE.fromString)(e, 'utf8')
			return new Uint8Array(
				t.buffer,
				t.byteOffset,
				t.byteLength / Uint8Array.BYTES_PER_ELEMENT,
			)
		}, 'fromUtf8'),
		lV = ug(
			(e) =>
				typeof e == 'string'
					? HE(e)
					: ArrayBuffer.isView(e)
						? new Uint8Array(
								e.buffer,
								e.byteOffset,
								e.byteLength / Uint8Array.BYTES_PER_ELEMENT,
							)
						: new Uint8Array(e),
			'toUint8Array',
		),
		dV = ug((e) => {
			if (typeof e == 'string') return e
			if (
				typeof e != 'object' ||
				typeof e.byteOffset != 'number' ||
				typeof e.byteLength != 'number'
			)
				throw new Error(
					'@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.',
				)
			return (0, zE.fromArrayBuffer)(
				e.buffer,
				e.byteOffset,
				e.byteLength,
			).toString('utf8')
		}, 'toUtf8')
})
var VE = E((pd) => {
	'use strict'
	Object.defineProperty(pd, '__esModule', { value: !0 })
	pd.toBase64 = void 0
	var uV = Cs(),
		mV = rr(),
		fV = (e) => {
			let t
			if (
				(typeof e == 'string' ? (t = (0, mV.fromUtf8)(e)) : (t = e),
				typeof t != 'object' ||
					typeof t.byteOffset != 'number' ||
					typeof t.byteLength != 'number')
			)
				throw new Error(
					'@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.',
				)
			return (0, uV.fromArrayBuffer)(
				t.buffer,
				t.byteOffset,
				t.byteLength,
			).toString('base64')
		}
	pd.toBase64 = fV
})
var gi = E((AAe, gd) => {
	var KE = Object.defineProperty,
		pV = Object.getOwnPropertyDescriptor,
		gV = Object.getOwnPropertyNames,
		vV = Object.prototype.hasOwnProperty,
		mg = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of gV(t))
					!vV.call(e, i) &&
						i !== r &&
						KE(e, i, {
							get: () => t[i],
							enumerable: !(n = pV(t, i)) || n.enumerable,
						})
			return e
		},
		WE = (e, t, r) => (mg(e, t, 'default'), r && mg(r, t, 'default')),
		hV = (e) => mg(KE({}, '__esModule', { value: !0 }), e),
		fg = {}
	gd.exports = hV(fg)
	WE(fg, UE(), gd.exports)
	WE(fg, VE(), gd.exports)
})
var XE = E((vd) => {
	'use strict'
	Object.defineProperty(vd, '__esModule', { value: !0 })
	vd.getAwsChunkedEncodingStream = void 0
	var _V = require('stream'),
		yV = (e, t) => {
			let {
					base64Encoder: r,
					bodyLengthChecker: n,
					checksumAlgorithmFn: i,
					checksumLocationName: o,
					streamHasher: s,
				} = t,
				c = r !== void 0 && i !== void 0 && o !== void 0 && s !== void 0,
				l = c ? s(i, e) : void 0,
				u = new _V.Readable({ read: () => {} })
			return (
				e.on('data', (m) => {
					let f = n(m) || 0
					u.push(`${f.toString(16)}\r
`),
						u.push(m),
						u.push(`\r
`)
				}),
				e.on('end', async () => {
					if (
						(u.push(`0\r
`),
						c)
					) {
						let m = r(await l)
						u.push(`${o}:${m}\r
`),
							u.push(`\r
`)
					}
					u.push(null)
				}),
				u
			)
		}
	vd.getAwsChunkedEncodingStream = yV
})
var gg = E((RAe, QE) => {
	var hd = Object.defineProperty,
		SV = Object.getOwnPropertyDescriptor,
		CV = Object.getOwnPropertyNames,
		EV = Object.prototype.hasOwnProperty,
		pg = (e, t) => hd(e, 'name', { value: t, configurable: !0 }),
		bV = (e, t) => {
			for (var r in t) hd(e, r, { get: t[r], enumerable: !0 })
		},
		wV = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of CV(t))
					!EV.call(e, i) &&
						i !== r &&
						hd(e, i, {
							get: () => t[i],
							enumerable: !(n = SV(t, i)) || n.enumerable,
						})
			return e
		},
		xV = (e) => wV(hd({}, '__esModule', { value: !0 }), e),
		YE = {}
	bV(YE, { escapeUri: () => JE, escapeUriPath: () => AV })
	QE.exports = xV(YE)
	var JE = pg(
			(e) => encodeURIComponent(e).replace(/[!'()*]/g, PV),
			'escapeUri',
		),
		PV = pg(
			(e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`,
			'hexEncode',
		),
		AV = pg((e) => e.split('/').map(JE).join('/'), 'escapeUriPath')
})
var hg = E((kAe, tb) => {
	var _d = Object.defineProperty,
		OV = Object.getOwnPropertyDescriptor,
		RV = Object.getOwnPropertyNames,
		kV = Object.prototype.hasOwnProperty,
		IV = (e, t) => _d(e, 'name', { value: t, configurable: !0 }),
		TV = (e, t) => {
			for (var r in t) _d(e, r, { get: t[r], enumerable: !0 })
		},
		BV = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of RV(t))
					!kV.call(e, i) &&
						i !== r &&
						_d(e, i, {
							get: () => t[i],
							enumerable: !(n = OV(t, i)) || n.enumerable,
						})
			return e
		},
		NV = (e) => BV(_d({}, '__esModule', { value: !0 }), e),
		ZE = {}
	TV(ZE, { buildQueryString: () => eb })
	tb.exports = NV(ZE)
	var vg = gg()
	function eb(e) {
		let t = []
		for (let r of Object.keys(e).sort()) {
			let n = e[r]
			if (((r = (0, vg.escapeUri)(r)), Array.isArray(n)))
				for (let i = 0, o = n.length; i < o; i++)
					t.push(`${r}=${(0, vg.escapeUri)(n[i])}`)
			else {
				let i = r
				;(n || typeof n == 'string') && (i += `=${(0, vg.escapeUri)(n)}`),
					t.push(i)
			}
		}
		return t.join('&')
	}
	IV(eb, 'buildQueryString')
})
var co = E((NAe, _b) => {
	var DV = Object.create,
		Pc = Object.defineProperty,
		LV = Object.getOwnPropertyDescriptor,
		FV = Object.getOwnPropertyNames,
		MV = Object.getPrototypeOf,
		qV = Object.prototype.hasOwnProperty,
		ut = (e, t) => Pc(e, 'name', { value: t, configurable: !0 }),
		jV = (e, t) => {
			for (var r in t) Pc(e, r, { get: t[r], enumerable: !0 })
		},
		ib = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of FV(t))
					!qV.call(e, i) &&
						i !== r &&
						Pc(e, i, {
							get: () => t[i],
							enumerable: !(n = LV(t, i)) || n.enumerable,
						})
			return e
		},
		UV = (e, t, r) => (
			(r = e != null ? DV(MV(e)) : {}),
			ib(
				t || !e || !e.__esModule
					? Pc(r, 'default', { value: e, enumerable: !0 })
					: r,
				e,
			)
		),
		GV = (e) => ib(Pc({}, '__esModule', { value: !0 }), e),
		ob = {}
	jV(ob, {
		DEFAULT_REQUEST_TIMEOUT: () => KV,
		NodeHttp2Handler: () => QV,
		NodeHttpHandler: () => WV,
		streamCollector: () => e8,
	})
	_b.exports = GV(ob)
	var sb = Xe(),
		ab = hg(),
		_g = require('http'),
		yg = require('https'),
		zV = ['ECONNRESET', 'EPIPE', 'ETIMEDOUT'],
		cb = ut((e) => {
			let t = {}
			for (let r of Object.keys(e)) {
				let n = e[r]
				t[r] = Array.isArray(n) ? n.join(',') : n
			}
			return t
		}, 'getTransformedHeaders'),
		HV = ut((e, t, r = 0) => {
			if (!r) return
			let n = setTimeout(() => {
				e.destroy(),
					t(
						Object.assign(
							new Error(
								`Socket timed out without establishing a connection within ${r} ms`,
							),
							{ name: 'TimeoutError' },
						),
					)
			}, r)
			e.on('socket', (i) => {
				i.connecting
					? i.on('connect', () => {
							clearTimeout(n)
						})
					: clearTimeout(n)
			})
		}, 'setConnectionTimeout'),
		$V = ut((e, { keepAlive: t, keepAliveMsecs: r }) => {
			t === !0 &&
				e.on('socket', (n) => {
					n.setKeepAlive(t, r || 0)
				})
		}, 'setSocketKeepAlive'),
		VV = ut((e, t, r = 0) => {
			e.setTimeout(r, () => {
				e.destroy(),
					t(
						Object.assign(new Error(`Connection timed out after ${r} ms`), {
							name: 'TimeoutError',
						}),
					)
			})
		}, 'setSocketTimeout'),
		lb = require('stream'),
		rb = 1e3
	async function Cg(e, t, r = rb) {
		let n = t.headers ?? {},
			i = n.Expect || n.expect,
			o = -1,
			s = !1
		i === '100-continue' &&
			(await Promise.race([
				new Promise((c) => {
					o = Number(setTimeout(c, Math.max(rb, r)))
				}),
				new Promise((c) => {
					e.on('continue', () => {
						clearTimeout(o), c()
					}),
						e.on('error', () => {
							;(s = !0), clearTimeout(o), c()
						})
				}),
			])),
			s || db(e, t.body)
	}
	ut(Cg, 'writeRequestBody')
	function db(e, t) {
		if (t instanceof lb.Readable) {
			t.pipe(e)
			return
		}
		if (t) {
			if (Buffer.isBuffer(t) || typeof t == 'string') {
				e.end(t)
				return
			}
			let r = t
			if (
				typeof r == 'object' &&
				r.buffer &&
				typeof r.byteOffset == 'number' &&
				typeof r.byteLength == 'number'
			) {
				e.end(Buffer.from(r.buffer, r.byteOffset, r.byteLength))
				return
			}
			e.end(Buffer.from(t))
			return
		}
		e.end()
	}
	ut(db, 'writeBody')
	var KV = 0,
		ub = class Sg {
			constructor(t) {
				;(this.socketWarningTimestamp = 0),
					(this.metadata = { handlerProtocol: 'http/1.1' }),
					(this.configProvider = new Promise((r, n) => {
						typeof t == 'function'
							? t()
									.then((i) => {
										r(this.resolveDefaultConfig(i))
									})
									.catch(n)
							: r(this.resolveDefaultConfig(t))
					}))
			}
			static create(t) {
				return typeof t?.handle == 'function' ? t : new Sg(t)
			}
			static checkSocketUsage(t, r, n = console) {
				var i, o, s
				let { sockets: c, requests: l, maxSockets: u } = t
				if (typeof u != 'number' || u === 1 / 0 || Date.now() - 15e3 < r)
					return r
				if (c && l)
					for (let f in c) {
						let p = ((i = c[f]) == null ? void 0 : i.length) ?? 0,
							g = ((o = l[f]) == null ? void 0 : o.length) ?? 0
						if (p >= u && g >= 2 * u)
							return (
								(s = n?.warn) == null ||
									s.call(
										n,
										`@smithy/node-http-handler:WARN - socket usage at capacity=${p} and ${g} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`,
									),
								Date.now()
							)
					}
				return r
			}
			resolveDefaultConfig(t) {
				let {
						requestTimeout: r,
						connectionTimeout: n,
						socketTimeout: i,
						httpAgent: o,
						httpsAgent: s,
					} = t || {},
					c = !0,
					l = 50
				return {
					connectionTimeout: n,
					requestTimeout: r ?? i,
					httpAgent:
						o instanceof _g.Agent || typeof o?.destroy == 'function'
							? o
							: new _g.Agent({ keepAlive: c, maxSockets: l, ...o }),
					httpsAgent:
						s instanceof yg.Agent || typeof s?.destroy == 'function'
							? s
							: new yg.Agent({ keepAlive: c, maxSockets: l, ...s }),
					logger: console,
				}
			}
			destroy() {
				var t, r, n, i
				;(r = (t = this.config) == null ? void 0 : t.httpAgent) == null ||
					r.destroy(),
					(i = (n = this.config) == null ? void 0 : n.httpsAgent) == null ||
						i.destroy()
			}
			async handle(t, { abortSignal: r } = {}) {
				this.config || (this.config = await this.configProvider)
				let n
				return new Promise((i, o) => {
					let s,
						c = ut(async (x) => {
							await s, clearTimeout(n), i(x)
						}, 'resolve'),
						l = ut(async (x) => {
							await s, clearTimeout(n), o(x)
						}, 'reject')
					if (!this.config)
						throw new Error('Node HTTP request handler config is not resolved')
					if (r?.aborted) {
						let x = new Error('Request aborted')
						;(x.name = 'AbortError'), l(x)
						return
					}
					let u = t.protocol === 'https:',
						m = u ? this.config.httpsAgent : this.config.httpAgent
					n = setTimeout(
						() => {
							this.socketWarningTimestamp = Sg.checkSocketUsage(
								m,
								this.socketWarningTimestamp,
								this.config.logger,
							)
						},
						this.config.socketAcquisitionWarningTimeout ??
							(this.config.requestTimeout ?? 2e3) +
								(this.config.connectionTimeout ?? 1e3),
					)
					let f = (0, ab.buildQueryString)(t.query || {}),
						p
					if (t.username != null || t.password != null) {
						let x = t.username ?? '',
							W = t.password ?? ''
						p = `${x}:${W}`
					}
					let g = t.path
					f && (g += `?${f}`), t.fragment && (g += `#${t.fragment}`)
					let v = {
							headers: t.headers,
							host: t.hostname,
							method: t.method,
							path: g,
							port: t.port,
							agent: m,
							auth: p,
						},
						y = (u ? yg.request : _g.request)(v, (x) => {
							let W = new sb.HttpResponse({
								statusCode: x.statusCode || -1,
								reason: x.statusMessage,
								headers: cb(x.headers),
								body: x,
							})
							c({ response: W })
						})
					if (
						(y.on('error', (x) => {
							zV.includes(x.code)
								? l(Object.assign(x, { name: 'TimeoutError' }))
								: l(x)
						}),
						HV(y, l, this.config.connectionTimeout),
						VV(y, l, this.config.requestTimeout),
						r)
					) {
						let x = ut(() => {
							y.destroy()
							let W = new Error('Request aborted')
							;(W.name = 'AbortError'), l(W)
						}, 'onAbort')
						if (typeof r.addEventListener == 'function') {
							let W = r
							W.addEventListener('abort', x, { once: !0 }),
								y.once('close', () => W.removeEventListener('abort', x))
						} else r.onabort = x
					}
					let P = v.agent
					typeof P == 'object' &&
						'keepAlive' in P &&
						$V(y, { keepAlive: P.keepAlive, keepAliveMsecs: P.keepAliveMsecs }),
						(s = Cg(y, t, this.config.requestTimeout).catch(
							(x) => (clearTimeout(n), o(x)),
						))
				})
			}
			updateHttpClientConfig(t, r) {
				;(this.config = void 0),
					(this.configProvider = this.configProvider.then((n) => ({
						...n,
						[t]: r,
					})))
			}
			httpHandlerConfigs() {
				return this.config ?? {}
			}
		}
	ut(ub, 'NodeHttpHandler')
	var WV = ub,
		nb = require('http2'),
		XV = UV(require('http2')),
		mb = class {
			constructor(t) {
				;(this.sessions = []), (this.sessions = t ?? [])
			}
			poll() {
				if (this.sessions.length > 0) return this.sessions.shift()
			}
			offerLast(t) {
				this.sessions.push(t)
			}
			contains(t) {
				return this.sessions.includes(t)
			}
			remove(t) {
				this.sessions = this.sessions.filter((r) => r !== t)
			}
			[Symbol.iterator]() {
				return this.sessions[Symbol.iterator]()
			}
			destroy(t) {
				for (let r of this.sessions) r === t && (r.destroyed || r.destroy())
			}
		}
	ut(mb, 'NodeHttp2ConnectionPool')
	var YV = mb,
		fb = class {
			constructor(t) {
				if (
					((this.sessionCache = new Map()),
					(this.config = t),
					this.config.maxConcurrency && this.config.maxConcurrency <= 0)
				)
					throw new RangeError('maxConcurrency must be greater than zero.')
			}
			lease(t, r) {
				let n = this.getUrlString(t),
					i = this.sessionCache.get(n)
				if (i) {
					let l = i.poll()
					if (l && !this.config.disableConcurrency) return l
				}
				let o = XV.default.connect(n)
				this.config.maxConcurrency &&
					o.settings(
						{ maxConcurrentStreams: this.config.maxConcurrency },
						(l) => {
							if (l)
								throw new Error(
									'Fail to set maxConcurrentStreams to ' +
										this.config.maxConcurrency +
										'when creating new session for ' +
										t.destination.toString(),
								)
						},
					),
					o.unref()
				let s = ut(() => {
					o.destroy(), this.deleteSession(n, o)
				}, 'destroySessionCb')
				o.on('goaway', s),
					o.on('error', s),
					o.on('frameError', s),
					o.on('close', () => this.deleteSession(n, o)),
					r.requestTimeout && o.setTimeout(r.requestTimeout, s)
				let c = this.sessionCache.get(n) || new YV()
				return c.offerLast(o), this.sessionCache.set(n, c), o
			}
			deleteSession(t, r) {
				let n = this.sessionCache.get(t)
				n && n.contains(r) && (n.remove(r), this.sessionCache.set(t, n))
			}
			release(t, r) {
				var n
				let i = this.getUrlString(t)
				;(n = this.sessionCache.get(i)) == null || n.offerLast(r)
			}
			destroy() {
				for (let [t, r] of this.sessionCache) {
					for (let n of r) n.destroyed || n.destroy(), r.remove(n)
					this.sessionCache.delete(t)
				}
			}
			setMaxConcurrentStreams(t) {
				if (this.config.maxConcurrency && this.config.maxConcurrency <= 0)
					throw new RangeError(
						'maxConcurrentStreams must be greater than zero.',
					)
				this.config.maxConcurrency = t
			}
			setDisableConcurrentStreams(t) {
				this.config.disableConcurrency = t
			}
			getUrlString(t) {
				return t.destination.toString()
			}
		}
	ut(fb, 'NodeHttp2ConnectionManager')
	var JV = fb,
		pb = class gb {
			constructor(t) {
				;(this.metadata = { handlerProtocol: 'h2' }),
					(this.connectionManager = new JV({})),
					(this.configProvider = new Promise((r, n) => {
						typeof t == 'function'
							? t()
									.then((i) => {
										r(i || {})
									})
									.catch(n)
							: r(t || {})
					}))
			}
			static create(t) {
				return typeof t?.handle == 'function' ? t : new gb(t)
			}
			destroy() {
				this.connectionManager.destroy()
			}
			async handle(t, { abortSignal: r } = {}) {
				this.config ||
					((this.config = await this.configProvider),
					this.connectionManager.setDisableConcurrentStreams(
						this.config.disableConcurrentStreams || !1,
					),
					this.config.maxConcurrentStreams &&
						this.connectionManager.setMaxConcurrentStreams(
							this.config.maxConcurrentStreams,
						))
				let { requestTimeout: n, disableConcurrentStreams: i } = this.config
				return new Promise((o, s) => {
					var c
					let l = !1,
						u,
						m = ut(async (k) => {
							await u, o(k)
						}, 'resolve'),
						f = ut(async (k) => {
							await u, s(k)
						}, 'reject')
					if (r?.aborted) {
						l = !0
						let k = new Error('Request aborted')
						;(k.name = 'AbortError'), f(k)
						return
					}
					let { hostname: p, method: g, port: v, protocol: _, query: y } = t,
						P = ''
					if (t.username != null || t.password != null) {
						let k = t.username ?? '',
							T = t.password ?? ''
						P = `${k}:${T}@`
					}
					let x = `${_}//${P}${p}${v ? `:${v}` : ''}`,
						W = { destination: new URL(x) },
						X = this.connectionManager.lease(W, {
							requestTimeout:
								(c = this.config) == null ? void 0 : c.sessionTimeout,
							disableConcurrentStreams: i || !1,
						}),
						w = ut((k) => {
							i && this.destroySession(X), (l = !0), f(k)
						}, 'rejectWithDestroy'),
						b = (0, ab.buildQueryString)(y || {}),
						A = t.path
					b && (A += `?${b}`), t.fragment && (A += `#${t.fragment}`)
					let R = X.request({
						...t.headers,
						[nb.constants.HTTP2_HEADER_PATH]: A,
						[nb.constants.HTTP2_HEADER_METHOD]: g,
					})
					if (
						(X.ref(),
						R.on('response', (k) => {
							let T = new sb.HttpResponse({
								statusCode: k[':status'] || -1,
								headers: cb(k),
								body: R,
							})
							;(l = !0),
								m({ response: T }),
								i && (X.close(), this.connectionManager.deleteSession(x, X))
						}),
						n &&
							R.setTimeout(n, () => {
								R.close()
								let k = new Error(
									`Stream timed out because of no activity for ${n} ms`,
								)
								;(k.name = 'TimeoutError'), w(k)
							}),
						r)
					) {
						let k = ut(() => {
							R.close()
							let T = new Error('Request aborted')
							;(T.name = 'AbortError'), w(T)
						}, 'onAbort')
						if (typeof r.addEventListener == 'function') {
							let T = r
							T.addEventListener('abort', k, { once: !0 }),
								R.once('close', () => T.removeEventListener('abort', k))
						} else r.onabort = k
					}
					R.on('frameError', (k, T, K) => {
						w(
							new Error(
								`Frame type id ${k} in stream id ${K} has failed with code ${T}.`,
							),
						)
					}),
						R.on('error', w),
						R.on('aborted', () => {
							w(
								new Error(
									`HTTP/2 stream is abnormally aborted in mid-communication with result code ${R.rstCode}.`,
								),
							)
						}),
						R.on('close', () => {
							X.unref(),
								i && X.destroy(),
								l ||
									w(
										new Error(
											'Unexpected error: http2 request did not get a response',
										),
									)
						}),
						(u = Cg(R, t, n))
				})
			}
			updateHttpClientConfig(t, r) {
				;(this.config = void 0),
					(this.configProvider = this.configProvider.then((n) => ({
						...n,
						[t]: r,
					})))
			}
			httpHandlerConfigs() {
				return this.config ?? {}
			}
			destroySession(t) {
				t.destroyed || t.destroy()
			}
		}
	ut(pb, 'NodeHttp2Handler')
	var QV = pb,
		vb = class extends lb.Writable {
			constructor() {
				super(...arguments), (this.bufferedBytes = [])
			}
			_write(t, r, n) {
				this.bufferedBytes.push(t), n()
			}
		}
	ut(vb, 'Collector')
	var ZV = vb,
		e8 = ut(
			(e) =>
				t8(e)
					? hb(e)
					: new Promise((t, r) => {
							let n = new ZV()
							e.pipe(n),
								e.on('error', (i) => {
									n.end(), r(i)
								}),
								n.on('error', r),
								n.on('finish', function () {
									let i = new Uint8Array(Buffer.concat(this.bufferedBytes))
									t(i)
								})
						}),
			'streamCollector',
		),
		t8 = ut(
			(e) => typeof ReadableStream == 'function' && e instanceof ReadableStream,
			'isReadableStreamInstance',
		)
	async function hb(e) {
		let t = [],
			r = e.getReader(),
			n = !1,
			i = 0
		for (; !n; ) {
			let { done: c, value: l } = await r.read()
			l && (t.push(l), (i += l.length)), (n = c)
		}
		let o = new Uint8Array(i),
			s = 0
		for (let c of t) o.set(c, s), (s += c.length)
		return o
	}
	ut(hb, 'collectReadableStream')
})
var Ob = E((DAe, Ab) => {
	var Sd = Object.defineProperty,
		r8 = Object.getOwnPropertyDescriptor,
		n8 = Object.getOwnPropertyNames,
		i8 = Object.prototype.hasOwnProperty,
		zn = (e, t) => Sd(e, 'name', { value: t, configurable: !0 }),
		o8 = (e, t) => {
			for (var r in t) Sd(e, r, { get: t[r], enumerable: !0 })
		},
		s8 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of n8(t))
					!i8.call(e, i) &&
						i !== r &&
						Sd(e, i, {
							get: () => t[i],
							enumerable: !(n = r8(t, i)) || n.enumerable,
						})
			return e
		},
		a8 = (e) => s8(Sd({}, '__esModule', { value: !0 }), e),
		Sb = {}
	o8(Sb, {
		FetchHttpHandler: () => l8,
		keepAliveSupport: () => yd,
		streamCollector: () => u8,
	})
	Ab.exports = a8(Sb)
	var yb = Xe(),
		c8 = hg()
	function Cb(e = 0) {
		return new Promise((t, r) => {
			e &&
				setTimeout(() => {
					let n = new Error(`Request did not complete within ${e} ms`)
					;(n.name = 'TimeoutError'), r(n)
				}, e)
		})
	}
	zn(Cb, 'requestTimeout')
	var yd = { supported: void 0 },
		Eb = class bb {
			static create(t) {
				return typeof t?.handle == 'function' ? t : new bb(t)
			}
			constructor(t) {
				typeof t == 'function'
					? (this.configProvider = t().then((r) => r || {}))
					: ((this.config = t ?? {}),
						(this.configProvider = Promise.resolve(this.config))),
					yd.supported === void 0 &&
						(yd.supported =
							typeof Request < 'u' &&
							'keepalive' in new Request('https://[::1]'))
			}
			destroy() {}
			async handle(t, { abortSignal: r } = {}) {
				this.config || (this.config = await this.configProvider)
				let n = this.config.requestTimeout,
					i = this.config.keepAlive === !0,
					o = this.config.credentials
				if (r?.aborted) {
					let P = new Error('Request aborted')
					return (P.name = 'AbortError'), Promise.reject(P)
				}
				let s = t.path,
					c = (0, c8.buildQueryString)(t.query || {})
				c && (s += `?${c}`), t.fragment && (s += `#${t.fragment}`)
				let l = ''
				if (t.username != null || t.password != null) {
					let P = t.username ?? '',
						x = t.password ?? ''
					l = `${P}:${x}@`
				}
				let { port: u, method: m } = t,
					f = `${t.protocol}//${l}${t.hostname}${u ? `:${u}` : ''}${s}`,
					p = m === 'GET' || m === 'HEAD' ? void 0 : t.body,
					g = {
						body: p,
						headers: new Headers(t.headers),
						method: m,
						credentials: o,
					}
				p && (g.duplex = 'half'),
					typeof AbortController < 'u' && (g.signal = r),
					yd.supported && (g.keepalive = i)
				let v = zn(() => {}, 'removeSignalEventListener'),
					_ = new Request(f, g),
					y = [
						fetch(_).then((P) => {
							let x = P.headers,
								W = {}
							for (let w of x.entries()) W[w[0]] = w[1]
							return P.body != null
								? {
										response: new yb.HttpResponse({
											headers: W,
											reason: P.statusText,
											statusCode: P.status,
											body: P.body,
										}),
									}
								: P.blob().then((w) => ({
										response: new yb.HttpResponse({
											headers: W,
											reason: P.statusText,
											statusCode: P.status,
											body: w,
										}),
									}))
						}),
						Cb(n),
					]
				return (
					r &&
						y.push(
							new Promise((P, x) => {
								let W = zn(() => {
									let X = new Error('Request aborted')
									;(X.name = 'AbortError'), x(X)
								}, 'onAbort')
								if (typeof r.addEventListener == 'function') {
									let X = r
									X.addEventListener('abort', W, { once: !0 }),
										(v = zn(
											() => X.removeEventListener('abort', W),
											'removeSignalEventListener',
										))
								} else r.onabort = W
							}),
						),
					Promise.race(y).finally(v)
				)
			}
			updateHttpClientConfig(t, r) {
				;(this.config = void 0),
					(this.configProvider = this.configProvider.then(
						(n) => ((n[t] = r), n),
					))
			}
			httpHandlerConfigs() {
				return this.config ?? {}
			}
		}
	zn(Eb, 'FetchHttpHandler')
	var l8 = Eb,
		d8 = gi(),
		u8 = zn(
			(e) => (typeof Blob == 'function' && e instanceof Blob ? wb(e) : xb(e)),
			'streamCollector',
		)
	async function wb(e) {
		let t = await Pb(e),
			r = (0, d8.fromBase64)(t)
		return new Uint8Array(r)
	}
	zn(wb, 'collectBlob')
	async function xb(e) {
		let t = [],
			r = e.getReader(),
			n = !1,
			i = 0
		for (; !n; ) {
			let { done: c, value: l } = await r.read()
			l && (t.push(l), (i += l.length)), (n = c)
		}
		let o = new Uint8Array(i),
			s = 0
		for (let c of t) o.set(c, s), (s += c.length)
		return o
	}
	zn(xb, 'collectStream')
	function Pb(e) {
		return new Promise((t, r) => {
			let n = new FileReader()
			;(n.onloadend = () => {
				if (n.readyState !== 2) return r(new Error('Reader aborted too early'))
				let i = n.result ?? '',
					o = i.indexOf(','),
					s = o > -1 ? o + 1 : i.length
				t(i.substring(s))
			}),
				(n.onabort = () => r(new Error('Read aborted'))),
				(n.onerror = () => r(n.error)),
				n.readAsDataURL(e)
		})
	}
	zn(Pb, 'readToBase64')
})
var Ed = E((LAe, Nb) => {
	var Cd = Object.defineProperty,
		m8 = Object.getOwnPropertyDescriptor,
		f8 = Object.getOwnPropertyNames,
		p8 = Object.prototype.hasOwnProperty,
		Rb = (e, t) => Cd(e, 'name', { value: t, configurable: !0 }),
		g8 = (e, t) => {
			for (var r in t) Cd(e, r, { get: t[r], enumerable: !0 })
		},
		v8 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of f8(t))
					!p8.call(e, i) &&
						i !== r &&
						Cd(e, i, {
							get: () => t[i],
							enumerable: !(n = m8(t, i)) || n.enumerable,
						})
			return e
		},
		h8 = (e) => v8(Cd({}, '__esModule', { value: !0 }), e),
		kb = {}
	g8(kb, { fromHex: () => Tb, toHex: () => Bb })
	Nb.exports = h8(kb)
	var Ib = {},
		Eg = {}
	for (let e = 0; e < 256; e++) {
		let t = e.toString(16).toLowerCase()
		t.length === 1 && (t = `0${t}`), (Ib[e] = t), (Eg[t] = e)
	}
	function Tb(e) {
		if (e.length % 2 !== 0)
			throw new Error('Hex encoded strings must have an even number length')
		let t = new Uint8Array(e.length / 2)
		for (let r = 0; r < e.length; r += 2) {
			let n = e.slice(r, r + 2).toLowerCase()
			if (n in Eg) t[r / 2] = Eg[n]
			else
				throw new Error(
					`Cannot decode unrecognized sequence ${n} as hexadecimal`,
				)
		}
		return t
	}
	Rb(Tb, 'fromHex')
	function Bb(e) {
		let t = ''
		for (let r = 0; r < e.byteLength; r++) t += Ib[e[r]]
		return t
	}
	Rb(Bb, 'toHex')
})
var Ac = E((bd) => {
	'use strict'
	Object.defineProperty(bd, '__esModule', { value: !0 })
	bd.isReadableStream = void 0
	var _8 = (e) => {
		var t
		return (
			typeof ReadableStream == 'function' &&
			(((t = e?.constructor) === null || t === void 0 ? void 0 : t.name) ===
				ReadableStream.name ||
				e instanceof ReadableStream)
		)
	}
	bd.isReadableStream = _8
})
var Mb = E((wd) => {
	'use strict'
	Object.defineProperty(wd, '__esModule', { value: !0 })
	wd.sdkStreamMixin = void 0
	var y8 = Ob(),
		S8 = gi(),
		C8 = Ed(),
		E8 = rr(),
		Db = Ac(),
		Lb = 'The stream has already been transformed.',
		b8 = (e) => {
			var t, r
			if (!Fb(e) && !(0, Db.isReadableStream)(e)) {
				let s =
					((r =
						(t = e?.__proto__) === null || t === void 0
							? void 0
							: t.constructor) === null || r === void 0
						? void 0
						: r.name) || e
				throw new Error(
					`Unexpected stream implementation, expect Blob or ReadableStream, got ${s}`,
				)
			}
			let n = !1,
				i = async () => {
					if (n) throw new Error(Lb)
					return (n = !0), await (0, y8.streamCollector)(e)
				},
				o = (s) => {
					if (typeof s.stream != 'function')
						throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`)
					return s.stream()
				}
			return Object.assign(e, {
				transformToByteArray: i,
				transformToString: async (s) => {
					let c = await i()
					if (s === 'base64') return (0, S8.toBase64)(c)
					if (s === 'hex') return (0, C8.toHex)(c)
					if (s === void 0 || s === 'utf8' || s === 'utf-8')
						return (0, E8.toUtf8)(c)
					if (typeof TextDecoder == 'function')
						return new TextDecoder(s).decode(c)
					throw new Error(
						'TextDecoder is not available, please make sure polyfill is provided.',
					)
				},
				transformToWebStream: () => {
					if (n) throw new Error(Lb)
					if (((n = !0), Fb(e))) return o(e)
					if ((0, Db.isReadableStream)(e)) return e
					throw new Error(`Cannot transform payload to web stream, got ${e}`)
				},
			})
		}
	wd.sdkStreamMixin = b8
	var Fb = (e) => typeof Blob == 'function' && e instanceof Blob
})
var jb = E((xd) => {
	'use strict'
	Object.defineProperty(xd, '__esModule', { value: !0 })
	xd.sdkStreamMixin = void 0
	var w8 = co(),
		x8 = Cs(),
		bg = require('stream'),
		P8 = require('util'),
		A8 = Mb(),
		qb = 'The stream has already been transformed.',
		O8 = (e) => {
			var t, r
			if (!(e instanceof bg.Readable))
				try {
					return (0, A8.sdkStreamMixin)(e)
				} catch {
					let s =
						((r =
							(t = e?.__proto__) === null || t === void 0
								? void 0
								: t.constructor) === null || r === void 0
							? void 0
							: r.name) || e
					throw new Error(
						`Unexpected stream implementation, expect Stream.Readable instance, got ${s}`,
					)
				}
			let n = !1,
				i = async () => {
					if (n) throw new Error(qb)
					return (n = !0), await (0, w8.streamCollector)(e)
				}
			return Object.assign(e, {
				transformToByteArray: i,
				transformToString: async (o) => {
					let s = await i()
					return o === void 0 || Buffer.isEncoding(o)
						? (0, x8.fromArrayBuffer)(
								s.buffer,
								s.byteOffset,
								s.byteLength,
							).toString(o)
						: new P8.TextDecoder(o).decode(s)
				},
				transformToWebStream: () => {
					if (n) throw new Error(qb)
					if (e.readableFlowing !== null)
						throw new Error('The stream has been consumed by other callbacks.')
					if (typeof bg.Readable.toWeb != 'function')
						throw new Error(
							'Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.',
						)
					return (n = !0), bg.Readable.toWeb(e)
				},
			})
		}
	xd.sdkStreamMixin = O8
})
var Ub = E((Pd) => {
	'use strict'
	Object.defineProperty(Pd, '__esModule', { value: !0 })
	Pd.splitStream = void 0
	async function R8(e) {
		return typeof e.stream == 'function' && (e = e.stream()), e.tee()
	}
	Pd.splitStream = R8
})
var zb = E((Ad) => {
	'use strict'
	Object.defineProperty(Ad, '__esModule', { value: !0 })
	Ad.splitStream = void 0
	var Gb = require('stream'),
		k8 = Ub(),
		I8 = Ac()
	async function T8(e) {
		if ((0, I8.isReadableStream)(e)) return (0, k8.splitStream)(e)
		let t = new Gb.PassThrough(),
			r = new Gb.PassThrough()
		return e.pipe(t), e.pipe(r), [t, r]
	}
	Ad.splitStream = T8
})
var Hb = E((Od) => {
	'use strict'
	Object.defineProperty(Od, '__esModule', { value: !0 })
	Od.headStream = void 0
	async function B8(e, t) {
		var r
		let n = 0,
			i = [],
			o = e.getReader(),
			s = !1
		for (; !s; ) {
			let { done: u, value: m } = await o.read()
			if (
				(m &&
					(i.push(m),
					(n += (r = m?.byteLength) !== null && r !== void 0 ? r : 0)),
				n >= t)
			)
				break
			s = u
		}
		o.releaseLock()
		let c = new Uint8Array(Math.min(t, n)),
			l = 0
		for (let u of i) {
			if (u.byteLength > c.byteLength - l) {
				c.set(u.subarray(0, c.byteLength - l), l)
				break
			} else c.set(u, l)
			l += u.length
		}
		return c
	}
	Od.headStream = B8
})
var $b = E((Rd) => {
	'use strict'
	Object.defineProperty(Rd, '__esModule', { value: !0 })
	Rd.headStream = void 0
	var N8 = require('stream'),
		D8 = Hb(),
		L8 = Ac(),
		F8 = (e, t) =>
			(0, L8.isReadableStream)(e)
				? (0, D8.headStream)(e, t)
				: new Promise((r, n) => {
						let i = new wg()
						;(i.limit = t),
							e.pipe(i),
							e.on('error', (o) => {
								i.end(), n(o)
							}),
							i.on('error', n),
							i.on('finish', function () {
								let o = new Uint8Array(Buffer.concat(this.buffers))
								r(o)
							})
					})
	Rd.headStream = F8
	var wg = class extends N8.Writable {
		constructor() {
			super(...arguments),
				(this.buffers = []),
				(this.limit = 1 / 0),
				(this.bytesBuffered = 0)
		}
		_write(t, r, n) {
			var i
			if (
				(this.buffers.push(t),
				(this.bytesBuffered +=
					(i = t.byteLength) !== null && i !== void 0 ? i : 0),
				this.bytesBuffered >= this.limit)
			) {
				let o = this.bytesBuffered - this.limit,
					s = this.buffers[this.buffers.length - 1]
				;(this.buffers[this.buffers.length - 1] = s.subarray(
					0,
					s.byteLength - o,
				)),
					this.emit('finish')
			}
			n()
		}
	}
})
var Rc = E((HAe, uo) => {
	var kd = Object.defineProperty,
		M8 = Object.getOwnPropertyDescriptor,
		q8 = Object.getOwnPropertyNames,
		j8 = Object.prototype.hasOwnProperty,
		Ag = (e, t) => kd(e, 'name', { value: t, configurable: !0 }),
		U8 = (e, t) => {
			for (var r in t) kd(e, r, { get: t[r], enumerable: !0 })
		},
		xg = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of q8(t))
					!j8.call(e, i) &&
						i !== r &&
						kd(e, i, {
							get: () => t[i],
							enumerable: !(n = M8(t, i)) || n.enumerable,
						})
			return e
		},
		Oc = (e, t, r) => (xg(e, t, 'default'), r && xg(r, t, 'default')),
		G8 = (e) => xg(kd({}, '__esModule', { value: !0 }), e),
		lo = {}
	U8(lo, { Uint8ArrayBlobAdapter: () => Pg })
	uo.exports = G8(lo)
	var Vb = gi(),
		Kb = rr()
	function Wb(e, t = 'utf-8') {
		return t === 'base64' ? (0, Vb.toBase64)(e) : (0, Kb.toUtf8)(e)
	}
	Ag(Wb, 'transformToString')
	function Xb(e, t) {
		return t === 'base64'
			? Pg.mutate((0, Vb.fromBase64)(e))
			: Pg.mutate((0, Kb.fromUtf8)(e))
	}
	Ag(Xb, 'transformFromString')
	var Yb = class Jb extends Uint8Array {
		static fromString(t, r = 'utf-8') {
			switch (typeof t) {
				case 'string':
					return Xb(t, r)
				default:
					throw new Error(
						`Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`,
					)
			}
		}
		static mutate(t) {
			return Object.setPrototypeOf(t, Jb.prototype), t
		}
		transformToString(t = 'utf-8') {
			return Wb(this, t)
		}
	}
	Ag(Yb, 'Uint8ArrayBlobAdapter')
	var Pg = Yb
	Oc(lo, XE(), uo.exports)
	Oc(lo, jb(), uo.exports)
	Oc(lo, zb(), uo.exports)
	Oc(lo, $b(), uo.exports)
	Oc(lo, Ac(), uo.exports)
})
var ze = E((XAe, Cw) => {
	var Dd = Object.defineProperty,
		z8 = Object.getOwnPropertyDescriptor,
		H8 = Object.getOwnPropertyNames,
		$8 = Object.prototype.hasOwnProperty,
		Y = (e, t) => Dd(e, 'name', { value: t, configurable: !0 }),
		V8 = (e, t) => {
			for (var r in t) Dd(e, r, { get: t[r], enumerable: !0 })
		},
		K8 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of H8(t))
					!$8.call(e, i) &&
						i !== r &&
						Dd(e, i, {
							get: () => t[i],
							enumerable: !(n = z8(t, i)) || n.enumerable,
						})
			return e
		},
		W8 = (e) => K8(Dd({}, '__esModule', { value: !0 }), e),
		Zb = {}
	V8(Zb, {
		Client: () => Y8,
		Command: () => iw,
		LazyJsonString: () => VK,
		NoOpLogger: () => X8,
		SENSITIVE_STRING: () => Z8,
		ServiceException: () => NK,
		StringWrapper: () => Nc,
		_json: () => Ng,
		collectBody: () => J8,
		convertMap: () => KK,
		createAggregatedClient: () => eK,
		dateToUtcString: () => uw,
		decorateServiceException: () => pw,
		emitWarningIfUnsupportedVersion: () => MK,
		expectBoolean: () => rK,
		expectByte: () => Bg,
		expectFloat32: () => Td,
		expectInt: () => iK,
		expectInt32: () => Ig,
		expectLong: () => Tc,
		expectNonNull: () => sK,
		expectNumber: () => Ic,
		expectObject: () => sw,
		expectShort: () => Tg,
		expectString: () => aK,
		expectUnion: () => cK,
		extendedEncodeURIComponent: () => Nd,
		getArrayIfSingleItem: () => $K,
		getDefaultClientConfiguration: () => zK,
		getDefaultExtensionConfiguration: () => vw,
		getValueFromTextNode: () => hw,
		handleFloat: () => uK,
		limitedParseDouble: () => Fg,
		limitedParseFloat: () => mK,
		limitedParseFloat32: () => fK,
		loadConfigsForDefaultMode: () => FK,
		logger: () => Bc,
		map: () => qg,
		parseBoolean: () => tK,
		parseEpochTimestamp: () => xK,
		parseRfc3339DateTime: () => _K,
		parseRfc3339DateTimeWithOffset: () => SK,
		parseRfc7231DateTime: () => wK,
		resolveDefaultRuntimeConfig: () => HK,
		resolvedPath: () => QK,
		serializeDateTime: () => eW,
		serializeFloat: () => ZK,
		splitEvery: () => Sw,
		strictParseByte: () => dw,
		strictParseDouble: () => Lg,
		strictParseFloat: () => lK,
		strictParseFloat32: () => aw,
		strictParseInt: () => pK,
		strictParseInt32: () => gK,
		strictParseLong: () => lw,
		strictParseShort: () => Es,
		take: () => WK,
		throwDefaultError: () => gw,
		withBaseException: () => DK,
	})
	Cw.exports = W8(Zb)
	var ew = class {
		trace() {}
		debug() {}
		info() {}
		warn() {}
		error() {}
	}
	Y(ew, 'NoOpLogger')
	var X8 = ew,
		tw = DE(),
		rw = class {
			constructor(t) {
				;(this.middlewareStack = (0, tw.constructStack)()), (this.config = t)
			}
			send(t, r, n) {
				let i = typeof r != 'function' ? r : void 0,
					o = typeof r == 'function' ? r : n,
					s = t.resolveMiddleware(this.middlewareStack, this.config, i)
				if (o)
					s(t)
						.then(
							(c) => o(null, c.output),
							(c) => o(c),
						)
						.catch(() => {})
				else return s(t).then((c) => c.output)
			}
			destroy() {
				this.config.requestHandler.destroy &&
					this.config.requestHandler.destroy()
			}
		}
	Y(rw, 'Client')
	var Y8 = rw,
		Og = Rc(),
		J8 = Y(async (e = new Uint8Array(), t) => {
			if (e instanceof Uint8Array) return Og.Uint8ArrayBlobAdapter.mutate(e)
			if (!e) return Og.Uint8ArrayBlobAdapter.mutate(new Uint8Array())
			let r = t.streamCollector(e)
			return Og.Uint8ArrayBlobAdapter.mutate(await r)
		}, 'collectBody'),
		kg = en(),
		nw = class {
			constructor() {
				this.middlewareStack = (0, tw.constructStack)()
			}
			static classBuilder() {
				return new Q8()
			}
			resolveMiddlewareWithContext(
				t,
				r,
				n,
				{
					middlewareFn: i,
					clientName: o,
					commandName: s,
					inputFilterSensitiveLog: c,
					outputFilterSensitiveLog: l,
					smithyContext: u,
					additionalContext: m,
					CommandCtor: f,
				},
			) {
				for (let y of i.bind(this)(f, t, r, n)) this.middlewareStack.use(y)
				let p = t.concat(this.middlewareStack),
					{ logger: g } = r,
					v = {
						logger: g,
						clientName: o,
						commandName: s,
						inputFilterSensitiveLog: c,
						outputFilterSensitiveLog: l,
						[kg.SMITHY_CONTEXT_KEY]: { commandInstance: this, ...u },
						...m,
					},
					{ requestHandler: _ } = r
				return p.resolve((y) => _.handle(y.request, n || {}), v)
			}
		}
	Y(nw, 'Command')
	var iw = nw,
		ow = class {
			constructor() {
				;(this._init = () => {}),
					(this._ep = {}),
					(this._middlewareFn = () => []),
					(this._commandName = ''),
					(this._clientName = ''),
					(this._additionalContext = {}),
					(this._smithyContext = {}),
					(this._inputFilterSensitiveLog = (t) => t),
					(this._outputFilterSensitiveLog = (t) => t),
					(this._serializer = null),
					(this._deserializer = null)
			}
			init(t) {
				this._init = t
			}
			ep(t) {
				return (this._ep = t), this
			}
			m(t) {
				return (this._middlewareFn = t), this
			}
			s(t, r, n = {}) {
				return (this._smithyContext = { service: t, operation: r, ...n }), this
			}
			c(t = {}) {
				return (this._additionalContext = t), this
			}
			n(t, r) {
				return (this._clientName = t), (this._commandName = r), this
			}
			f(t = (n) => n, r = (n) => n) {
				return (
					(this._inputFilterSensitiveLog = t),
					(this._outputFilterSensitiveLog = r),
					this
				)
			}
			ser(t) {
				return (this._serializer = t), this
			}
			de(t) {
				return (this._deserializer = t), this
			}
			build() {
				var t
				let r = this,
					n
				return (n =
					((t = class extends iw {
						constructor(...[i]) {
							super(),
								(this.serialize = r._serializer),
								(this.deserialize = r._deserializer),
								(this.input = i ?? {}),
								r._init(this)
						}
						static getEndpointParameterInstructions() {
							return r._ep
						}
						resolveMiddleware(i, o, s) {
							return this.resolveMiddlewareWithContext(i, o, s, {
								CommandCtor: n,
								middlewareFn: r._middlewareFn,
								clientName: r._clientName,
								commandName: r._commandName,
								inputFilterSensitiveLog: r._inputFilterSensitiveLog,
								outputFilterSensitiveLog: r._outputFilterSensitiveLog,
								smithyContext: r._smithyContext,
								additionalContext: r._additionalContext,
							})
						}
					}),
					Y(t, 'CommandRef'),
					t))
			}
		}
	Y(ow, 'ClassBuilder')
	var Q8 = ow,
		Z8 = '***SensitiveInformation***',
		eK = Y((e, t) => {
			for (let r of Object.keys(e)) {
				let n = e[r],
					i = Y(async function (s, c, l) {
						let u = new n(s)
						if (typeof c == 'function') this.send(u, c)
						else if (typeof l == 'function') {
							if (typeof c != 'object')
								throw new Error(`Expected http options but got ${typeof c}`)
							this.send(u, c || {}, l)
						} else return this.send(u, c)
					}, 'methodImpl'),
					o = (r[0].toLowerCase() + r.slice(1)).replace(/Command$/, '')
				t.prototype[o] = i
			}
		}, 'createAggregatedClient'),
		tK = Y((e) => {
			switch (e) {
				case 'true':
					return !0
				case 'false':
					return !1
				default:
					throw new Error(`Unable to parse boolean value "${e}"`)
			}
		}, 'parseBoolean'),
		rK = Y((e) => {
			if (e != null) {
				if (typeof e == 'number') {
					if (
						((e === 0 || e === 1) &&
							Bc.warn(Bd(`Expected boolean, got ${typeof e}: ${e}`)),
						e === 0)
					)
						return !1
					if (e === 1) return !0
				}
				if (typeof e == 'string') {
					let t = e.toLowerCase()
					if (
						((t === 'false' || t === 'true') &&
							Bc.warn(Bd(`Expected boolean, got ${typeof e}: ${e}`)),
						t === 'false')
					)
						return !1
					if (t === 'true') return !0
				}
				if (typeof e == 'boolean') return e
				throw new TypeError(`Expected boolean, got ${typeof e}: ${e}`)
			}
		}, 'expectBoolean'),
		Ic = Y((e) => {
			if (e != null) {
				if (typeof e == 'string') {
					let t = parseFloat(e)
					if (!Number.isNaN(t))
						return (
							String(t) !== String(e) &&
								Bc.warn(Bd(`Expected number but observed string: ${e}`)),
							t
						)
				}
				if (typeof e == 'number') return e
				throw new TypeError(`Expected number, got ${typeof e}: ${e}`)
			}
		}, 'expectNumber'),
		nK = Math.ceil(2 ** 127 * (2 - 2 ** -23)),
		Td = Y((e) => {
			let t = Ic(e)
			if (
				t !== void 0 &&
				!Number.isNaN(t) &&
				t !== 1 / 0 &&
				t !== -1 / 0 &&
				Math.abs(t) > nK
			)
				throw new TypeError(`Expected 32-bit float, got ${e}`)
			return t
		}, 'expectFloat32'),
		Tc = Y((e) => {
			if (e != null) {
				if (Number.isInteger(e) && !Number.isNaN(e)) return e
				throw new TypeError(`Expected integer, got ${typeof e}: ${e}`)
			}
		}, 'expectLong'),
		iK = Tc,
		Ig = Y((e) => Dg(e, 32), 'expectInt32'),
		Tg = Y((e) => Dg(e, 16), 'expectShort'),
		Bg = Y((e) => Dg(e, 8), 'expectByte'),
		Dg = Y((e, t) => {
			let r = Tc(e)
			if (r !== void 0 && oK(r, t) !== r)
				throw new TypeError(`Expected ${t}-bit integer, got ${e}`)
			return r
		}, 'expectSizedInt'),
		oK = Y((e, t) => {
			switch (t) {
				case 32:
					return Int32Array.of(e)[0]
				case 16:
					return Int16Array.of(e)[0]
				case 8:
					return Int8Array.of(e)[0]
			}
		}, 'castInt'),
		sK = Y((e, t) => {
			if (e == null)
				throw t
					? new TypeError(`Expected a non-null value for ${t}`)
					: new TypeError('Expected a non-null value')
			return e
		}, 'expectNonNull'),
		sw = Y((e) => {
			if (e == null) return
			if (typeof e == 'object' && !Array.isArray(e)) return e
			let t = Array.isArray(e) ? 'array' : typeof e
			throw new TypeError(`Expected object, got ${t}: ${e}`)
		}, 'expectObject'),
		aK = Y((e) => {
			if (e != null) {
				if (typeof e == 'string') return e
				if (['boolean', 'number', 'bigint'].includes(typeof e))
					return (
						Bc.warn(Bd(`Expected string, got ${typeof e}: ${e}`)), String(e)
					)
				throw new TypeError(`Expected string, got ${typeof e}: ${e}`)
			}
		}, 'expectString'),
		cK = Y((e) => {
			if (e == null) return
			let t = sw(e),
				r = Object.entries(t)
					.filter(([, n]) => n != null)
					.map(([n]) => n)
			if (r.length === 0)
				throw new TypeError(
					'Unions must have exactly one non-null member. None were found.',
				)
			if (r.length > 1)
				throw new TypeError(
					`Unions must have exactly one non-null member. Keys ${r} were not null.`,
				)
			return t
		}, 'expectUnion'),
		Lg = Y((e) => Ic(typeof e == 'string' ? ws(e) : e), 'strictParseDouble'),
		lK = Lg,
		aw = Y((e) => Td(typeof e == 'string' ? ws(e) : e), 'strictParseFloat32'),
		dK = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
		ws = Y((e) => {
			let t = e.match(dK)
			if (t === null || t[0].length !== e.length)
				throw new TypeError('Expected real number, got implicit NaN')
			return parseFloat(e)
		}, 'parseNumber'),
		Fg = Y((e) => (typeof e == 'string' ? cw(e) : Ic(e)), 'limitedParseDouble'),
		uK = Fg,
		mK = Fg,
		fK = Y(
			(e) => (typeof e == 'string' ? cw(e) : Td(e)),
			'limitedParseFloat32',
		),
		cw = Y((e) => {
			switch (e) {
				case 'NaN':
					return NaN
				case 'Infinity':
					return 1 / 0
				case '-Infinity':
					return -1 / 0
				default:
					throw new Error(`Unable to parse float value: ${e}`)
			}
		}, 'parseFloatString'),
		lw = Y((e) => Tc(typeof e == 'string' ? ws(e) : e), 'strictParseLong'),
		pK = lw,
		gK = Y((e) => Ig(typeof e == 'string' ? ws(e) : e), 'strictParseInt32'),
		Es = Y((e) => Tg(typeof e == 'string' ? ws(e) : e), 'strictParseShort'),
		dw = Y((e) => Bg(typeof e == 'string' ? ws(e) : e), 'strictParseByte'),
		Bd = Y(
			(e) =>
				String(new TypeError(e).stack || e)
					.split(`
`)
					.slice(0, 5)
					.filter((t) => !t.includes('stackTraceWarning'))
					.join(`
`),
			'stackTraceWarning',
		),
		Bc = { warn: console.warn },
		vK = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		Mg = [
			'Jan',
			'Feb',
			'Mar',
			'Apr',
			'May',
			'Jun',
			'Jul',
			'Aug',
			'Sep',
			'Oct',
			'Nov',
			'Dec',
		]
	function uw(e) {
		let t = e.getUTCFullYear(),
			r = e.getUTCMonth(),
			n = e.getUTCDay(),
			i = e.getUTCDate(),
			o = e.getUTCHours(),
			s = e.getUTCMinutes(),
			c = e.getUTCSeconds(),
			l = i < 10 ? `0${i}` : `${i}`,
			u = o < 10 ? `0${o}` : `${o}`,
			m = s < 10 ? `0${s}` : `${s}`,
			f = c < 10 ? `0${c}` : `${c}`
		return `${vK[n]}, ${l} ${Mg[r]} ${t} ${u}:${m}:${f} GMT`
	}
	Y(uw, 'dateToUtcString')
	var hK = new RegExp(
			/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/,
		),
		_K = Y((e) => {
			if (e == null) return
			if (typeof e != 'string')
				throw new TypeError('RFC-3339 date-times must be expressed as strings')
			let t = hK.exec(e)
			if (!t) throw new TypeError('Invalid RFC-3339 date-time value')
			let [r, n, i, o, s, c, l, u] = t,
				m = Es(bs(n)),
				f = En(i, 'month', 1, 12),
				p = En(o, 'day', 1, 31)
			return kc(m, f, p, {
				hours: s,
				minutes: c,
				seconds: l,
				fractionalMilliseconds: u,
			})
		}, 'parseRfc3339DateTime'),
		yK = new RegExp(
			/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/,
		),
		SK = Y((e) => {
			if (e == null) return
			if (typeof e != 'string')
				throw new TypeError('RFC-3339 date-times must be expressed as strings')
			let t = yK.exec(e)
			if (!t) throw new TypeError('Invalid RFC-3339 date-time value')
			let [r, n, i, o, s, c, l, u, m] = t,
				f = Es(bs(n)),
				p = En(i, 'month', 1, 12),
				g = En(o, 'day', 1, 31),
				v = kc(f, p, g, {
					hours: s,
					minutes: c,
					seconds: l,
					fractionalMilliseconds: u,
				})
			return m.toUpperCase() != 'Z' && v.setTime(v.getTime() - BK(m)), v
		}, 'parseRfc3339DateTimeWithOffset'),
		CK = new RegExp(
			/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
		),
		EK = new RegExp(
			/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
		),
		bK = new RegExp(
			/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/,
		),
		wK = Y((e) => {
			if (e == null) return
			if (typeof e != 'string')
				throw new TypeError('RFC-7231 date-times must be expressed as strings')
			let t = CK.exec(e)
			if (t) {
				let [r, n, i, o, s, c, l, u] = t
				return kc(Es(bs(o)), Rg(i), En(n, 'day', 1, 31), {
					hours: s,
					minutes: c,
					seconds: l,
					fractionalMilliseconds: u,
				})
			}
			if (((t = EK.exec(e)), t)) {
				let [r, n, i, o, s, c, l, u] = t
				return OK(
					kc(PK(o), Rg(i), En(n, 'day', 1, 31), {
						hours: s,
						minutes: c,
						seconds: l,
						fractionalMilliseconds: u,
					}),
				)
			}
			if (((t = bK.exec(e)), t)) {
				let [r, n, i, o, s, c, l, u] = t
				return kc(Es(bs(u)), Rg(n), En(i.trimLeft(), 'day', 1, 31), {
					hours: o,
					minutes: s,
					seconds: c,
					fractionalMilliseconds: l,
				})
			}
			throw new TypeError('Invalid RFC-7231 date-time value')
		}, 'parseRfc7231DateTime'),
		xK = Y((e) => {
			if (e == null) return
			let t
			if (typeof e == 'number') t = e
			else if (typeof e == 'string') t = Lg(e)
			else if (typeof e == 'object' && e.tag === 1) t = e.value
			else
				throw new TypeError(
					'Epoch timestamps must be expressed as floating point numbers or their string representation',
				)
			if (Number.isNaN(t) || t === 1 / 0 || t === -1 / 0)
				throw new TypeError(
					'Epoch timestamps must be valid, non-Infinite, non-NaN numerics',
				)
			return new Date(Math.round(t * 1e3))
		}, 'parseEpochTimestamp'),
		kc = Y((e, t, r, n) => {
			let i = t - 1
			return (
				kK(e, i, r),
				new Date(
					Date.UTC(
						e,
						i,
						r,
						En(n.hours, 'hour', 0, 23),
						En(n.minutes, 'minute', 0, 59),
						En(n.seconds, 'seconds', 0, 60),
						TK(n.fractionalMilliseconds),
					),
				)
			)
		}, 'buildDate'),
		PK = Y((e) => {
			let t = new Date().getUTCFullYear(),
				r = Math.floor(t / 100) * 100 + Es(bs(e))
			return r < t ? r + 100 : r
		}, 'parseTwoDigitYear'),
		AK = 50 * 365 * 24 * 60 * 60 * 1e3,
		OK = Y(
			(e) =>
				e.getTime() - new Date().getTime() > AK
					? new Date(
							Date.UTC(
								e.getUTCFullYear() - 100,
								e.getUTCMonth(),
								e.getUTCDate(),
								e.getUTCHours(),
								e.getUTCMinutes(),
								e.getUTCSeconds(),
								e.getUTCMilliseconds(),
							),
						)
					: e,
			'adjustRfc850Year',
		),
		Rg = Y((e) => {
			let t = Mg.indexOf(e)
			if (t < 0) throw new TypeError(`Invalid month: ${e}`)
			return t + 1
		}, 'parseMonthByShortName'),
		RK = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
		kK = Y((e, t, r) => {
			let n = RK[t]
			if ((t === 1 && IK(e) && (n = 29), r > n))
				throw new TypeError(`Invalid day for ${Mg[t]} in ${e}: ${r}`)
		}, 'validateDayOfMonth'),
		IK = Y(
			(e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0),
			'isLeapYear',
		),
		En = Y((e, t, r, n) => {
			let i = dw(bs(e))
			if (i < r || i > n)
				throw new TypeError(`${t} must be between ${r} and ${n}, inclusive`)
			return i
		}, 'parseDateValue'),
		TK = Y((e) => (e == null ? 0 : aw('0.' + e) * 1e3), 'parseMilliseconds'),
		BK = Y((e) => {
			let t = e[0],
				r = 1
			if (t == '+') r = 1
			else if (t == '-') r = -1
			else throw new TypeError(`Offset direction, ${t}, must be "+" or "-"`)
			let n = Number(e.substring(1, 3)),
				i = Number(e.substring(4, 6))
			return r * (n * 60 + i) * 60 * 1e3
		}, 'parseOffsetToMilliseconds'),
		bs = Y((e) => {
			let t = 0
			for (; t < e.length - 1 && e.charAt(t) === '0'; ) t++
			return t === 0 ? e : e.slice(t)
		}, 'stripLeadingZeroes'),
		mw = class fw extends Error {
			constructor(t) {
				super(t.message),
					Object.setPrototypeOf(this, fw.prototype),
					(this.name = t.name),
					(this.$fault = t.$fault),
					(this.$metadata = t.$metadata)
			}
		}
	Y(mw, 'ServiceException')
	var NK = mw,
		pw = Y((e, t = {}) => {
			Object.entries(t)
				.filter(([, n]) => n !== void 0)
				.forEach(([n, i]) => {
					;(e[n] == null || e[n] === '') && (e[n] = i)
				})
			let r = e.message || e.Message || 'UnknownError'
			return (e.message = r), delete e.Message, e
		}, 'decorateServiceException'),
		gw = Y(({ output: e, parsedBody: t, exceptionCtor: r, errorCode: n }) => {
			let i = LK(e),
				o = i.httpStatusCode ? i.httpStatusCode + '' : void 0,
				s = new r({
					name: t?.code || t?.Code || n || o || 'UnknownError',
					$fault: 'client',
					$metadata: i,
				})
			throw pw(s, t)
		}, 'throwDefaultError'),
		DK = Y(
			(e) =>
				({ output: t, parsedBody: r, errorCode: n }) => {
					gw({ output: t, parsedBody: r, exceptionCtor: e, errorCode: n })
				},
			'withBaseException',
		),
		LK = Y(
			(e) => ({
				httpStatusCode: e.statusCode,
				requestId:
					e.headers['x-amzn-requestid'] ??
					e.headers['x-amzn-request-id'] ??
					e.headers['x-amz-request-id'],
				extendedRequestId: e.headers['x-amz-id-2'],
				cfId: e.headers['x-amz-cf-id'],
			}),
			'deserializeMetadata',
		),
		FK = Y((e) => {
			switch (e) {
				case 'standard':
					return { retryMode: 'standard', connectionTimeout: 3100 }
				case 'in-region':
					return { retryMode: 'standard', connectionTimeout: 1100 }
				case 'cross-region':
					return { retryMode: 'standard', connectionTimeout: 3100 }
				case 'mobile':
					return { retryMode: 'standard', connectionTimeout: 3e4 }
				default:
					return {}
			}
		}, 'loadConfigsForDefaultMode'),
		Qb = !1,
		MK = Y((e) => {
			e && !Qb && parseInt(e.substring(1, e.indexOf('.'))) < 16 && (Qb = !0)
		}, 'emitWarningIfUnsupportedVersion'),
		qK = Y((e) => {
			let t = []
			for (let r in kg.AlgorithmId) {
				let n = kg.AlgorithmId[r]
				e[n] !== void 0 &&
					t.push({ algorithmId: () => n, checksumConstructor: () => e[n] })
			}
			return {
				_checksumAlgorithms: t,
				addChecksumAlgorithm(r) {
					this._checksumAlgorithms.push(r)
				},
				checksumAlgorithms() {
					return this._checksumAlgorithms
				},
			}
		}, 'getChecksumConfiguration'),
		jK = Y((e) => {
			let t = {}
			return (
				e.checksumAlgorithms().forEach((r) => {
					t[r.algorithmId()] = r.checksumConstructor()
				}),
				t
			)
		}, 'resolveChecksumRuntimeConfig'),
		UK = Y((e) => {
			let t = e.retryStrategy
			return {
				setRetryStrategy(r) {
					t = r
				},
				retryStrategy() {
					return t
				},
			}
		}, 'getRetryConfiguration'),
		GK = Y((e) => {
			let t = {}
			return (t.retryStrategy = e.retryStrategy()), t
		}, 'resolveRetryRuntimeConfig'),
		vw = Y((e) => ({ ...qK(e), ...UK(e) }), 'getDefaultExtensionConfiguration'),
		zK = vw,
		HK = Y((e) => ({ ...jK(e), ...GK(e) }), 'resolveDefaultRuntimeConfig')
	function Nd(e) {
		return encodeURIComponent(e).replace(/[!'()*]/g, function (t) {
			return '%' + t.charCodeAt(0).toString(16).toUpperCase()
		})
	}
	Y(Nd, 'extendedEncodeURIComponent')
	var $K = Y((e) => (Array.isArray(e) ? e : [e]), 'getArrayIfSingleItem'),
		hw = Y((e) => {
			let t = '#text'
			for (let r in e)
				e.hasOwnProperty(r) && e[r][t] !== void 0
					? (e[r] = e[r][t])
					: typeof e[r] == 'object' && e[r] !== null && (e[r] = hw(e[r]))
			return e
		}, 'getValueFromTextNode'),
		Nc = Y(function () {
			let e = Object.getPrototypeOf(this).constructor,
				t = Function.bind.apply(String, [null, ...arguments]),
				r = new t()
			return Object.setPrototypeOf(r, e.prototype), r
		}, 'StringWrapper')
	Nc.prototype = Object.create(String.prototype, {
		constructor: { value: Nc, enumerable: !1, writable: !0, configurable: !0 },
	})
	Object.setPrototypeOf(Nc, String)
	var _w = class Id extends Nc {
		deserializeJSON() {
			return JSON.parse(super.toString())
		}
		toJSON() {
			return super.toString()
		}
		static fromObject(t) {
			return t instanceof Id
				? t
				: t instanceof String || typeof t == 'string'
					? new Id(t)
					: new Id(JSON.stringify(t))
		}
	}
	Y(_w, 'LazyJsonString')
	var VK = _w
	function qg(e, t, r) {
		let n, i, o
		if (typeof t > 'u' && typeof r > 'u') (n = {}), (o = e)
		else {
			if (((n = e), typeof t == 'function'))
				return (i = t), (o = r), XK(n, i, o)
			o = t
		}
		for (let s of Object.keys(o)) {
			if (!Array.isArray(o[s])) {
				n[s] = o[s]
				continue
			}
			yw(n, null, o, s)
		}
		return n
	}
	Y(qg, 'map')
	var KK = Y((e) => {
			let t = {}
			for (let [r, n] of Object.entries(e || {})) t[r] = [, n]
			return t
		}, 'convertMap'),
		WK = Y((e, t) => {
			let r = {}
			for (let n in t) yw(r, e, t, n)
			return r
		}, 'take'),
		XK = Y(
			(e, t, r) =>
				qg(
					e,
					Object.entries(r).reduce(
						(n, [i, o]) => (
							Array.isArray(o)
								? (n[i] = o)
								: typeof o == 'function'
									? (n[i] = [t, o()])
									: (n[i] = [t, o]),
							n
						),
						{},
					),
				),
			'mapWithFilter',
		),
		yw = Y((e, t, r, n) => {
			if (t !== null) {
				let s = r[n]
				typeof s == 'function' && (s = [, s])
				let [c = YK, l = JK, u = n] = s
				;((typeof c == 'function' && c(t[u])) ||
					(typeof c != 'function' && c)) &&
					(e[n] = l(t[u]))
				return
			}
			let [i, o] = r[n]
			if (typeof o == 'function') {
				let s,
					c = i === void 0 && (s = o()) != null,
					l =
						(typeof i == 'function' && !!i(void 0)) ||
						(typeof i != 'function' && !!i)
				c ? (e[n] = s) : l && (e[n] = o())
			} else {
				let s = i === void 0 && o != null,
					c =
						(typeof i == 'function' && !!i(o)) ||
						(typeof i != 'function' && !!i)
				;(s || c) && (e[n] = o)
			}
		}, 'applyInstruction'),
		YK = Y((e) => e != null, 'nonNullish'),
		JK = Y((e) => e, 'pass'),
		QK = Y((e, t, r, n, i, o) => {
			if (t != null && t[r] !== void 0) {
				let s = n()
				if (s.length <= 0)
					throw new Error(
						'Empty value provided for input HTTP label: ' + r + '.',
					)
				e = e.replace(
					i,
					o
						? s
								.split('/')
								.map((c) => Nd(c))
								.join('/')
						: Nd(s),
				)
			} else
				throw new Error('No value provided for input HTTP label: ' + r + '.')
			return e
		}, 'resolvedPath'),
		ZK = Y((e) => {
			if (e !== e) return 'NaN'
			switch (e) {
				case 1 / 0:
					return 'Infinity'
				case -1 / 0:
					return '-Infinity'
				default:
					return e
			}
		}, 'serializeFloat'),
		eW = Y((e) => e.toISOString().replace('.000Z', 'Z'), 'serializeDateTime'),
		Ng = Y((e) => {
			if (e == null) return {}
			if (Array.isArray(e)) return e.filter((t) => t != null).map(Ng)
			if (typeof e == 'object') {
				let t = {}
				for (let r of Object.keys(e)) e[r] != null && (t[r] = Ng(e[r]))
				return t
			}
			return e
		}, '_json')
	function Sw(e, t, r) {
		if (r <= 0 || !Number.isInteger(r))
			throw new Error(
				'Invalid number of delimiters (' + r + ') for splitEvery.',
			)
		let n = e.split(t)
		if (r === 1) return n
		let i = [],
			o = ''
		for (let s = 0; s < n.length; s++)
			o === '' ? (o = n[s]) : (o += t + n[s]),
				(s + 1) % r === 0 && (i.push(o), (o = ''))
		return o !== '' && i.push(o), i
	}
	Y(Sw, 'splitEvery')
})
var Tr = E((JAe, xw) => {
	var Ld = Object.defineProperty,
		tW = Object.getOwnPropertyDescriptor,
		rW = Object.getOwnPropertyNames,
		nW = Object.prototype.hasOwnProperty,
		bw = (e, t) => Ld(e, 'name', { value: t, configurable: !0 }),
		iW = (e, t) => {
			for (var r in t) Ld(e, r, { get: t[r], enumerable: !0 })
		},
		oW = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of rW(t))
					!nW.call(e, i) &&
						i !== r &&
						Ld(e, i, {
							get: () => t[i],
							enumerable: !(n = tW(t, i)) || n.enumerable,
						})
			return e
		},
		sW = (e) => oW(Ld({}, '__esModule', { value: !0 }), e),
		ww = {}
	iW(ww, { getSmithyContext: () => aW, normalizeProvider: () => cW })
	xw.exports = sW(ww)
	var Ew = en(),
		aW = bw(
			(e) => e[Ew.SMITHY_CONTEXT_KEY] || (e[Ew.SMITHY_CONTEXT_KEY] = {}),
			'getSmithyContext',
		),
		cW = bw((e) => {
			if (typeof e == 'function') return e
			let t = Promise.resolve(e)
			return () => t
		}, 'normalizeProvider')
})
var Vg = E((eOe, $w) => {
	var Ud = Object.defineProperty,
		lW = Object.getOwnPropertyDescriptor,
		dW = Object.getOwnPropertyNames,
		uW = Object.prototype.hasOwnProperty,
		It = (e, t) => Ud(e, 'name', { value: t, configurable: !0 }),
		mW = (e, t) => {
			for (var r in t) Ud(e, r, { get: t[r], enumerable: !0 })
		},
		fW = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of dW(t))
					!uW.call(e, i) &&
						i !== r &&
						Ud(e, i, {
							get: () => t[i],
							enumerable: !(n = lW(t, i)) || n.enumerable,
						})
			return e
		},
		pW = (e) => fW(Ud({}, '__esModule', { value: !0 }), e),
		kw = {}
	mW(kw, {
		SignatureV4: () => jW,
		clearCredentialCache: () => IW,
		createScope: () => qd,
		getCanonicalHeaders: () => zg,
		getCanonicalQuery: () => Mw,
		getPayloadHash: () => jd,
		getSigningKey: () => Fw,
		moveHeadersToQuery: () => zw,
		prepareRequest: () => $g,
	})
	$w.exports = pW(kw)
	var Pw = Tr(),
		jg = rr(),
		gW = 'X-Amz-Algorithm',
		vW = 'X-Amz-Credential',
		Iw = 'X-Amz-Date',
		hW = 'X-Amz-SignedHeaders',
		_W = 'X-Amz-Expires',
		Tw = 'X-Amz-Signature',
		Bw = 'X-Amz-Security-Token',
		Nw = 'authorization',
		Dw = Iw.toLowerCase(),
		yW = 'date',
		SW = [Nw, Dw, yW],
		CW = Tw.toLowerCase(),
		Gg = 'x-amz-content-sha256',
		EW = Bw.toLowerCase(),
		bW = {
			authorization: !0,
			'cache-control': !0,
			connection: !0,
			expect: !0,
			from: !0,
			'keep-alive': !0,
			'max-forwards': !0,
			pragma: !0,
			referer: !0,
			te: !0,
			trailer: !0,
			'transfer-encoding': !0,
			upgrade: !0,
			'user-agent': !0,
			'x-amzn-trace-id': !0,
		},
		wW = /^proxy-/,
		xW = /^sec-/,
		Ug = 'AWS4-HMAC-SHA256',
		PW = 'AWS4-HMAC-SHA256-PAYLOAD',
		AW = 'UNSIGNED-PAYLOAD',
		OW = 50,
		Lw = 'aws4_request',
		RW = 60 * 60 * 24 * 7,
		vi = Ed(),
		kW = rr(),
		xs = {},
		Md = [],
		qd = It((e, t, r) => `${e}/${t}/${r}/${Lw}`, 'createScope'),
		Fw = It(async (e, t, r, n, i) => {
			let o = await Aw(e, t.secretAccessKey, t.accessKeyId),
				s = `${r}:${n}:${i}:${(0, vi.toHex)(o)}:${t.sessionToken}`
			if (s in xs) return xs[s]
			for (Md.push(s); Md.length > OW; ) delete xs[Md.shift()]
			let c = `AWS4${t.secretAccessKey}`
			for (let l of [r, n, i, Lw]) c = await Aw(e, c, l)
			return (xs[s] = c)
		}, 'getSigningKey'),
		IW = It(() => {
			;(Md.length = 0),
				Object.keys(xs).forEach((e) => {
					delete xs[e]
				})
		}, 'clearCredentialCache'),
		Aw = It((e, t, r) => {
			let n = new e(t)
			return n.update((0, kW.toUint8Array)(r)), n.digest()
		}, 'hmac'),
		zg = It(({ headers: e }, t, r) => {
			let n = {}
			for (let i of Object.keys(e).sort()) {
				if (e[i] == null) continue
				let o = i.toLowerCase()
				;((o in bW || t?.has(o) || wW.test(o) || xW.test(o)) &&
					(!r || (r && !r.has(o)))) ||
					(n[o] = e[i].trim().replace(/\s+/g, ' '))
			}
			return n
		}, 'getCanonicalHeaders'),
		Dc = gg(),
		Mw = It(({ query: e = {} }) => {
			let t = [],
				r = {}
			for (let n of Object.keys(e).sort()) {
				if (n.toLowerCase() === CW) continue
				t.push(n)
				let i = e[n]
				typeof i == 'string'
					? (r[n] = `${(0, Dc.escapeUri)(n)}=${(0, Dc.escapeUri)(i)}`)
					: Array.isArray(i) &&
						(r[n] = i
							.slice(0)
							.reduce(
								(o, s) =>
									o.concat([`${(0, Dc.escapeUri)(n)}=${(0, Dc.escapeUri)(s)}`]),
								[],
							)
							.sort()
							.join('&'))
			}
			return t
				.map((n) => r[n])
				.filter((n) => n)
				.join('&')
		}, 'getCanonicalQuery'),
		TW = dd(),
		BW = rr(),
		jd = It(async ({ headers: e, body: t }, r) => {
			for (let n of Object.keys(e)) if (n.toLowerCase() === Gg) return e[n]
			if (t == null)
				return 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'
			if (
				typeof t == 'string' ||
				ArrayBuffer.isView(t) ||
				(0, TW.isArrayBuffer)(t)
			) {
				let n = new r()
				return (
					n.update((0, BW.toUint8Array)(t)), (0, vi.toHex)(await n.digest())
				)
			}
			return AW
		}, 'getPayloadHash'),
		Ow = rr(),
		qw = class {
			format(t) {
				let r = []
				for (let o of Object.keys(t)) {
					let s = (0, Ow.fromUtf8)(o)
					r.push(
						Uint8Array.from([s.byteLength]),
						s,
						this.formatHeaderValue(t[o]),
					)
				}
				let n = new Uint8Array(r.reduce((o, s) => o + s.byteLength, 0)),
					i = 0
				for (let o of r) n.set(o, i), (i += o.byteLength)
				return n
			}
			formatHeaderValue(t) {
				switch (t.type) {
					case 'boolean':
						return Uint8Array.from([t.value ? 0 : 1])
					case 'byte':
						return Uint8Array.from([2, t.value])
					case 'short':
						let r = new DataView(new ArrayBuffer(3))
						return (
							r.setUint8(0, 3),
							r.setInt16(1, t.value, !1),
							new Uint8Array(r.buffer)
						)
					case 'integer':
						let n = new DataView(new ArrayBuffer(5))
						return (
							n.setUint8(0, 4),
							n.setInt32(1, t.value, !1),
							new Uint8Array(n.buffer)
						)
					case 'long':
						let i = new Uint8Array(9)
						return (i[0] = 5), i.set(t.value.bytes, 1), i
					case 'binary':
						let o = new DataView(new ArrayBuffer(3 + t.value.byteLength))
						o.setUint8(0, 6), o.setUint16(1, t.value.byteLength, !1)
						let s = new Uint8Array(o.buffer)
						return s.set(t.value, 3), s
					case 'string':
						let c = (0, Ow.fromUtf8)(t.value),
							l = new DataView(new ArrayBuffer(3 + c.byteLength))
						l.setUint8(0, 7), l.setUint16(1, c.byteLength, !1)
						let u = new Uint8Array(l.buffer)
						return u.set(c, 3), u
					case 'timestamp':
						let m = new Uint8Array(9)
						return (
							(m[0] = 8), m.set(LW.fromNumber(t.value.valueOf()).bytes, 1), m
						)
					case 'uuid':
						if (!DW.test(t.value))
							throw new Error(`Invalid UUID received: ${t.value}`)
						let f = new Uint8Array(17)
						return (
							(f[0] = 9),
							f.set((0, vi.fromHex)(t.value.replace(/\-/g, '')), 1),
							f
						)
				}
			}
		}
	It(qw, 'HeaderFormatter')
	var NW = qw,
		DW = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
		jw = class Uw {
			constructor(t) {
				if (((this.bytes = t), t.byteLength !== 8))
					throw new Error('Int64 buffers must be exactly 8 bytes')
			}
			static fromNumber(t) {
				if (t > 9223372036854776e3 || t < -9223372036854776e3)
					throw new Error(
						`${t} is too large (or, if negative, too small) to represent as an Int64`,
					)
				let r = new Uint8Array(8)
				for (
					let n = 7, i = Math.abs(Math.round(t));
					n > -1 && i > 0;
					n--, i /= 256
				)
					r[n] = i
				return t < 0 && Hg(r), new Uw(r)
			}
			valueOf() {
				let t = this.bytes.slice(0),
					r = t[0] & 128
				return r && Hg(t), parseInt((0, vi.toHex)(t), 16) * (r ? -1 : 1)
			}
			toString() {
				return String(this.valueOf())
			}
		}
	It(jw, 'Int64')
	var LW = jw
	function Hg(e) {
		for (let t = 0; t < 8; t++) e[t] ^= 255
		for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
	}
	It(Hg, 'negate')
	var FW = It((e, t) => {
			e = e.toLowerCase()
			for (let r of Object.keys(t)) if (e === r.toLowerCase()) return !0
			return !1
		}, 'hasHeader'),
		Gw = Xe(),
		zw = It((e, t = {}) => {
			var r
			let { headers: n, query: i = {} } = Gw.HttpRequest.clone(e)
			for (let o of Object.keys(n)) {
				let s = o.toLowerCase()
				s.slice(0, 6) === 'x-amz-' &&
					!((r = t.unhoistableHeaders) != null && r.has(s)) &&
					((i[o] = n[o]), delete n[o])
			}
			return { ...e, headers: n, query: i }
		}, 'moveHeadersToQuery'),
		$g = It((e) => {
			e = Gw.HttpRequest.clone(e)
			for (let t of Object.keys(e.headers))
				SW.indexOf(t.toLowerCase()) > -1 && delete e.headers[t]
			return e
		}, 'prepareRequest'),
		MW = It(
			(e) =>
				qW(e)
					.toISOString()
					.replace(/\.\d{3}Z$/, 'Z'),
			'iso8601',
		),
		qW = It(
			(e) =>
				typeof e == 'number'
					? new Date(e * 1e3)
					: typeof e == 'string'
						? Number(e)
							? new Date(Number(e) * 1e3)
							: new Date(e)
						: e,
			'toDate',
		),
		Hw = class {
			constructor({
				applyChecksum: t,
				credentials: r,
				region: n,
				service: i,
				sha256: o,
				uriEscapePath: s = !0,
			}) {
				;(this.headerFormatter = new NW()),
					(this.service = i),
					(this.sha256 = o),
					(this.uriEscapePath = s),
					(this.applyChecksum = typeof t == 'boolean' ? t : !0),
					(this.regionProvider = (0, Pw.normalizeProvider)(n)),
					(this.credentialProvider = (0, Pw.normalizeProvider)(r))
			}
			async presign(t, r = {}) {
				let {
						signingDate: n = new Date(),
						expiresIn: i = 3600,
						unsignableHeaders: o,
						unhoistableHeaders: s,
						signableHeaders: c,
						signingRegion: l,
						signingService: u,
					} = r,
					m = await this.credentialProvider()
				this.validateResolvedCredentials(m)
				let f = l ?? (await this.regionProvider()),
					{ longDate: p, shortDate: g } = Fd(n)
				if (i > RW)
					return Promise.reject(
						'Signature version 4 presigned URLs must have an expiration date less than one week in the future',
					)
				let v = qd(g, f, u ?? this.service),
					_ = zw($g(t), { unhoistableHeaders: s })
				m.sessionToken && (_.query[Bw] = m.sessionToken),
					(_.query[gW] = Ug),
					(_.query[vW] = `${m.accessKeyId}/${v}`),
					(_.query[Iw] = p),
					(_.query[_W] = i.toString(10))
				let y = zg(_, o, c)
				return (
					(_.query[hW] = Rw(y)),
					(_.query[Tw] = await this.getSignature(
						p,
						v,
						this.getSigningKey(m, f, g, u),
						this.createCanonicalRequest(_, y, await jd(t, this.sha256)),
					)),
					_
				)
			}
			async sign(t, r) {
				return typeof t == 'string'
					? this.signString(t, r)
					: t.headers && t.payload
						? this.signEvent(t, r)
						: t.message
							? this.signMessage(t, r)
							: this.signRequest(t, r)
			}
			async signEvent(
				{ headers: t, payload: r },
				{
					signingDate: n = new Date(),
					priorSignature: i,
					signingRegion: o,
					signingService: s,
				},
			) {
				let c = o ?? (await this.regionProvider()),
					{ shortDate: l, longDate: u } = Fd(n),
					m = qd(l, c, s ?? this.service),
					f = await jd({ headers: {}, body: r }, this.sha256),
					p = new this.sha256()
				p.update(t)
				let g = (0, vi.toHex)(await p.digest()),
					v = [PW, u, m, i, g, f].join(`
`)
				return this.signString(v, {
					signingDate: n,
					signingRegion: c,
					signingService: s,
				})
			}
			async signMessage(
				t,
				{ signingDate: r = new Date(), signingRegion: n, signingService: i },
			) {
				return this.signEvent(
					{
						headers: this.headerFormatter.format(t.message.headers),
						payload: t.message.body,
					},
					{
						signingDate: r,
						signingRegion: n,
						signingService: i,
						priorSignature: t.priorSignature,
					},
				).then((s) => ({ message: t.message, signature: s }))
			}
			async signString(
				t,
				{
					signingDate: r = new Date(),
					signingRegion: n,
					signingService: i,
				} = {},
			) {
				let o = await this.credentialProvider()
				this.validateResolvedCredentials(o)
				let s = n ?? (await this.regionProvider()),
					{ shortDate: c } = Fd(r),
					l = new this.sha256(await this.getSigningKey(o, s, c, i))
				return (
					l.update((0, jg.toUint8Array)(t)), (0, vi.toHex)(await l.digest())
				)
			}
			async signRequest(
				t,
				{
					signingDate: r = new Date(),
					signableHeaders: n,
					unsignableHeaders: i,
					signingRegion: o,
					signingService: s,
				} = {},
			) {
				let c = await this.credentialProvider()
				this.validateResolvedCredentials(c)
				let l = o ?? (await this.regionProvider()),
					u = $g(t),
					{ longDate: m, shortDate: f } = Fd(r),
					p = qd(f, l, s ?? this.service)
				;(u.headers[Dw] = m), c.sessionToken && (u.headers[EW] = c.sessionToken)
				let g = await jd(u, this.sha256)
				!FW(Gg, u.headers) && this.applyChecksum && (u.headers[Gg] = g)
				let v = zg(u, i, n),
					_ = await this.getSignature(
						m,
						p,
						this.getSigningKey(c, l, f, s),
						this.createCanonicalRequest(u, v, g),
					)
				return (
					(u.headers[Nw] =
						`${Ug} Credential=${c.accessKeyId}/${p}, SignedHeaders=${Rw(v)}, Signature=${_}`),
					u
				)
			}
			createCanonicalRequest(t, r, n) {
				let i = Object.keys(r).sort()
				return `${t.method}
${this.getCanonicalPath(t)}
${Mw(t)}
${i
	.map((o) => `${o}:${r[o]}`)
	.join(`
`)}

${i.join(';')}
${n}`
			}
			async createStringToSign(t, r, n) {
				let i = new this.sha256()
				i.update((0, jg.toUint8Array)(n))
				let o = await i.digest()
				return `${Ug}
${t}
${r}
${(0, vi.toHex)(o)}`
			}
			getCanonicalPath({ path: t }) {
				if (this.uriEscapePath) {
					let r = []
					for (let o of t.split('/'))
						o?.length !== 0 && o !== '.' && (o === '..' ? r.pop() : r.push(o))
					let n = `${t?.startsWith('/') ? '/' : ''}${r.join('/')}${r.length > 0 && t?.endsWith('/') ? '/' : ''}`
					return (0, Dc.escapeUri)(n).replace(/%2F/g, '/')
				}
				return t
			}
			async getSignature(t, r, n, i) {
				let o = await this.createStringToSign(t, r, i),
					s = new this.sha256(await n)
				return (
					s.update((0, jg.toUint8Array)(o)), (0, vi.toHex)(await s.digest())
				)
			}
			getSigningKey(t, r, n, i) {
				return Fw(this.sha256, t, n, r, i || this.service)
			}
			validateResolvedCredentials(t) {
				if (
					typeof t != 'object' ||
					typeof t.accessKeyId != 'string' ||
					typeof t.secretAccessKey != 'string'
				)
					throw new Error('Resolved credential object is not valid')
			}
		}
	It(Hw, 'SignatureV4')
	var jW = Hw,
		Fd = It((e) => {
			let t = MW(e).replace(/[\-:]/g, '')
			return { longDate: t, shortDate: t.slice(0, 8) }
		}, 'formatDate'),
		Rw = It((e) => Object.keys(e).sort().join(';'), 'getCanonicalHeaderList')
})
var zd = E((tOe, Xw) => {
	var Gd = Object.defineProperty,
		UW = Object.getOwnPropertyDescriptor,
		GW = Object.getOwnPropertyNames,
		zW = Object.prototype.hasOwnProperty,
		Vw = (e, t) => Gd(e, 'name', { value: t, configurable: !0 }),
		HW = (e, t) => {
			for (var r in t) Gd(e, r, { get: t[r], enumerable: !0 })
		},
		$W = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of GW(t))
					!zW.call(e, i) &&
						i !== r &&
						Gd(e, i, {
							get: () => t[i],
							enumerable: !(n = UW(t, i)) || n.enumerable,
						})
			return e
		},
		VW = (e) => $W(Gd({}, '__esModule', { value: !0 }), e),
		Kw = {}
	HW(Kw, {
		SelectorType: () => Ww,
		booleanSelector: () => KW,
		numberSelector: () => WW,
	})
	Xw.exports = VW(Kw)
	var KW = Vw((e, t, r) => {
			if (t in e) {
				if (e[t] === 'true') return !0
				if (e[t] === 'false') return !1
				throw new Error(
					`Cannot load ${r} "${t}". Expected "true" or "false", got ${e[t]}.`,
				)
			}
		}, 'booleanSelector'),
		WW = Vw((e, t, r) => {
			if (!(t in e)) return
			let n = parseInt(e[t], 10)
			if (Number.isNaN(n))
				throw new TypeError(
					`Cannot load ${r} '${t}'. Expected number, got '${e[t]}'.`,
				)
			return n
		}, 'numberSelector'),
		Ww = ((e) => ((e.ENV = 'env'), (e.CONFIG = 'shared config entry'), e))(
			Ww || {},
		)
})
function XW(e) {
	let t = new Map()
	for (let r of e) t.set(r.schemeId, r)
	return t
}
var rOe,
	Yw,
	Lc,
	Hd = oe(() => {
		;(rOe = Oe(en())), (Yw = Oe(Tr()))
		Lc = (e, t) => (r, n) => async (i) => {
			let o = e.httpAuthSchemeProvider(
					await t.httpAuthSchemeParametersProvider(e, n, i.input),
				),
				s = XW(e.httpAuthSchemes),
				c = (0, Yw.getSmithyContext)(n),
				l = []
			for (let u of o) {
				let m = s.get(u.schemeId)
				if (!m) {
					l.push(
						`HttpAuthScheme \`${u.schemeId}\` was not enabled for this service.`,
					)
					continue
				}
				let f = m.identityProvider(await t.identityProviderConfigProvider(e))
				if (!f) {
					l.push(
						`HttpAuthScheme \`${u.schemeId}\` did not have an IdentityProvider configured.`,
					)
					continue
				}
				let { identityProperties: p = {}, signingProperties: g = {} } =
					u.propertiesExtractor?.(e, n) || {}
				;(u.identityProperties = Object.assign(u.identityProperties || {}, p)),
					(u.signingProperties = Object.assign(u.signingProperties || {}, g)),
					(c.selectedHttpAuthScheme = {
						httpAuthOption: u,
						identity: await f(u.identityProperties),
						signer: m.signer,
					})
				break
			}
			if (!c.selectedHttpAuthScheme)
				throw new Error(
					l.join(`
`),
				)
			return r(i)
		}
	})
var nr = E((oOe, ix) => {
	var $d = Object.defineProperty,
		YW = Object.getOwnPropertyDescriptor,
		JW = Object.getOwnPropertyNames,
		QW = Object.prototype.hasOwnProperty,
		mo = (e, t) => $d(e, 'name', { value: t, configurable: !0 }),
		ZW = (e, t) => {
			for (var r in t) $d(e, r, { get: t[r], enumerable: !0 })
		},
		e5 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of JW(t))
					!QW.call(e, i) &&
						i !== r &&
						$d(e, i, {
							get: () => t[i],
							enumerable: !(n = YW(t, i)) || n.enumerable,
						})
			return e
		},
		t5 = (e) => e5($d({}, '__esModule', { value: !0 }), e),
		Jw = {}
	ZW(Jw, {
		CredentialsProviderError: () => r5,
		ProviderError: () => Vd,
		TokenProviderError: () => n5,
		chain: () => i5,
		fromStatic: () => o5,
		memoize: () => s5,
	})
	ix.exports = t5(Jw)
	var Qw = class Zw extends Error {
		constructor(t, r = !0) {
			var n
			let i,
				o = !0
			typeof r == 'boolean'
				? ((i = void 0), (o = r))
				: r != null &&
					typeof r == 'object' &&
					((i = r.logger), (o = r.tryNextLink ?? !0)),
				super(t),
				(this.name = 'ProviderError'),
				(this.tryNextLink = o),
				Object.setPrototypeOf(this, Zw.prototype),
				(n = i?.debug) == null ||
					n.call(i, `@smithy/property-provider ${o ? '->' : '(!)'} ${t}`)
		}
		static from(t, r = !0) {
			return Object.assign(new this(t.message, r), t)
		}
	}
	mo(Qw, 'ProviderError')
	var Vd = Qw,
		ex = class tx extends Vd {
			constructor(t, r = !0) {
				super(t, r),
					(this.name = 'CredentialsProviderError'),
					Object.setPrototypeOf(this, tx.prototype)
			}
		}
	mo(ex, 'CredentialsProviderError')
	var r5 = ex,
		rx = class nx extends Vd {
			constructor(t, r = !0) {
				super(t, r),
					(this.name = 'TokenProviderError'),
					Object.setPrototypeOf(this, nx.prototype)
			}
		}
	mo(rx, 'TokenProviderError')
	var n5 = rx,
		i5 = mo(
			(...e) =>
				async () => {
					if (e.length === 0) throw new Vd('No providers in chain')
					let t
					for (let r of e)
						try {
							return await r()
						} catch (n) {
							if (((t = n), n?.tryNextLink)) continue
							throw n
						}
					throw t
				},
			'chain',
		),
		o5 = mo((e) => () => Promise.resolve(e), 'fromStatic'),
		s5 = mo((e, t, r) => {
			let n,
				i,
				o,
				s = !1,
				c = mo(async () => {
					i || (i = e())
					try {
						;(n = await i), (o = !0), (s = !1)
					} finally {
						i = void 0
					}
					return n
				}, 'coalesceProvider')
			return t === void 0
				? async (l) => ((!o || l?.forceRefresh) && (n = await c()), n)
				: async (l) => (
						(!o || l?.forceRefresh) && (n = await c()),
						s ? n : r && !r(n) ? ((s = !0), n) : (t(n) && (await c()), n)
					)
		}, 'memoize')
})
var Ps = E((Kd) => {
	'use strict'
	Object.defineProperty(Kd, '__esModule', { value: !0 })
	Kd.getHomeDir = void 0
	var a5 = require('os'),
		c5 = require('path'),
		Kg = {},
		l5 = () =>
			process && process.geteuid ? `${process.geteuid()}` : 'DEFAULT',
		d5 = () => {
			let {
				HOME: e,
				USERPROFILE: t,
				HOMEPATH: r,
				HOMEDRIVE: n = `C:${c5.sep}`,
			} = process.env
			if (e) return e
			if (t) return t
			if (r) return `${n}${r}`
			let i = l5()
			return Kg[i] || (Kg[i] = (0, a5.homedir)()), Kg[i]
		}
	Kd.getHomeDir = d5
})
var Wg = E((Wd) => {
	'use strict'
	Object.defineProperty(Wd, '__esModule', { value: !0 })
	Wd.getSSOTokenFilepath = void 0
	var u5 = require('crypto'),
		m5 = require('path'),
		f5 = Ps(),
		p5 = (e) => {
			let r = (0, u5.createHash)('sha1').update(e).digest('hex')
			return (0, m5.join)(
				(0, f5.getHomeDir)(),
				'.aws',
				'sso',
				'cache',
				`${r}.json`,
			)
		}
	Wd.getSSOTokenFilepath = p5
})
var ox = E((Xd) => {
	'use strict'
	Object.defineProperty(Xd, '__esModule', { value: !0 })
	Xd.getSSOTokenFromFile = void 0
	var g5 = require('fs'),
		v5 = Wg(),
		{ readFile: h5 } = g5.promises,
		_5 = async (e) => {
			let t = (0, v5.getSSOTokenFilepath)(e),
				r = await h5(t, 'utf8')
			return JSON.parse(r)
		}
	Xd.getSSOTokenFromFile = _5
})
var Yg = E((Yd) => {
	'use strict'
	Object.defineProperty(Yd, '__esModule', { value: !0 })
	Yd.slurpFile = void 0
	var y5 = require('fs'),
		{ readFile: S5 } = y5.promises,
		Xg = {},
		C5 = (e, t) => (
			(!Xg[e] || t?.ignoreCache) && (Xg[e] = S5(e, 'utf8')), Xg[e]
		)
	Yd.slurpFile = C5
})
var hi = E((dOe, Mc) => {
	var Zd = Object.defineProperty,
		E5 = Object.getOwnPropertyDescriptor,
		b5 = Object.getOwnPropertyNames,
		w5 = Object.prototype.hasOwnProperty,
		Br = (e, t) => Zd(e, 'name', { value: t, configurable: !0 }),
		x5 = (e, t) => {
			for (var r in t) Zd(e, r, { get: t[r], enumerable: !0 })
		},
		Jg = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of b5(t))
					!w5.call(e, i) &&
						i !== r &&
						Zd(e, i, {
							get: () => t[i],
							enumerable: !(n = E5(t, i)) || n.enumerable,
						})
			return e
		},
		Zg = (e, t, r) => (Jg(e, t, 'default'), r && Jg(r, t, 'default')),
		P5 = (e) => Jg(Zd({}, '__esModule', { value: !0 }), e),
		Fc = {}
	x5(Fc, {
		CONFIG_PREFIX_SEPARATOR: () => fo,
		DEFAULT_PROFILE: () => lx,
		ENV_PROFILE: () => cx,
		getProfileName: () => A5,
		loadSharedConfigFiles: () => ux,
		loadSsoSessionData: () => j5,
		parseKnownFiles: () => G5,
	})
	Mc.exports = P5(Fc)
	Zg(Fc, Ps(), Mc.exports)
	var cx = 'AWS_PROFILE',
		lx = 'default',
		A5 = Br((e) => e.profile || process.env[cx] || lx, 'getProfileName')
	Zg(Fc, Wg(), Mc.exports)
	Zg(Fc, ox(), Mc.exports)
	var Jd = en(),
		O5 = Br(
			(e) =>
				Object.entries(e)
					.filter(([t]) => {
						let r = t.indexOf(fo)
						return r === -1
							? !1
							: Object.values(Jd.IniSectionType).includes(t.substring(0, r))
					})
					.reduce(
						(t, [r, n]) => {
							let i = r.indexOf(fo),
								o =
									r.substring(0, i) === Jd.IniSectionType.PROFILE
										? r.substring(i + 1)
										: r
							return (t[o] = n), t
						},
						{ ...(e.default && { default: e.default }) },
					),
			'getConfigData',
		),
		Qd = require('path'),
		R5 = Ps(),
		k5 = 'AWS_CONFIG_FILE',
		dx = Br(
			() =>
				process.env[k5] || (0, Qd.join)((0, R5.getHomeDir)(), '.aws', 'config'),
			'getConfigFilepath',
		),
		I5 = Ps(),
		T5 = 'AWS_SHARED_CREDENTIALS_FILE',
		B5 = Br(
			() =>
				process.env[T5] ||
				(0, Qd.join)((0, I5.getHomeDir)(), '.aws', 'credentials'),
			'getCredentialsFilepath',
		),
		N5 = Ps(),
		D5 = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/,
		L5 = ['__proto__', 'profile __proto__'],
		Qg = Br((e) => {
			let t = {},
				r,
				n
			for (let i of e.split(/\r?\n/)) {
				let o = i.split(/(^|\s)[;#]/)[0].trim()
				if (o[0] === '[' && o[o.length - 1] === ']') {
					;(r = void 0), (n = void 0)
					let c = o.substring(1, o.length - 1),
						l = D5.exec(c)
					if (l) {
						let [, u, , m] = l
						Object.values(Jd.IniSectionType).includes(u) &&
							(r = [u, m].join(fo))
					} else r = c
					if (L5.includes(c))
						throw new Error(`Found invalid profile name "${c}"`)
				} else if (r) {
					let c = o.indexOf('=')
					if (![0, -1].includes(c)) {
						let [l, u] = [o.substring(0, c).trim(), o.substring(c + 1).trim()]
						if (u === '') n = l
						else {
							n && i.trimStart() === i && (n = void 0), (t[r] = t[r] || {})
							let m = n ? [n, l].join(fo) : l
							t[r][m] = u
						}
					}
				}
			}
			return t
		}, 'parseIni'),
		sx = Yg(),
		ax = Br(() => ({}), 'swallowError'),
		fo = '.',
		ux = Br(async (e = {}) => {
			let { filepath: t = B5(), configFilepath: r = dx() } = e,
				n = (0, N5.getHomeDir)(),
				i = '~/',
				o = t
			t.startsWith(i) && (o = (0, Qd.join)(n, t.slice(2)))
			let s = r
			r.startsWith(i) && (s = (0, Qd.join)(n, r.slice(2)))
			let c = await Promise.all([
				(0, sx.slurpFile)(s, { ignoreCache: e.ignoreCache })
					.then(Qg)
					.then(O5)
					.catch(ax),
				(0, sx.slurpFile)(o, { ignoreCache: e.ignoreCache }).then(Qg).catch(ax),
			])
			return { configFile: c[0], credentialsFile: c[1] }
		}, 'loadSharedConfigFiles'),
		F5 = Br(
			(e) =>
				Object.entries(e)
					.filter(([t]) => t.startsWith(Jd.IniSectionType.SSO_SESSION + fo))
					.reduce(
						(t, [r, n]) => ({ ...t, [r.substring(r.indexOf(fo) + 1)]: n }),
						{},
					),
			'getSsoSessionData',
		),
		M5 = Yg(),
		q5 = Br(() => ({}), 'swallowError'),
		j5 = Br(
			async (e = {}) =>
				(0, M5.slurpFile)(e.configFilepath ?? dx())
					.then(Qg)
					.then(F5)
					.catch(q5),
			'loadSsoSessionData',
		),
		U5 = Br((...e) => {
			let t = {}
			for (let r of e)
				for (let [n, i] of Object.entries(r))
					t[n] !== void 0 ? Object.assign(t[n], i) : (t[n] = i)
			return t
		}, 'mergeConfigFiles'),
		G5 = Br(async (e) => {
			let t = await ux(e)
			return U5(t.configFile, t.credentialsFile)
		}, 'parseKnownFiles')
})
var Hn = E((uOe, px) => {
	var eu = Object.defineProperty,
		z5 = Object.getOwnPropertyDescriptor,
		H5 = Object.getOwnPropertyNames,
		$5 = Object.prototype.hasOwnProperty,
		As = (e, t) => eu(e, 'name', { value: t, configurable: !0 }),
		V5 = (e, t) => {
			for (var r in t) eu(e, r, { get: t[r], enumerable: !0 })
		},
		K5 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of H5(t))
					!$5.call(e, i) &&
						i !== r &&
						eu(e, i, {
							get: () => t[i],
							enumerable: !(n = z5(t, i)) || n.enumerable,
						})
			return e
		},
		W5 = (e) => K5(eu({}, '__esModule', { value: !0 }), e),
		fx = {}
	V5(fx, { loadConfig: () => Z5 })
	px.exports = W5(fx)
	var qc = nr()
	function ev(e) {
		try {
			let t = new Set(Array.from(e.match(/([A-Z_]){3,}/g) ?? []))
			return (
				t.delete('CONFIG'),
				t.delete('CONFIG_PREFIX_SEPARATOR'),
				t.delete('ENV'),
				[...t].join(', ')
			)
		} catch {
			return e
		}
	}
	As(ev, 'getSelectorName')
	var X5 = As(
			(e, t) => async () => {
				try {
					let r = e(process.env)
					if (r === void 0) throw new Error()
					return r
				} catch (r) {
					throw new qc.CredentialsProviderError(
						r.message || `Not found in ENV: ${ev(e.toString())}`,
						{ logger: t },
					)
				}
			},
			'fromEnv',
		),
		mx = hi(),
		Y5 = As(
			(e, { preferredFile: t = 'config', ...r } = {}) =>
				async () => {
					let n = (0, mx.getProfileName)(r),
						{ configFile: i, credentialsFile: o } = await (0,
						mx.loadSharedConfigFiles)(r),
						s = o[n] || {},
						c = i[n] || {},
						l = t === 'config' ? { ...s, ...c } : { ...c, ...s }
					try {
						let m = e(l, t === 'config' ? i : o)
						if (m === void 0) throw new Error()
						return m
					} catch (u) {
						throw new qc.CredentialsProviderError(
							u.message ||
								`Not found in config files w/ profile [${n}]: ${ev(e.toString())}`,
							{ logger: r.logger },
						)
					}
				},
			'fromSharedConfigFiles',
		),
		J5 = As((e) => typeof e == 'function', 'isFunction'),
		Q5 = As(
			(e) => (J5(e) ? async () => await e() : (0, qc.fromStatic)(e)),
			'fromStatic',
		),
		Z5 = As(
			(
				{ environmentVariableSelector: e, configFileSelector: t, default: r },
				n = {},
			) => (0, qc.memoize)((0, qc.chain)(X5(e), Y5(t, n), Q5(r))),
			'loadConfig',
		)
})
var _x = E((tu) => {
	'use strict'
	Object.defineProperty(tu, '__esModule', { value: !0 })
	tu.getEndpointUrlConfig = void 0
	var gx = hi(),
		vx = 'AWS_ENDPOINT_URL',
		hx = 'endpoint_url',
		eX = (e) => ({
			environmentVariableSelector: (t) => {
				let r = e.split(' ').map((o) => o.toUpperCase()),
					n = t[[vx, ...r].join('_')]
				if (n) return n
				let i = t[vx]
				if (i) return i
			},
			configFileSelector: (t, r) => {
				if (r && t.services) {
					let i = r[['services', t.services].join(gx.CONFIG_PREFIX_SEPARATOR)]
					if (i) {
						let o = e.split(' ').map((c) => c.toLowerCase()),
							s = i[[o.join('_'), hx].join(gx.CONFIG_PREFIX_SEPARATOR)]
						if (s) return s
					}
				}
				let n = t[hx]
				if (n) return n
			},
			default: void 0,
		})
	tu.getEndpointUrlConfig = eX
})
var yx = E((ru) => {
	'use strict'
	Object.defineProperty(ru, '__esModule', { value: !0 })
	ru.getEndpointFromConfig = void 0
	var tX = Hn(),
		rX = _x(),
		nX = async (e) => (0, tX.loadConfig)((0, rX.getEndpointUrlConfig)(e))()
	ru.getEndpointFromConfig = nX
})
var bx = E((pOe, Ex) => {
	var nu = Object.defineProperty,
		iX = Object.getOwnPropertyDescriptor,
		oX = Object.getOwnPropertyNames,
		sX = Object.prototype.hasOwnProperty,
		aX = (e, t) => nu(e, 'name', { value: t, configurable: !0 }),
		cX = (e, t) => {
			for (var r in t) nu(e, r, { get: t[r], enumerable: !0 })
		},
		lX = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of oX(t))
					!sX.call(e, i) &&
						i !== r &&
						nu(e, i, {
							get: () => t[i],
							enumerable: !(n = iX(t, i)) || n.enumerable,
						})
			return e
		},
		dX = (e) => lX(nu({}, '__esModule', { value: !0 }), e),
		Sx = {}
	cX(Sx, { parseQueryString: () => Cx })
	Ex.exports = dX(Sx)
	function Cx(e) {
		let t = {}
		if (((e = e.replace(/^\?/, '')), e))
			for (let r of e.split('&')) {
				let [n, i = null] = r.split('=')
				;(n = decodeURIComponent(n)),
					i && (i = decodeURIComponent(i)),
					n in t
						? Array.isArray(t[n])
							? t[n].push(i)
							: (t[n] = [t[n], i])
						: (t[n] = i)
			}
		return t
	}
	aX(Cx, 'parseQueryString')
})
var po = E((gOe, Px) => {
	var iu = Object.defineProperty,
		uX = Object.getOwnPropertyDescriptor,
		mX = Object.getOwnPropertyNames,
		fX = Object.prototype.hasOwnProperty,
		pX = (e, t) => iu(e, 'name', { value: t, configurable: !0 }),
		gX = (e, t) => {
			for (var r in t) iu(e, r, { get: t[r], enumerable: !0 })
		},
		vX = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of mX(t))
					!fX.call(e, i) &&
						i !== r &&
						iu(e, i, {
							get: () => t[i],
							enumerable: !(n = uX(t, i)) || n.enumerable,
						})
			return e
		},
		hX = (e) => vX(iu({}, '__esModule', { value: !0 }), e),
		wx = {}
	gX(wx, { parseUrl: () => xx })
	Px.exports = hX(wx)
	var _X = bx(),
		xx = pX((e) => {
			if (typeof e == 'string') return xx(new URL(e))
			let { hostname: t, pathname: r, port: n, protocol: i, search: o } = e,
				s
			return (
				o && (s = (0, _X.parseQueryString)(o)),
				{
					hostname: t,
					port: n ? parseInt(n) : void 0,
					protocol: i,
					path: r,
					query: s,
				}
			)
		}, 'parseUrl')
})
var go = E((vOe, Bx) => {
	var ou = Object.defineProperty,
		yX = Object.getOwnPropertyDescriptor,
		SX = Object.getOwnPropertyNames,
		CX = Object.prototype.hasOwnProperty,
		tv = (e, t) => ou(e, 'name', { value: t, configurable: !0 }),
		EX = (e, t) => {
			for (var r in t) ou(e, r, { get: t[r], enumerable: !0 })
		},
		bX = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of SX(t))
					!CX.call(e, i) &&
						i !== r &&
						ou(e, i, {
							get: () => t[i],
							enumerable: !(n = yX(t, i)) || n.enumerable,
						})
			return e
		},
		wX = (e) => bX(ou({}, '__esModule', { value: !0 }), e),
		Ax = {}
	EX(Ax, {
		deserializerMiddleware: () => Ox,
		deserializerMiddlewareOption: () => kx,
		getSerdePlugin: () => Tx,
		serializerMiddleware: () => Rx,
		serializerMiddlewareOption: () => Ix,
	})
	Bx.exports = wX(Ax)
	var Ox = tv(
			(e, t) => (r) => async (n) => {
				let { response: i } = await r(n)
				try {
					let o = await t(i, e)
					return { response: i, output: o }
				} catch (o) {
					if (
						(Object.defineProperty(o, '$response', { value: i }),
						!('$metadata' in o))
					) {
						let s =
							'Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.'
						;(o.message +=
							`
  ` + s),
							typeof o.$responseBodyText < 'u' &&
								o.$response &&
								(o.$response.body = o.$responseBodyText)
					}
					throw o
				}
			},
			'deserializerMiddleware',
		),
		Rx = tv(
			(e, t) => (r, n) => async (i) => {
				var o
				let s =
					(o = n.endpointV2) != null && o.url && e.urlParser
						? async () => e.urlParser(n.endpointV2.url)
						: e.endpoint
				if (!s) throw new Error('No valid endpoint provider available.')
				let c = await t(i.input, { ...e, endpoint: s })
				return r({ ...i, request: c })
			},
			'serializerMiddleware',
		),
		kx = {
			name: 'deserializerMiddleware',
			step: 'deserialize',
			tags: ['DESERIALIZER'],
			override: !0,
		},
		Ix = {
			name: 'serializerMiddleware',
			step: 'serialize',
			tags: ['SERIALIZER'],
			override: !0,
		}
	function Tx(e, t, r) {
		return {
			applyToStack: (n) => {
				n.add(Ox(e, r), kx), n.add(Rx(e, t), Ix)
			},
		}
	}
	tv(Tx, 'getSerdePlugin')
})
var $n = E((hOe, jx) => {
	var au = Object.defineProperty,
		xX = Object.getOwnPropertyDescriptor,
		PX = Object.getOwnPropertyNames,
		AX = Object.prototype.hasOwnProperty,
		tn = (e, t) => au(e, 'name', { value: t, configurable: !0 }),
		OX = (e, t) => {
			for (var r in t) au(e, r, { get: t[r], enumerable: !0 })
		},
		RX = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of PX(t))
					!AX.call(e, i) &&
						i !== r &&
						au(e, i, {
							get: () => t[i],
							enumerable: !(n = xX(t, i)) || n.enumerable,
						})
			return e
		},
		kX = (e) => RX(au({}, '__esModule', { value: !0 }), e),
		Dx = {}
	OX(Dx, {
		endpointMiddleware: () => Mx,
		endpointMiddlewareOptions: () => qx,
		getEndpointFromInstructions: () => Lx,
		getEndpointPlugin: () => jX,
		resolveEndpointConfig: () => UX,
		resolveParams: () => Fx,
		toEndpointV1: () => rv,
	})
	jx.exports = kX(Dx)
	var IX = tn(async (e) => {
			let t = e?.Bucket || ''
			if (
				(typeof e.Bucket == 'string' &&
					(e.Bucket = t
						.replace(/#/g, encodeURIComponent('#'))
						.replace(/\?/g, encodeURIComponent('?'))),
				LX(t))
			) {
				if (e.ForcePathStyle === !0)
					throw new Error(
						'Path-style addressing cannot be used with ARN buckets',
					)
			} else
				(!DX(t) ||
					(t.indexOf('.') !== -1 && !String(e.Endpoint).startsWith('http:')) ||
					t.toLowerCase() !== t ||
					t.length < 3) &&
					(e.ForcePathStyle = !0)
			return (
				e.DisableMultiRegionAccessPoints &&
					((e.disableMultiRegionAccessPoints = !0), (e.DisableMRAP = !0)),
				e
			)
		}, 'resolveParamsForS3'),
		TX = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/,
		BX = /(\d+\.){3}\d+/,
		NX = /\.\./,
		DX = tn(
			(e) => TX.test(e) && !BX.test(e) && !NX.test(e),
			'isDnsCompatibleBucketName',
		),
		LX = tn((e) => {
			let [t, r, n, , , i] = e.split(':'),
				o = t === 'arn' && e.split(':').length >= 6,
				s = !!(o && r && n && i)
			if (o && !s) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`)
			return s
		}, 'isArnBucketName'),
		FX = tn((e, t, r) => {
			let n = tn(async () => {
				let i = r[e] ?? r[t]
				return typeof i == 'function' ? i() : i
			}, 'configProvider')
			return e === 'credentialScope' || t === 'CredentialScope'
				? async () => {
						let i =
							typeof r.credentials == 'function'
								? await r.credentials()
								: r.credentials
						return i?.credentialScope ?? i?.CredentialScope
					}
				: e === 'accountId' || t === 'AccountId'
					? async () => {
							let i =
								typeof r.credentials == 'function'
									? await r.credentials()
									: r.credentials
							return i?.accountId ?? i?.AccountId
						}
					: e === 'endpoint' || t === 'endpoint'
						? async () => {
								let i = await n()
								if (i && typeof i == 'object') {
									if ('url' in i) return i.url.href
									if ('hostname' in i) {
										let { protocol: o, hostname: s, port: c, path: l } = i
										return `${o}//${s}${c ? ':' + c : ''}${l}`
									}
								}
								return i
							}
						: n
		}, 'createConfigValueProvider'),
		MX = yx(),
		Nx = po(),
		rv = tn(
			(e) =>
				typeof e == 'object'
					? 'url' in e
						? (0, Nx.parseUrl)(e.url)
						: e
					: (0, Nx.parseUrl)(e),
			'toEndpointV1',
		),
		Lx = tn(async (e, t, r, n) => {
			if (!r.endpoint) {
				let s = await (0, MX.getEndpointFromConfig)(r.serviceId || '')
				s && (r.endpoint = () => Promise.resolve(rv(s)))
			}
			let i = await Fx(e, t, r)
			if (typeof r.endpointProvider != 'function')
				throw new Error('config.endpointProvider is not set.')
			return r.endpointProvider(i, n)
		}, 'getEndpointFromInstructions'),
		Fx = tn(async (e, t, r) => {
			var n
			let i = {},
				o =
					((n = t?.getEndpointParameterInstructions) == null
						? void 0
						: n.call(t)) || {}
			for (let [s, c] of Object.entries(o))
				switch (c.type) {
					case 'staticContextParams':
						i[s] = c.value
						break
					case 'contextParams':
						i[s] = e[c.name]
						break
					case 'clientContextParams':
					case 'builtInParams':
						i[s] = await FX(c.name, s, r)()
						break
					default:
						throw new Error(
							'Unrecognized endpoint parameter instruction: ' +
								JSON.stringify(c),
						)
				}
			return (
				Object.keys(o).length === 0 && Object.assign(i, r),
				String(r.serviceId).toLowerCase() === 's3' && (await IX(i)),
				i
			)
		}, 'resolveParams'),
		su = Tr(),
		Mx = tn(
			({ config: e, instructions: t }) =>
				(r, n) =>
				async (i) => {
					var o, s, c
					let l = await Lx(
						i.input,
						{
							getEndpointParameterInstructions() {
								return t
							},
						},
						{ ...e },
						n,
					)
					;(n.endpointV2 = l),
						(n.authSchemes =
							(o = l.properties) == null ? void 0 : o.authSchemes)
					let u = (s = n.authSchemes) == null ? void 0 : s[0]
					if (u) {
						;(n.signing_region = u.signingRegion),
							(n.signing_service = u.signingName)
						let m = (0, su.getSmithyContext)(n),
							f =
								(c = m?.selectedHttpAuthScheme) == null
									? void 0
									: c.httpAuthOption
						f &&
							(f.signingProperties = Object.assign(
								f.signingProperties || {},
								{
									signing_region: u.signingRegion,
									signingRegion: u.signingRegion,
									signing_service: u.signingName,
									signingName: u.signingName,
									signingRegionSet: u.signingRegionSet,
								},
								u.properties,
							))
					}
					return r({ ...i })
				},
			'endpointMiddleware',
		),
		qX = go(),
		qx = {
			step: 'serialize',
			tags: ['ENDPOINT_PARAMETERS', 'ENDPOINT_V2', 'ENDPOINT'],
			name: 'endpointV2Middleware',
			override: !0,
			relation: 'before',
			toMiddleware: qX.serializerMiddlewareOption.name,
		},
		jX = tn(
			(e, t) => ({
				applyToStack: (r) => {
					r.addRelativeTo(Mx({ config: e, instructions: t }), qx)
				},
			}),
			'getEndpointPlugin',
		),
		UX = tn((e) => {
			let t = e.tls ?? !0,
				{ endpoint: r } = e,
				n =
					r != null
						? async () => rv(await (0, su.normalizeProvider)(r)())
						: void 0
			return {
				...e,
				endpoint: n,
				tls: t,
				isCustomEndpoint: !!r,
				useDualstackEndpoint: (0, su.normalizeProvider)(
					e.useDualstackEndpoint ?? !1,
				),
				useFipsEndpoint: (0, su.normalizeProvider)(e.useFipsEndpoint ?? !1),
			}
		}, 'resolveEndpointConfig')
})
var Ux,
	Gx,
	GX,
	zx = oe(() => {
		Ux = Oe($n())
		Hd()
		;(Gx = {
			step: 'serialize',
			tags: ['HTTP_AUTH_SCHEME'],
			name: 'httpAuthSchemeMiddleware',
			override: !0,
			relation: 'before',
			toMiddleware: Ux.endpointMiddlewareOptions.name,
		}),
			(GX = (
				e,
				{
					httpAuthSchemeParametersProvider: t,
					identityProviderConfigProvider: r,
				},
			) => ({
				applyToStack: (n) => {
					n.addRelativeTo(
						Lc(e, {
							httpAuthSchemeParametersProvider: t,
							identityProviderConfigProvider: r,
						}),
						Gx,
					)
				},
			}))
	})
var Hx,
	$x,
	zX,
	Vx = oe(() => {
		Hx = Oe(go())
		Hd()
		;($x = {
			step: 'serialize',
			tags: ['HTTP_AUTH_SCHEME'],
			name: 'httpAuthSchemeMiddleware',
			override: !0,
			relation: 'before',
			toMiddleware: Hx.serializerMiddlewareOption.name,
		}),
			(zX = (
				e,
				{
					httpAuthSchemeParametersProvider: t,
					identityProviderConfigProvider: r,
				},
			) => ({
				applyToStack: (n) => {
					n.addRelativeTo(
						Lc(e, {
							httpAuthSchemeParametersProvider: t,
							identityProviderConfigProvider: r,
						}),
						$x,
					)
				},
			}))
	})
var Kx = oe(() => {
	Hd()
	zx()
	Vx()
})
var Wx,
	POe,
	Xx,
	HX,
	$X,
	nv,
	iv = oe(() => {
		;(Wx = Oe(Xe())),
			(POe = Oe(en())),
			(Xx = Oe(Tr())),
			(HX = (e) => (t) => {
				throw t
			}),
			($X = (e, t) => {}),
			(nv = (e) => (t, r) => async (n) => {
				if (!Wx.HttpRequest.isInstance(n.request)) return t(n)
				let o = (0, Xx.getSmithyContext)(r).selectedHttpAuthScheme
				if (!o)
					throw new Error(
						'No HttpAuthScheme was selected: unable to sign request',
					)
				let {
						httpAuthOption: { signingProperties: s = {} },
						identity: c,
						signer: l,
					} = o,
					u = await t({ ...n, request: await l.sign(n.request, c, s) }).catch(
						(l.errorHandler || HX)(s),
					)
				return (l.successHandler || $X)(u.response, s), u
			})
	})
function jc() {
	return (
		cu > lu.length - 16 && (Yx.default.randomFillSync(lu), (cu = 0)),
		lu.slice(cu, (cu += 16))
	)
}
var Yx,
	lu,
	cu,
	ov = oe(() => {
		;(Yx = Oe(require('crypto'))), (lu = new Uint8Array(256)), (cu = lu.length)
	})
var Jx,
	Qx = oe(() => {
		Jx =
			/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
	})
function VX(e) {
	return typeof e == 'string' && Jx.test(e)
}
var _i,
	Uc = oe(() => {
		Qx()
		_i = VX
	})
function vo(e, t = 0) {
	return (
		jt[e[t + 0]] +
		jt[e[t + 1]] +
		jt[e[t + 2]] +
		jt[e[t + 3]] +
		'-' +
		jt[e[t + 4]] +
		jt[e[t + 5]] +
		'-' +
		jt[e[t + 6]] +
		jt[e[t + 7]] +
		'-' +
		jt[e[t + 8]] +
		jt[e[t + 9]] +
		'-' +
		jt[e[t + 10]] +
		jt[e[t + 11]] +
		jt[e[t + 12]] +
		jt[e[t + 13]] +
		jt[e[t + 14]] +
		jt[e[t + 15]]
	)
}
function KX(e, t = 0) {
	let r = vo(e, t)
	if (!_i(r)) throw TypeError('Stringified UUID is invalid')
	return r
}
var jt,
	Zx,
	Gc = oe(() => {
		Uc()
		jt = []
		for (let e = 0; e < 256; ++e) jt.push((e + 256).toString(16).slice(1))
		Zx = KX
	})
function WX(e, t, r) {
	let n = (t && r) || 0,
		i = t || new Array(16)
	e = e || {}
	let o = e.node || eP,
		s = e.clockseq !== void 0 ? e.clockseq : sv
	if (o == null || s == null) {
		let p = e.random || (e.rng || jc)()
		o == null && (o = eP = [p[0] | 1, p[1], p[2], p[3], p[4], p[5]]),
			s == null && (s = sv = ((p[6] << 8) | p[7]) & 16383)
	}
	let c = e.msecs !== void 0 ? e.msecs : Date.now(),
		l = e.nsecs !== void 0 ? e.nsecs : cv + 1,
		u = c - av + (l - cv) / 1e4
	if (
		(u < 0 && e.clockseq === void 0 && (s = (s + 1) & 16383),
		(u < 0 || c > av) && e.nsecs === void 0 && (l = 0),
		l >= 1e4)
	)
		throw new Error("uuid.v1(): Can't create more than 10M uuids/sec")
	;(av = c), (cv = l), (sv = s), (c += 122192928e5)
	let m = ((c & 268435455) * 1e4 + l) % 4294967296
	;(i[n++] = (m >>> 24) & 255),
		(i[n++] = (m >>> 16) & 255),
		(i[n++] = (m >>> 8) & 255),
		(i[n++] = m & 255)
	let f = ((c / 4294967296) * 1e4) & 268435455
	;(i[n++] = (f >>> 8) & 255),
		(i[n++] = f & 255),
		(i[n++] = ((f >>> 24) & 15) | 16),
		(i[n++] = (f >>> 16) & 255),
		(i[n++] = (s >>> 8) | 128),
		(i[n++] = s & 255)
	for (let p = 0; p < 6; ++p) i[n + p] = o[p]
	return t || vo(i)
}
var eP,
	sv,
	av,
	cv,
	tP,
	rP = oe(() => {
		ov()
		Gc()
		;(av = 0), (cv = 0)
		tP = WX
	})
function XX(e) {
	if (!_i(e)) throw TypeError('Invalid UUID')
	let t,
		r = new Uint8Array(16)
	return (
		(r[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24),
		(r[1] = (t >>> 16) & 255),
		(r[2] = (t >>> 8) & 255),
		(r[3] = t & 255),
		(r[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8),
		(r[5] = t & 255),
		(r[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8),
		(r[7] = t & 255),
		(r[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8),
		(r[9] = t & 255),
		(r[10] = ((t = parseInt(e.slice(24, 36), 16)) / 1099511627776) & 255),
		(r[11] = (t / 4294967296) & 255),
		(r[12] = (t >>> 24) & 255),
		(r[13] = (t >>> 16) & 255),
		(r[14] = (t >>> 8) & 255),
		(r[15] = t & 255),
		r
	)
}
var du,
	lv = oe(() => {
		Uc()
		du = XX
	})
function YX(e) {
	e = unescape(encodeURIComponent(e))
	let t = []
	for (let r = 0; r < e.length; ++r) t.push(e.charCodeAt(r))
	return t
}
function zc(e, t, r) {
	function n(i, o, s, c) {
		var l
		if (
			(typeof i == 'string' && (i = YX(i)),
			typeof o == 'string' && (o = du(o)),
			((l = o) === null || l === void 0 ? void 0 : l.length) !== 16)
		)
			throw TypeError(
				'Namespace must be array-like (16 iterable integer values, 0-255)',
			)
		let u = new Uint8Array(16 + i.length)
		if (
			(u.set(o),
			u.set(i, o.length),
			(u = r(u)),
			(u[6] = (u[6] & 15) | t),
			(u[8] = (u[8] & 63) | 128),
			s)
		) {
			c = c || 0
			for (let m = 0; m < 16; ++m) s[c + m] = u[m]
			return s
		}
		return vo(u)
	}
	try {
		n.name = e
	} catch {}
	return (n.DNS = JX), (n.URL = QX), n
}
var JX,
	QX,
	dv = oe(() => {
		Gc()
		lv()
		;(JX = '6ba7b810-9dad-11d1-80b4-00c04fd430c8'),
			(QX = '6ba7b811-9dad-11d1-80b4-00c04fd430c8')
	})
function ZX(e) {
	return (
		Array.isArray(e)
			? (e = Buffer.from(e))
			: typeof e == 'string' && (e = Buffer.from(e, 'utf8')),
		nP.default.createHash('md5').update(e).digest()
	)
}
var nP,
	iP,
	oP = oe(() => {
		nP = Oe(require('crypto'))
		iP = ZX
	})
var e9,
	sP,
	aP = oe(() => {
		dv()
		oP()
		;(e9 = zc('v3', 48, iP)), (sP = e9)
	})
var cP,
	uv,
	lP = oe(() => {
		;(cP = Oe(require('crypto'))), (uv = { randomUUID: cP.default.randomUUID })
	})
function t9(e, t, r) {
	if (uv.randomUUID && !t && !e) return uv.randomUUID()
	e = e || {}
	let n = e.random || (e.rng || jc)()
	if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), t)) {
		r = r || 0
		for (let i = 0; i < 16; ++i) t[r + i] = n[i]
		return t
	}
	return vo(n)
}
var dP,
	uP = oe(() => {
		lP()
		ov()
		Gc()
		dP = t9
	})
function r9(e) {
	return (
		Array.isArray(e)
			? (e = Buffer.from(e))
			: typeof e == 'string' && (e = Buffer.from(e, 'utf8')),
		mP.default.createHash('sha1').update(e).digest()
	)
}
var mP,
	fP,
	pP = oe(() => {
		mP = Oe(require('crypto'))
		fP = r9
	})
var n9,
	gP,
	vP = oe(() => {
		dv()
		pP()
		;(n9 = zc('v5', 80, fP)), (gP = n9)
	})
var hP,
	_P = oe(() => {
		hP = '00000000-0000-0000-0000-000000000000'
	})
function i9(e) {
	if (!_i(e)) throw TypeError('Invalid UUID')
	return parseInt(e.slice(14, 15), 16)
}
var yP,
	SP = oe(() => {
		Uc()
		yP = i9
	})
var CP = {}
Sc(CP, {
	NIL: () => hP,
	parse: () => du,
	stringify: () => Zx,
	v1: () => tP,
	v3: () => sP,
	v4: () => dP,
	v5: () => gP,
	validate: () => _i,
	version: () => yP,
})
var EP = oe(() => {
	rP()
	aP()
	uP()
	vP()
	_P()
	SP()
	Uc()
	Gc()
	lv()
})
var mv = E((pRe, PP) => {
	var uu = Object.defineProperty,
		o9 = Object.getOwnPropertyDescriptor,
		s9 = Object.getOwnPropertyNames,
		a9 = Object.prototype.hasOwnProperty,
		Os = (e, t) => uu(e, 'name', { value: t, configurable: !0 }),
		c9 = (e, t) => {
			for (var r in t) uu(e, r, { get: t[r], enumerable: !0 })
		},
		l9 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of s9(t))
					!a9.call(e, i) &&
						i !== r &&
						uu(e, i, {
							get: () => t[i],
							enumerable: !(n = o9(t, i)) || n.enumerable,
						})
			return e
		},
		d9 = (e) => l9(uu({}, '__esModule', { value: !0 }), e),
		bP = {}
	c9(bP, {
		isClockSkewCorrectedError: () => wP,
		isClockSkewError: () => h9,
		isRetryableByTrait: () => v9,
		isServerError: () => y9,
		isThrottlingError: () => _9,
		isTransientError: () => xP,
	})
	PP.exports = d9(bP)
	var u9 = [
			'AuthFailure',
			'InvalidSignatureException',
			'RequestExpired',
			'RequestInTheFuture',
			'RequestTimeTooSkewed',
			'SignatureDoesNotMatch',
		],
		m9 = [
			'BandwidthLimitExceeded',
			'EC2ThrottledException',
			'LimitExceededException',
			'PriorRequestNotComplete',
			'ProvisionedThroughputExceededException',
			'RequestLimitExceeded',
			'RequestThrottled',
			'RequestThrottledException',
			'SlowDown',
			'ThrottledException',
			'Throttling',
			'ThrottlingException',
			'TooManyRequestsException',
			'TransactionInProgressException',
		],
		f9 = ['TimeoutError', 'RequestTimeout', 'RequestTimeoutException'],
		p9 = [500, 502, 503, 504],
		g9 = ['ECONNRESET', 'ECONNREFUSED', 'EPIPE', 'ETIMEDOUT'],
		v9 = Os((e) => e.$retryable !== void 0, 'isRetryableByTrait'),
		h9 = Os((e) => u9.includes(e.name), 'isClockSkewError'),
		wP = Os((e) => {
			var t
			return (t = e.$metadata) == null ? void 0 : t.clockSkewCorrected
		}, 'isClockSkewCorrectedError'),
		_9 = Os((e) => {
			var t, r
			return (
				((t = e.$metadata) == null ? void 0 : t.httpStatusCode) === 429 ||
				m9.includes(e.name) ||
				((r = e.$retryable) == null ? void 0 : r.throttling) == !0
			)
		}, 'isThrottlingError'),
		xP = Os((e) => {
			var t
			return (
				wP(e) ||
				f9.includes(e.name) ||
				g9.includes(e?.code || '') ||
				p9.includes(
					((t = e.$metadata) == null ? void 0 : t.httpStatusCode) || 0,
				)
			)
		}, 'isTransientError'),
		y9 = Os((e) => {
			var t
			if (((t = e.$metadata) == null ? void 0 : t.httpStatusCode) !== void 0) {
				let r = e.$metadata.httpStatusCode
				return 500 <= r && r <= 599 && !xP(e)
			}
			return !1
		}, 'isServerError')
})
var Rs = E((yRe, qP) => {
	var mu = Object.defineProperty,
		S9 = Object.getOwnPropertyDescriptor,
		C9 = Object.getOwnPropertyNames,
		E9 = Object.prototype.hasOwnProperty,
		rn = (e, t) => mu(e, 'name', { value: t, configurable: !0 }),
		b9 = (e, t) => {
			for (var r in t) mu(e, r, { get: t[r], enumerable: !0 })
		},
		w9 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of C9(t))
					!E9.call(e, i) &&
						i !== r &&
						mu(e, i, {
							get: () => t[i],
							enumerable: !(n = S9(t, i)) || n.enumerable,
						})
			return e
		},
		x9 = (e) => w9(mu({}, '__esModule', { value: !0 }), e),
		OP = {}
	b9(OP, {
		AdaptiveRetryStrategy: () => I9,
		ConfiguredRetryStrategy: () => T9,
		DEFAULT_MAX_ATTEMPTS: () => fv,
		DEFAULT_RETRY_DELAY_BASE: () => Hc,
		DEFAULT_RETRY_MODE: () => P9,
		DefaultRateLimiter: () => IP,
		INITIAL_RETRY_TOKENS: () => pv,
		INVOCATION_ID_HEADER: () => O9,
		MAXIMUM_RETRY_DELAY: () => gv,
		NO_RETRY_INCREMENT: () => DP,
		REQUEST_HEADER: () => R9,
		RETRY_COST: () => BP,
		RETRY_MODES: () => RP,
		StandardRetryStrategy: () => vv,
		THROTTLING_RETRY_DELAY_BASE: () => TP,
		TIMEOUT_RETRY_COST: () => NP,
	})
	qP.exports = x9(OP)
	var RP = ((e) => ((e.STANDARD = 'standard'), (e.ADAPTIVE = 'adaptive'), e))(
			RP || {},
		),
		fv = 3,
		P9 = 'standard',
		A9 = mv(),
		kP = class {
			constructor(t) {
				;(this.currentCapacity = 0),
					(this.enabled = !1),
					(this.lastMaxRate = 0),
					(this.measuredTxRate = 0),
					(this.requestCount = 0),
					(this.lastTimestamp = 0),
					(this.timeWindow = 0),
					(this.beta = t?.beta ?? 0.7),
					(this.minCapacity = t?.minCapacity ?? 1),
					(this.minFillRate = t?.minFillRate ?? 0.5),
					(this.scaleConstant = t?.scaleConstant ?? 0.4),
					(this.smooth = t?.smooth ?? 0.8)
				let r = this.getCurrentTimeInSeconds()
				;(this.lastThrottleTime = r),
					(this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds())),
					(this.fillRate = this.minFillRate),
					(this.maxCapacity = this.minCapacity)
			}
			getCurrentTimeInSeconds() {
				return Date.now() / 1e3
			}
			async getSendToken() {
				return this.acquireTokenBucket(1)
			}
			async acquireTokenBucket(t) {
				if (this.enabled) {
					if ((this.refillTokenBucket(), t > this.currentCapacity)) {
						let r = ((t - this.currentCapacity) / this.fillRate) * 1e3
						await new Promise((n) => setTimeout(n, r))
					}
					this.currentCapacity = this.currentCapacity - t
				}
			}
			refillTokenBucket() {
				let t = this.getCurrentTimeInSeconds()
				if (!this.lastTimestamp) {
					this.lastTimestamp = t
					return
				}
				let r = (t - this.lastTimestamp) * this.fillRate
				;(this.currentCapacity = Math.min(
					this.maxCapacity,
					this.currentCapacity + r,
				)),
					(this.lastTimestamp = t)
			}
			updateClientSendingRate(t) {
				let r
				if ((this.updateMeasuredRate(), (0, A9.isThrottlingError)(t))) {
					let i = this.enabled
						? Math.min(this.measuredTxRate, this.fillRate)
						: this.measuredTxRate
					;(this.lastMaxRate = i),
						this.calculateTimeWindow(),
						(this.lastThrottleTime = this.getCurrentTimeInSeconds()),
						(r = this.cubicThrottle(i)),
						this.enableTokenBucket()
				} else
					this.calculateTimeWindow(),
						(r = this.cubicSuccess(this.getCurrentTimeInSeconds()))
				let n = Math.min(r, 2 * this.measuredTxRate)
				this.updateTokenBucketRate(n)
			}
			calculateTimeWindow() {
				this.timeWindow = this.getPrecise(
					Math.pow(
						(this.lastMaxRate * (1 - this.beta)) / this.scaleConstant,
						1 / 3,
					),
				)
			}
			cubicThrottle(t) {
				return this.getPrecise(t * this.beta)
			}
			cubicSuccess(t) {
				return this.getPrecise(
					this.scaleConstant *
						Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) +
						this.lastMaxRate,
				)
			}
			enableTokenBucket() {
				this.enabled = !0
			}
			updateTokenBucketRate(t) {
				this.refillTokenBucket(),
					(this.fillRate = Math.max(t, this.minFillRate)),
					(this.maxCapacity = Math.max(t, this.minCapacity)),
					(this.currentCapacity = Math.min(
						this.currentCapacity,
						this.maxCapacity,
					))
			}
			updateMeasuredRate() {
				let t = this.getCurrentTimeInSeconds(),
					r = Math.floor(t * 2) / 2
				if ((this.requestCount++, r > this.lastTxRateBucket)) {
					let n = this.requestCount / (r - this.lastTxRateBucket)
					;(this.measuredTxRate = this.getPrecise(
						n * this.smooth + this.measuredTxRate * (1 - this.smooth),
					)),
						(this.requestCount = 0),
						(this.lastTxRateBucket = r)
				}
			}
			getPrecise(t) {
				return parseFloat(t.toFixed(8))
			}
		}
	rn(kP, 'DefaultRateLimiter')
	var IP = kP,
		Hc = 100,
		gv = 20 * 1e3,
		TP = 500,
		pv = 500,
		BP = 5,
		NP = 10,
		DP = 1,
		O9 = 'amz-sdk-invocation-id',
		R9 = 'amz-sdk-request',
		k9 = rn(() => {
			let e = Hc
			return {
				computeNextBackoffDelay: rn(
					(n) => Math.floor(Math.min(gv, Math.random() * 2 ** n * e)),
					'computeNextBackoffDelay',
				),
				setDelayBase: rn((n) => {
					e = n
				}, 'setDelayBase'),
			}
		}, 'getDefaultRetryBackoffStrategy'),
		AP = rn(
			({ retryDelay: e, retryCount: t, retryCost: r }) => ({
				getRetryCount: rn(() => t, 'getRetryCount'),
				getRetryDelay: rn(() => Math.min(gv, e), 'getRetryDelay'),
				getRetryCost: rn(() => r, 'getRetryCost'),
			}),
			'createDefaultRetryToken',
		),
		LP = class {
			constructor(t) {
				;(this.maxAttempts = t),
					(this.mode = 'standard'),
					(this.capacity = pv),
					(this.retryBackoffStrategy = k9()),
					(this.maxAttemptsProvider =
						typeof t == 'function' ? t : async () => t)
			}
			async acquireInitialRetryToken(t) {
				return AP({ retryDelay: Hc, retryCount: 0 })
			}
			async refreshRetryTokenForRetry(t, r) {
				let n = await this.getMaxAttempts()
				if (this.shouldRetry(t, r, n)) {
					let i = r.errorType
					this.retryBackoffStrategy.setDelayBase(i === 'THROTTLING' ? TP : Hc)
					let o = this.retryBackoffStrategy.computeNextBackoffDelay(
							t.getRetryCount(),
						),
						s = r.retryAfterHint
							? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, o)
							: o,
						c = this.getCapacityCost(i)
					return (
						(this.capacity -= c),
						AP({
							retryDelay: s,
							retryCount: t.getRetryCount() + 1,
							retryCost: c,
						})
					)
				}
				throw new Error('No retry token available')
			}
			recordSuccess(t) {
				this.capacity = Math.max(pv, this.capacity + (t.getRetryCost() ?? DP))
			}
			getCapacity() {
				return this.capacity
			}
			async getMaxAttempts() {
				try {
					return await this.maxAttemptsProvider()
				} catch {
					return (
						console.warn(
							`Max attempts provider could not resolve. Using default of ${fv}`,
						),
						fv
					)
				}
			}
			shouldRetry(t, r, n) {
				return (
					t.getRetryCount() + 1 < n &&
					this.capacity >= this.getCapacityCost(r.errorType) &&
					this.isRetryableError(r.errorType)
				)
			}
			getCapacityCost(t) {
				return t === 'TRANSIENT' ? NP : BP
			}
			isRetryableError(t) {
				return t === 'THROTTLING' || t === 'TRANSIENT'
			}
		}
	rn(LP, 'StandardRetryStrategy')
	var vv = LP,
		FP = class {
			constructor(t, r) {
				;(this.maxAttemptsProvider = t), (this.mode = 'adaptive')
				let { rateLimiter: n } = r ?? {}
				;(this.rateLimiter = n ?? new IP()),
					(this.standardRetryStrategy = new vv(t))
			}
			async acquireInitialRetryToken(t) {
				return (
					await this.rateLimiter.getSendToken(),
					this.standardRetryStrategy.acquireInitialRetryToken(t)
				)
			}
			async refreshRetryTokenForRetry(t, r) {
				return (
					this.rateLimiter.updateClientSendingRate(r),
					this.standardRetryStrategy.refreshRetryTokenForRetry(t, r)
				)
			}
			recordSuccess(t) {
				this.rateLimiter.updateClientSendingRate({}),
					this.standardRetryStrategy.recordSuccess(t)
			}
		}
	rn(FP, 'AdaptiveRetryStrategy')
	var I9 = FP,
		MP = class extends vv {
			constructor(t, r = Hc) {
				super(typeof t == 'function' ? t : async () => t),
					typeof r == 'number'
						? (this.computeNextBackoffDelay = () => r)
						: (this.computeNextBackoffDelay = r)
			}
			async refreshRetryTokenForRetry(t, r) {
				let n = await super.refreshRetryTokenForRetry(t, r)
				return (
					(n.getRetryDelay = () =>
						this.computeNextBackoffDelay(n.getRetryCount())),
					n
				)
			}
		}
	rn(MP, 'ConfiguredRetryStrategy')
	var T9 = MP
})
var jP = E((fu) => {
	'use strict'
	Object.defineProperty(fu, '__esModule', { value: !0 })
	fu.isStreamingPayload = void 0
	var B9 = require('stream'),
		N9 = (e) =>
			e?.body instanceof B9.Readable ||
			(typeof ReadableStream < 'u' && e?.body instanceof ReadableStream)
	fu.isStreamingPayload = N9
})
var bn = E((bRe, nA) => {
	var pu = Object.defineProperty,
		D9 = Object.getOwnPropertyDescriptor,
		L9 = Object.getOwnPropertyNames,
		F9 = Object.prototype.hasOwnProperty,
		_t = (e, t) => pu(e, 'name', { value: t, configurable: !0 }),
		M9 = (e, t) => {
			for (var r in t) pu(e, r, { get: t[r], enumerable: !0 })
		},
		q9 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of L9(t))
					!F9.call(e, i) &&
						i !== r &&
						pu(e, i, {
							get: () => t[i],
							enumerable: !(n = D9(t, i)) || n.enumerable,
						})
			return e
		},
		j9 = (e) => q9(pu({}, '__esModule', { value: !0 }), e),
		GP = {}
	M9(GP, {
		AdaptiveRetryStrategy: () => z9,
		CONFIG_MAX_ATTEMPTS: () => _v,
		CONFIG_RETRY_MODE: () => JP,
		ENV_MAX_ATTEMPTS: () => hv,
		ENV_RETRY_MODE: () => YP,
		NODE_MAX_ATTEMPT_CONFIG_OPTIONS: () => H9,
		NODE_RETRY_MODE_CONFIG_OPTIONS: () => V9,
		StandardRetryStrategy: () => WP,
		defaultDelayDecider: () => HP,
		defaultRetryDecider: () => $P,
		getOmitRetryHeadersPlugin: () => K9,
		getRetryAfterHint: () => rA,
		getRetryPlugin: () => Z9,
		omitRetryHeadersMiddleware: () => QP,
		omitRetryHeadersMiddlewareOptions: () => ZP,
		resolveRetryConfig: () => $9,
		retryMiddleware: () => eA,
		retryMiddlewareOptions: () => tA,
	})
	nA.exports = j9(GP)
	var ks = Xe(),
		zP = (EP(), ve(CP)),
		at = Rs(),
		U9 = _t((e, t) => {
			let r = e,
				n = t?.noRetryIncrement ?? at.NO_RETRY_INCREMENT,
				i = t?.retryCost ?? at.RETRY_COST,
				o = t?.timeoutRetryCost ?? at.TIMEOUT_RETRY_COST,
				s = e,
				c = _t((f) => (f.name === 'TimeoutError' ? o : i), 'getCapacityAmount'),
				l = _t((f) => c(f) <= s, 'hasRetryTokens')
			return Object.freeze({
				hasRetryTokens: l,
				retrieveRetryTokens: _t((f) => {
					if (!l(f)) throw new Error('No retry token available')
					let p = c(f)
					return (s -= p), p
				}, 'retrieveRetryTokens'),
				releaseRetryTokens: _t((f) => {
					;(s += f ?? n), (s = Math.min(s, r))
				}, 'releaseRetryTokens'),
			})
		}, 'getDefaultRetryQuota'),
		HP = _t(
			(e, t) =>
				Math.floor(
					Math.min(at.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** t * e),
				),
			'defaultDelayDecider',
		),
		yi = mv(),
		$P = _t(
			(e) =>
				e
					? (0, yi.isRetryableByTrait)(e) ||
						(0, yi.isClockSkewError)(e) ||
						(0, yi.isThrottlingError)(e) ||
						(0, yi.isTransientError)(e)
					: !1,
			'defaultRetryDecider',
		),
		VP = _t(
			(e) =>
				e instanceof Error
					? e
					: e instanceof Object
						? Object.assign(new Error(), e)
						: typeof e == 'string'
							? new Error(e)
							: new Error(`AWS SDK error wrapper for ${e}`),
			'asSdkError',
		),
		KP = class {
			constructor(t, r) {
				;(this.maxAttemptsProvider = t),
					(this.mode = at.RETRY_MODES.STANDARD),
					(this.retryDecider = r?.retryDecider ?? $P),
					(this.delayDecider = r?.delayDecider ?? HP),
					(this.retryQuota = r?.retryQuota ?? U9(at.INITIAL_RETRY_TOKENS))
			}
			shouldRetry(t, r, n) {
				return (
					r < n && this.retryDecider(t) && this.retryQuota.hasRetryTokens(t)
				)
			}
			async getMaxAttempts() {
				let t
				try {
					t = await this.maxAttemptsProvider()
				} catch {
					t = at.DEFAULT_MAX_ATTEMPTS
				}
				return t
			}
			async retry(t, r, n) {
				let i,
					o = 0,
					s = 0,
					c = await this.getMaxAttempts(),
					{ request: l } = r
				for (
					ks.HttpRequest.isInstance(l) &&
					(l.headers[at.INVOCATION_ID_HEADER] = (0, zP.v4)());
					;
				)
					try {
						ks.HttpRequest.isInstance(l) &&
							(l.headers[at.REQUEST_HEADER] = `attempt=${o + 1}; max=${c}`),
							n?.beforeRequest && (await n.beforeRequest())
						let { response: u, output: m } = await t(r)
						return (
							n?.afterRequest && n.afterRequest(u),
							this.retryQuota.releaseRetryTokens(i),
							(m.$metadata.attempts = o + 1),
							(m.$metadata.totalRetryDelay = s),
							{ response: u, output: m }
						)
					} catch (u) {
						let m = VP(u)
						if ((o++, this.shouldRetry(m, o, c))) {
							i = this.retryQuota.retrieveRetryTokens(m)
							let f = this.delayDecider(
									(0, yi.isThrottlingError)(m)
										? at.THROTTLING_RETRY_DELAY_BASE
										: at.DEFAULT_RETRY_DELAY_BASE,
									o,
								),
								p = G9(m.$response),
								g = Math.max(p || 0, f)
							;(s += g), await new Promise((v) => setTimeout(v, g))
							continue
						}
						throw (
							(m.$metadata || (m.$metadata = {}),
							(m.$metadata.attempts = o),
							(m.$metadata.totalRetryDelay = s),
							m)
						)
					}
			}
		}
	_t(KP, 'StandardRetryStrategy')
	var WP = KP,
		G9 = _t((e) => {
			if (!ks.HttpResponse.isInstance(e)) return
			let t = Object.keys(e.headers).find(
				(o) => o.toLowerCase() === 'retry-after',
			)
			if (!t) return
			let r = e.headers[t],
				n = Number(r)
			return Number.isNaN(n) ? new Date(r).getTime() - Date.now() : n * 1e3
		}, 'getDelayFromRetryAfterHeader'),
		XP = class extends WP {
			constructor(t, r) {
				let { rateLimiter: n, ...i } = r ?? {}
				super(t, i),
					(this.rateLimiter = n ?? new at.DefaultRateLimiter()),
					(this.mode = at.RETRY_MODES.ADAPTIVE)
			}
			async retry(t, r) {
				return super.retry(t, r, {
					beforeRequest: async () => this.rateLimiter.getSendToken(),
					afterRequest: (n) => {
						this.rateLimiter.updateClientSendingRate(n)
					},
				})
			}
		}
	_t(XP, 'AdaptiveRetryStrategy')
	var z9 = XP,
		UP = Tr(),
		hv = 'AWS_MAX_ATTEMPTS',
		_v = 'max_attempts',
		H9 = {
			environmentVariableSelector: (e) => {
				let t = e[hv]
				if (!t) return
				let r = parseInt(t)
				if (Number.isNaN(r))
					throw new Error(
						`Environment variable ${hv} mast be a number, got "${t}"`,
					)
				return r
			},
			configFileSelector: (e) => {
				let t = e[_v]
				if (!t) return
				let r = parseInt(t)
				if (Number.isNaN(r))
					throw new Error(
						`Shared config file entry ${_v} mast be a number, got "${t}"`,
					)
				return r
			},
			default: at.DEFAULT_MAX_ATTEMPTS,
		},
		$9 = _t((e) => {
			let { retryStrategy: t } = e,
				r = (0, UP.normalizeProvider)(e.maxAttempts ?? at.DEFAULT_MAX_ATTEMPTS)
			return {
				...e,
				maxAttempts: r,
				retryStrategy: async () =>
					t ||
					((await (0, UP.normalizeProvider)(e.retryMode)()) ===
					at.RETRY_MODES.ADAPTIVE
						? new at.AdaptiveRetryStrategy(r)
						: new at.StandardRetryStrategy(r)),
			}
		}, 'resolveRetryConfig'),
		YP = 'AWS_RETRY_MODE',
		JP = 'retry_mode',
		V9 = {
			environmentVariableSelector: (e) => e[YP],
			configFileSelector: (e) => e[JP],
			default: at.DEFAULT_RETRY_MODE,
		},
		QP = _t(
			() => (e) => async (t) => {
				let { request: r } = t
				return (
					ks.HttpRequest.isInstance(r) &&
						(delete r.headers[at.INVOCATION_ID_HEADER],
						delete r.headers[at.REQUEST_HEADER]),
					e(t)
				)
			},
			'omitRetryHeadersMiddleware',
		),
		ZP = {
			name: 'omitRetryHeadersMiddleware',
			tags: ['RETRY', 'HEADERS', 'OMIT_RETRY_HEADERS'],
			relation: 'before',
			toMiddleware: 'awsAuthMiddleware',
			override: !0,
		},
		K9 = _t(
			(e) => ({
				applyToStack: (t) => {
					t.addRelativeTo(QP(), ZP)
				},
			}),
			'getOmitRetryHeadersPlugin',
		),
		W9 = ze(),
		X9 = jP(),
		eA = _t(
			(e) => (t, r) => async (n) => {
				var i
				let o = await e.retryStrategy(),
					s = await e.maxAttempts()
				if (Y9(o)) {
					o = o
					let c = await o.acquireInitialRetryToken(r.partition_id),
						l = new Error(),
						u = 0,
						m = 0,
						{ request: f } = n,
						p = ks.HttpRequest.isInstance(f)
					for (p && (f.headers[at.INVOCATION_ID_HEADER] = (0, zP.v4)()); ; )
						try {
							p && (f.headers[at.REQUEST_HEADER] = `attempt=${u + 1}; max=${s}`)
							let { response: g, output: v } = await t(n)
							return (
								o.recordSuccess(c),
								(v.$metadata.attempts = u + 1),
								(v.$metadata.totalRetryDelay = m),
								{ response: g, output: v }
							)
						} catch (g) {
							let v = J9(g)
							if (((l = VP(g)), p && (0, X9.isStreamingPayload)(f)))
								throw (
									((i =
										r.logger instanceof W9.NoOpLogger ? console : r.logger) ==
										null ||
										i.warn(
											'An error was encountered in a non-retryable streaming request.',
										),
									l)
								)
							try {
								c = await o.refreshRetryTokenForRetry(c, v)
							} catch {
								throw (
									(l.$metadata || (l.$metadata = {}),
									(l.$metadata.attempts = u + 1),
									(l.$metadata.totalRetryDelay = m),
									l)
								)
							}
							u = c.getRetryCount()
							let _ = c.getRetryDelay()
							;(m += _), await new Promise((y) => setTimeout(y, _))
						}
				} else
					return (
						(o = o),
						o?.mode &&
							(r.userAgent = [
								...(r.userAgent || []),
								['cfg/retry-mode', o.mode],
							]),
						o.retry(t, n)
					)
			},
			'retryMiddleware',
		),
		Y9 = _t(
			(e) =>
				typeof e.acquireInitialRetryToken < 'u' &&
				typeof e.refreshRetryTokenForRetry < 'u' &&
				typeof e.recordSuccess < 'u',
			'isRetryStrategyV2',
		),
		J9 = _t((e) => {
			let t = { error: e, errorType: Q9(e) },
				r = rA(e.$response)
			return r && (t.retryAfterHint = r), t
		}, 'getRetryErrorInfo'),
		Q9 = _t(
			(e) =>
				(0, yi.isThrottlingError)(e)
					? 'THROTTLING'
					: (0, yi.isTransientError)(e)
						? 'TRANSIENT'
						: (0, yi.isServerError)(e)
							? 'SERVER_ERROR'
							: 'CLIENT_ERROR',
			'getRetryErrorType',
		),
		tA = {
			name: 'retryMiddleware',
			tags: ['RETRY'],
			step: 'finalizeRequest',
			priority: 'high',
			override: !0,
		},
		Z9 = _t(
			(e) => ({
				applyToStack: (t) => {
					t.add(eA(e), tA)
				},
			}),
			'getRetryPlugin',
		),
		rA = _t((e) => {
			if (!ks.HttpResponse.isInstance(e)) return
			let t = Object.keys(e.headers).find(
				(o) => o.toLowerCase() === 'retry-after',
			)
			if (!t) return
			let r = e.headers[t],
				n = Number(r)
			return Number.isNaN(n) ? new Date(r) : new Date(n * 1e3)
		}, 'getRetryAfterHint')
})
var iA,
	oA,
	e7,
	sA = oe(() => {
		iA = Oe(bn())
		iv()
		;(oA = {
			step: 'finalizeRequest',
			tags: ['HTTP_SIGNING'],
			name: 'httpSigningMiddleware',
			aliases: ['apiKeyMiddleware', 'tokenMiddleware', 'awsAuthMiddleware'],
			override: !0,
			relation: 'after',
			toMiddleware: iA.retryMiddlewareOptions.name,
		}),
			(e7 = (e) => ({
				applyToStack: (t) => {
					t.addRelativeTo(nv(e), oA)
				},
			}))
	})
var aA = oe(() => {
	iv()
	sA()
})
var yv,
	cA = oe(() => {
		yv = class {
			constructor(t) {
				this.authSchemes = new Map()
				for (let [r, n] of Object.entries(t))
					n !== void 0 && this.authSchemes.set(r, n)
			}
			getIdentityProvider(t) {
				return this.authSchemes.get(t)
			}
		}
	})
var lA,
	Sv,
	Cv,
	dA = oe(() => {
		;(lA = Oe(Xe())),
			(Sv = Oe(en())),
			(Cv = class {
				async sign(t, r, n) {
					if (!n)
						throw new Error(
							'request could not be signed with `apiKey` since the `name` and `in` signer properties are missing',
						)
					if (!n.name)
						throw new Error(
							'request could not be signed with `apiKey` since the `name` signer property is missing',
						)
					if (!n.in)
						throw new Error(
							'request could not be signed with `apiKey` since the `in` signer property is missing',
						)
					if (!r.apiKey)
						throw new Error(
							'request could not be signed with `apiKey` since the `apiKey` is not defined',
						)
					let i = lA.HttpRequest.clone(t)
					if (n.in === Sv.HttpApiKeyAuthLocation.QUERY)
						i.query[n.name] = r.apiKey
					else if (n.in === Sv.HttpApiKeyAuthLocation.HEADER)
						i.headers[n.name] = n.scheme ? `${n.scheme} ${r.apiKey}` : r.apiKey
					else
						throw new Error(
							'request can only be signed with `apiKey` locations `query` or `header`, but found: `' +
								n.in +
								'`',
						)
					return i
				}
			})
	})
var uA,
	Ev,
	mA = oe(() => {
		;(uA = Oe(Xe())),
			(Ev = class {
				async sign(t, r, n) {
					let i = uA.HttpRequest.clone(t)
					if (!r.token)
						throw new Error(
							'request could not be signed with `token` since the `token` is not defined',
						)
					return (i.headers.Authorization = `Bearer ${r.token}`), i
				}
			})
	})
var bv,
	fA = oe(() => {
		bv = class {
			async sign(t, r, n) {
				return t
			}
		}
	})
var pA = oe(() => {
	dA()
	mA()
	fA()
})
var gA,
	t7,
	wv,
	gu,
	xv,
	vA = oe(() => {
		;(gA = (e) => (t) => gu(t) && t.expiration.getTime() - Date.now() < e),
			(t7 = 3e5),
			(wv = gA(3e5)),
			(gu = (e) => e.expiration !== void 0),
			(xv = (e, t, r) => {
				if (e === void 0) return
				let n = typeof e != 'function' ? async () => Promise.resolve(e) : e,
					i,
					o,
					s,
					c = !1,
					l = async (u) => {
						o || (o = n(u))
						try {
							;(i = await o), (s = !0), (c = !1)
						} finally {
							o = void 0
						}
						return i
					}
				return t === void 0
					? async (u) => ((!s || u?.forceRefresh) && (i = await l(u)), i)
					: async (u) => (
							(!s || u?.forceRefresh) && (i = await l(u)),
							c ? i : r(i) ? (t(i) && (await l(u)), i) : ((c = !0), i)
						)
			})
	})
var hA = oe(() => {
	cA()
	pA()
	vA()
})
var Pv,
	r7,
	_A = oe(() => {
		;(Pv = Oe(en())),
			(r7 = (e) => e[Pv.SMITHY_CONTEXT_KEY] || (e[Pv.SMITHY_CONTEXT_KEY] = {}))
	})
var Si,
	yA = oe(() => {
		Si = (e) => {
			if (typeof e == 'function') return e
			let t = Promise.resolve(e)
			return () => t
		}
	})
function n7(e, t) {
	return new vu(e, t)
}
var SA,
	CA,
	vu,
	EA = oe(() => {
		;(SA = Oe(Xe())), (CA = Oe(ze()))
		vu = class {
			constructor(t, r) {
				;(this.input = t),
					(this.context = r),
					(this.query = {}),
					(this.method = ''),
					(this.headers = {}),
					(this.path = ''),
					(this.body = null),
					(this.hostname = ''),
					(this.resolvePathStack = [])
			}
			async build() {
				let {
					hostname: t,
					protocol: r = 'https',
					port: n,
					path: i,
				} = await this.context.endpoint()
				this.path = i
				for (let o of this.resolvePathStack) o(this.path)
				return new SA.HttpRequest({
					protocol: r,
					hostname: this.hostname || t,
					port: n,
					method: this.method,
					path: this.path,
					query: this.query,
					body: this.body,
					headers: this.headers,
				})
			}
			hn(t) {
				return (this.hostname = t), this
			}
			bp(t) {
				return (
					this.resolvePathStack.push((r) => {
						this.path = `${r?.endsWith('/') ? r.slice(0, -1) : r || ''}` + t
					}),
					this
				)
			}
			p(t, r, n, i) {
				return (
					this.resolvePathStack.push((o) => {
						this.path = (0, CA.resolvedPath)(o, this.input, t, r, n, i)
					}),
					this
				)
			}
			h(t) {
				return (this.headers = t), this
			}
			q(t) {
				return (this.query = t), this
			}
			b(t) {
				return (this.body = t), this
			}
			m(t) {
				return (this.method = t), this
			}
		}
	})
function bA(e, t, r, n, i) {
	return async function* (s, c, ...l) {
		let u = s.startingToken || void 0,
			m = !0,
			f
		for (; m; ) {
			if (((c[r] = u), i && (c[i] = c[i] ?? s.pageSize), s.client instanceof e))
				f = await i7(t, s.client, c, ...l)
			else throw new Error(`Invalid client, expected instance of ${e.name}`)
			yield f
			let p = u
			;(u = o7(f, n)), (m = !!(u && (!s.stopOnSameToken || u !== p)))
		}
		return void 0
	}
}
var i7,
	o7,
	wA = oe(() => {
		i7 = async (e, t, r, ...n) => await t.send(new e(r), ...n)
		o7 = (e, t) => {
			let r = e,
				n = t.split('.')
			for (let i of n) {
				if (!r || typeof r != 'object') return
				r = r[i]
			}
			return r
		}
	})
var ir = {}
Sc(ir, {
	DefaultIdentityProviderConfig: () => yv,
	EXPIRATION_MS: () => t7,
	HttpApiKeyAuthSigner: () => Cv,
	HttpBearerAuthSigner: () => Ev,
	NoAuthSigner: () => bv,
	RequestBuilder: () => vu,
	createIsIdentityExpiredFunction: () => gA,
	createPaginator: () => bA,
	doesIdentityRequireRefresh: () => gu,
	getHttpAuthSchemeEndpointRuleSetPlugin: () => GX,
	getHttpAuthSchemePlugin: () => zX,
	getHttpSigningPlugin: () => e7,
	getSmithyContext: () => r7,
	httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => Gx,
	httpAuthSchemeMiddleware: () => Lc,
	httpAuthSchemeMiddlewareOptions: () => $x,
	httpSigningMiddleware: () => nv,
	httpSigningMiddlewareOptions: () => oA,
	isIdentityExpired: () => wv,
	memoizeIdentityProvider: () => xv,
	normalizeProvider: () => Si,
	requestBuilder: () => n7,
})
var Ut = oe(() => {
	Kx()
	aA()
	hA()
	_A()
	yA()
	EA()
	wA()
})
var Ov = E((ZRe, PA) => {
	var hu = Object.defineProperty,
		s7 = Object.getOwnPropertyDescriptor,
		a7 = Object.getOwnPropertyNames,
		c7 = Object.prototype.hasOwnProperty,
		Av = (e, t) => hu(e, 'name', { value: t, configurable: !0 }),
		l7 = (e, t) => {
			for (var r in t) hu(e, r, { get: t[r], enumerable: !0 })
		},
		d7 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of a7(t))
					!c7.call(e, i) &&
						i !== r &&
						hu(e, i, {
							get: () => t[i],
							enumerable: !(n = s7(t, i)) || n.enumerable,
						})
			return e
		},
		u7 = (e) => d7(hu({}, '__esModule', { value: !0 }), e),
		xA = {}
	l7(xA, { build: () => p7, parse: () => f7, validate: () => m7 })
	PA.exports = u7(xA)
	var m7 = Av(
			(e) =>
				typeof e == 'string' &&
				e.indexOf('arn:') === 0 &&
				e.split(':').length >= 6,
			'validate',
		),
		f7 = Av((e) => {
			let t = e.split(':')
			if (t.length < 6 || t[0] !== 'arn') throw new Error('Malformed ARN')
			let [, r, n, i, o, ...s] = t
			return {
				partition: r,
				service: n,
				region: i,
				accountId: o,
				resource: s.join(':'),
			}
		}, 'parse'),
		p7 = Av((e) => {
			let {
				partition: t = 'aws',
				service: r,
				region: n,
				accountId: i,
				resource: o,
			} = e
			if ([r, n, i, o].some((s) => typeof s != 'string'))
				throw new Error('Input ARN object is invalid')
			return `arn:${t}:${r}:${n}:${i}:${o}`
		}, 'build')
})
var re = E((rke, YA) => {
	'use strict'
	var Su = Object.defineProperty,
		g7 = Object.getOwnPropertyDescriptor,
		v7 = Object.getOwnPropertyNames,
		h7 = Object.prototype.hasOwnProperty,
		Ne = (e, t) => Su(e, 'name', { value: t, configurable: !0 }),
		_7 = (e, t) => {
			for (var r in t) Su(e, r, { get: t[r], enumerable: !0 })
		},
		y7 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of v7(t))
					!h7.call(e, i) &&
						i !== r &&
						Su(e, i, {
							get: () => t[i],
							enumerable: !(n = g7(t, i)) || n.enumerable,
						})
			return e
		},
		S7 = (e) => y7(Su({}, '__esModule', { value: !0 }), e),
		OA = {}
	_7(OA, {
		NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS: () => I7,
		S3ExpressIdentityCache: () => FA,
		S3ExpressIdentityCacheEntry: () => yu,
		S3ExpressIdentityProviderImpl: () => jA,
		SignatureV4S3Express: () => T7,
		checkContentLengthHeader: () => Bv,
		checkContentLengthHeaderMiddlewareOptions: () => kA,
		getCheckContentLengthHeaderPlugin: () => E7,
		getRegionRedirectMiddlewarePlugin: () => b7,
		getS3ExpiresMiddlewarePlugin: () => w7,
		getS3ExpressHttpSigningPlugin: () => q7,
		getS3ExpressPlugin: () => B7,
		getThrow200ExceptionsPlugin: () => H7,
		getValidateBucketNamePlugin: () => K7,
		regionRedirectEndpointMiddleware: () => IA,
		regionRedirectEndpointMiddlewareOptions: () => TA,
		regionRedirectMiddleware: () => Nv,
		regionRedirectMiddlewareOptions: () => BA,
		resolveS3Config: () => j7,
		s3ExpiresMiddleware: () => NA,
		s3ExpiresMiddlewareOptions: () => DA,
		s3ExpressHttpSigningMiddleware: () => $A,
		s3ExpressHttpSigningMiddlewareOptions: () => M7,
		s3ExpressMiddleware: () => GA,
		s3ExpressMiddlewareOptions: () => zA,
		throw200ExceptionsMiddleware: () => VA,
		throw200ExceptionsMiddlewareOptions: () => KA,
		validateBucketNameMiddleware: () => Fv,
		validateBucketNameMiddlewareOptions: () => XA,
	})
	YA.exports = S7(OA)
	var $c = Xe(),
		RA = ze(),
		C7 = 'content-length'
	function Bv() {
		return (e, t) => async (r) => {
			var n
			let { request: i } = r
			if ($c.HttpRequest.isInstance(i) && !(C7 in i.headers)) {
				let o =
					'Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.'
				typeof ((n = t?.logger) == null ? void 0 : n.warn) == 'function' &&
				!(t.logger instanceof RA.NoOpLogger)
					? t.logger.warn(o)
					: console.warn(o)
			}
			return e({ ...r })
		}
	}
	Ne(Bv, 'checkContentLengthHeader')
	var kA = {
			step: 'finalizeRequest',
			tags: ['CHECK_CONTENT_LENGTH_HEADER'],
			name: 'getCheckContentLengthHeaderPlugin',
			override: !0,
		},
		E7 = Ne(
			(e) => ({
				applyToStack: (t) => {
					t.add(Bv(), kA)
				},
			}),
			'getCheckContentLengthHeaderPlugin',
		),
		IA = Ne(
			(e) => (t, r) => async (n) => {
				let i = await e.region(),
					o = e.region,
					s = Ne(() => {}, 'unlock')
				r.__s3RegionRedirect &&
					(Object.defineProperty(e, 'region', {
						writable: !1,
						value: async () => r.__s3RegionRedirect,
					}),
					(s = Ne(
						() =>
							Object.defineProperty(e, 'region', { writable: !0, value: o }),
						'unlock',
					)))
				try {
					let c = await t(n)
					if (r.__s3RegionRedirect) {
						s()
						let l = await e.region()
						if (i !== l)
							throw new Error(
								'Region was not restored following S3 region redirect.',
							)
					}
					return c
				} catch (c) {
					throw (s(), c)
				}
			},
			'regionRedirectEndpointMiddleware',
		),
		TA = {
			tags: ['REGION_REDIRECT', 'S3'],
			name: 'regionRedirectEndpointMiddleware',
			override: !0,
			relation: 'before',
			toMiddleware: 'endpointV2Middleware',
		}
	function Nv(e) {
		return (t, r) => async (n) => {
			var i, o
			try {
				return await t(n)
			} catch (s) {
				if (
					e.followRegionRedirects &&
					((i = s?.$metadata) == null ? void 0 : i.httpStatusCode) === 301
				) {
					try {
						let c = s.$response.headers['x-amz-bucket-region']
						;(o = r.logger) == null ||
							o.debug(`Redirecting from ${await e.region()} to ${c}`),
							(r.__s3RegionRedirect = c)
					} catch (c) {
						throw new Error('Region redirect failed: ' + c)
					}
					return t(n)
				} else throw s
			}
		}
	}
	Ne(Nv, 'regionRedirectMiddleware')
	var BA = {
			step: 'initialize',
			tags: ['REGION_REDIRECT', 'S3'],
			name: 'regionRedirectMiddleware',
			override: !0,
		},
		b7 = Ne(
			(e) => ({
				applyToStack: (t) => {
					t.add(Nv(e), BA), t.addRelativeTo(IA(e), TA)
				},
			}),
			'getRegionRedirectMiddlewarePlugin',
		),
		NA = Ne(
			(e) => (t, r) => async (n) => {
				var i
				let o = await t(n),
					{ response: s } = o
				if ($c.HttpResponse.isInstance(s) && s.headers.expires) {
					s.headers.expiresstring = s.headers.expires
					try {
						;(0, RA.parseRfc7231DateTime)(s.headers.expires)
					} catch (c) {
						;(i = r.logger) == null ||
							i.warn(
								`AWS SDK Warning for ${r.clientName}::${r.commandName} response parsing (${s.headers.expires}): ${c}`,
							),
							delete s.headers.expires
					}
				}
				return o
			},
			's3ExpiresMiddleware',
		),
		DA = {
			tags: ['S3'],
			name: 's3ExpiresMiddleware',
			override: !0,
			relation: 'after',
			toMiddleware: 'deserializerMiddleware',
		},
		w7 = Ne(
			(e) => ({
				applyToStack: (t) => {
					t.addRelativeTo(NA(e), DA)
				},
			}),
			'getS3ExpiresMiddlewarePlugin',
		),
		Dv = class LA {
			constructor(t = {}) {
				;(this.data = t), (this.lastPurgeTime = Date.now())
			}
			get(t) {
				let r = this.data[t]
				if (r) return r
			}
			set(t, r) {
				return (this.data[t] = r), r
			}
			delete(t) {
				delete this.data[t]
			}
			async purgeExpired() {
				let t = Date.now()
				if (!(this.lastPurgeTime + LA.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > t))
					for (let r in this.data) {
						let n = this.data[r]
						if (!n.isRefreshing) {
							let i = await n.identity
							i.expiration && i.expiration.getTime() < t && delete this.data[r]
						}
					}
			}
		}
	Ne(Dv, 'S3ExpressIdentityCache')
	Dv.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4
	var FA = Dv,
		MA = class {
			constructor(t, r = !1, n = Date.now()) {
				;(this._identity = t), (this.isRefreshing = r), (this.accessed = n)
			}
			get identity() {
				return (this.accessed = Date.now()), this._identity
			}
		}
	Ne(MA, 'S3ExpressIdentityCacheEntry')
	var yu = MA,
		Lv = class qA {
			constructor(t, r = new FA()) {
				;(this.createSessionFn = t), (this.cache = r)
			}
			async getS3ExpressIdentity(t, r) {
				let n = r.Bucket,
					{ cache: i } = this,
					o = i.get(n)
				return o
					? o.identity.then((s) => {
							var c, l
							return (((c = s.expiration) == null ? void 0 : c.getTime()) ??
								0) < Date.now()
								? i.set(n, new yu(this.getIdentity(n))).identity
								: ((((l = s.expiration) == null ? void 0 : l.getTime()) ?? 0) <
										Date.now() + qA.REFRESH_WINDOW_MS &&
										!o.isRefreshing &&
										((o.isRefreshing = !0),
										this.getIdentity(n).then((f) => {
											i.set(n, new yu(Promise.resolve(f)))
										})),
									s)
						})
					: i.set(n, new yu(this.getIdentity(n))).identity
			}
			async getIdentity(t) {
				var r, n
				await this.cache.purgeExpired().catch((s) => {
					console.warn(
						`Error while clearing expired entries in S3ExpressIdentityCache: 
` + s,
					)
				})
				let i = await this.createSessionFn(t)
				if (
					!((r = i.Credentials) != null && r.AccessKeyId) ||
					!((n = i.Credentials) != null && n.SecretAccessKey)
				)
					throw new Error(
						's3#createSession response credential missing AccessKeyId or SecretAccessKey.',
					)
				return {
					accessKeyId: i.Credentials.AccessKeyId,
					secretAccessKey: i.Credentials.SecretAccessKey,
					sessionToken: i.Credentials.SessionToken,
					expiration: i.Credentials.Expiration
						? new Date(i.Credentials.Expiration)
						: void 0,
				}
			}
		}
	Ne(Lv, 'S3ExpressIdentityProviderImpl')
	Lv.REFRESH_WINDOW_MS = 6e4
	var jA = Lv,
		x7 = Vg(),
		_u = zd(),
		P7 = 'Directory',
		A7 = 'S3Express',
		O7 = 'sigv4-s3express',
		Rv = 'X-Amz-S3session-Token',
		kv = Rv.toLowerCase(),
		R7 = 'AWS_S3_DISABLE_EXPRESS_SESSION_AUTH',
		k7 = 's3_disable_express_session_auth',
		I7 = {
			environmentVariableSelector: (e) =>
				(0, _u.booleanSelector)(e, R7, _u.SelectorType.ENV),
			configFileSelector: (e) =>
				(0, _u.booleanSelector)(e, k7, _u.SelectorType.CONFIG),
			default: !1,
		},
		UA = class extends x7.SignatureV4 {
			async signWithCredentials(t, r, n) {
				let i = Iv(r)
				t.headers[kv] = r.sessionToken
				let o = this
				return Tv(o, i), o.signRequest(t, n ?? {})
			}
			async presignWithCredentials(t, r, n) {
				let i = Iv(r)
				return (
					delete t.headers[kv],
					(t.headers[Rv] = r.sessionToken),
					(t.query = t.query ?? {}),
					(t.query[Rv] = r.sessionToken),
					Tv(this, i),
					this.presign(t, n)
				)
			}
		}
	Ne(UA, 'SignatureV4S3Express')
	var T7 = UA
	function Iv(e) {
		return {
			accessKeyId: e.accessKeyId,
			secretAccessKey: e.secretAccessKey,
			expiration: e.expiration,
		}
	}
	Ne(Iv, 'getCredentialsWithoutSessionToken')
	function Tv(e, t) {
		let r = setTimeout(() => {
				throw new Error(
					'SignatureV4S3Express credential override was created but not called.',
				)
			}, 10),
			n = e.credentialProvider,
			i = Ne(
				() => (clearTimeout(r), (e.credentialProvider = n), Promise.resolve(t)),
				'overrideCredentialsProviderOnce',
			)
		e.credentialProvider = i
	}
	Ne(Tv, 'setSingleOverride')
	var GA = Ne(
			(e) => (t, r) => async (n) => {
				var i, o, s, c, l
				if (r.endpointV2) {
					let u = r.endpointV2,
						m =
							((s =
								(o = (i = u.properties) == null ? void 0 : i.authSchemes) ==
								null
									? void 0
									: o[0]) == null
								? void 0
								: s.name) === O7
					if (
						((((c = u.properties) == null ? void 0 : c.backend) === A7 ||
							((l = u.properties) == null ? void 0 : l.bucketType) === P7) &&
							(r.isS3ExpressBucket = !0),
						m)
					) {
						let p = n.input.Bucket
						if (p) {
							let g = await e.s3ExpressIdentityProvider.getS3ExpressIdentity(
								await e.credentials(),
								{ Bucket: p },
							)
							;(r.s3ExpressIdentity = g),
								$c.HttpRequest.isInstance(n.request) &&
									g.sessionToken &&
									(n.request.headers[kv] = g.sessionToken)
						}
					}
				}
				return t(n)
			},
			's3ExpressMiddleware',
		),
		zA = {
			name: 's3ExpressMiddleware',
			step: 'build',
			tags: ['S3', 'S3_EXPRESS'],
			override: !0,
		},
		B7 = Ne(
			(e) => ({
				applyToStack: (t) => {
					t.add(GA(e), zA)
				},
			}),
			'getS3ExpressPlugin',
		),
		HA = (Ut(), ve(ir)),
		N7 = Tr(),
		D7 = Ne(async (e, t, r, n) => {
			let i = await n.signWithCredentials(r, e, {})
			if (
				i.headers['X-Amz-Security-Token'] ||
				i.headers['x-amz-security-token']
			)
				throw new Error(
					'X-Amz-Security-Token must not be set for s3-express requests.',
				)
			return i
		}, 'signS3Express'),
		L7 = Ne(
			(e) => (t) => {
				throw t
			},
			'defaultErrorHandler',
		),
		F7 = Ne((e, t) => {}, 'defaultSuccessHandler'),
		M7 = HA.httpSigningMiddlewareOptions,
		$A = Ne(
			(e) => (t, r) => async (n) => {
				if (!$c.HttpRequest.isInstance(n.request)) return t(n)
				let o = (0, N7.getSmithyContext)(r).selectedHttpAuthScheme
				if (!o)
					throw new Error(
						'No HttpAuthScheme was selected: unable to sign request',
					)
				let {
						httpAuthOption: { signingProperties: s = {} },
						identity: c,
						signer: l,
					} = o,
					u
				r.s3ExpressIdentity
					? (u = await D7(r.s3ExpressIdentity, s, n.request, await e.signer()))
					: (u = await l.sign(n.request, c, s))
				let m = await t({ ...n, request: u }).catch((l.errorHandler || L7)(s))
				return (l.successHandler || F7)(m.response, s), m
			},
			's3ExpressHttpSigningMiddleware',
		),
		q7 = Ne(
			(e) => ({
				applyToStack: (t) => {
					t.addRelativeTo($A(e), HA.httpSigningMiddlewareOptions)
				},
			}),
			'getS3ExpressHttpSigningPlugin',
		),
		j7 = Ne((e, { session: t }) => {
			let [r, n] = t
			return {
				...e,
				forcePathStyle: e.forcePathStyle ?? !1,
				useAccelerateEndpoint: e.useAccelerateEndpoint ?? !1,
				disableMultiregionAccessPoints: e.disableMultiregionAccessPoints ?? !1,
				followRegionRedirects: e.followRegionRedirects ?? !1,
				s3ExpressIdentityProvider:
					e.s3ExpressIdentityProvider ??
					new jA(async (i) =>
						r().send(new n({ Bucket: i, SessionMode: 'ReadWrite' })),
					),
				bucketEndpoint: e.bucketEndpoint ?? !1,
			}
		}, 'resolveS3Config'),
		AA = Rc(),
		U7 = {
			CopyObjectCommand: !0,
			UploadPartCopyCommand: !0,
			CompleteMultipartUploadCommand: !0,
		},
		G7 = 3e3,
		VA = Ne(
			(e) => (t, r) => async (n) => {
				let i = await t(n),
					{ response: o } = i
				if (!$c.HttpResponse.isInstance(o)) return i
				let { statusCode: s, body: c } = o
				if (
					s < 200 ||
					s >= 300 ||
					!(
						typeof c?.stream == 'function' ||
						typeof c?.pipe == 'function' ||
						typeof c?.tee == 'function'
					)
				)
					return i
				let u = c,
					m = c
				c &&
					typeof c == 'object' &&
					!(c instanceof Uint8Array) &&
					([u, m] = await (0, AA.splitStream)(c)),
					(o.body = m)
				let f = await z7(u, {
					streamCollector: async (g) => (0, AA.headStream)(g, G7),
				})
				typeof u?.destroy == 'function' && u.destroy()
				let p = e.utf8Encoder(f.subarray(f.length - 16))
				if (f.length === 0 && U7[r.commandName]) {
					let g = new Error('S3 aborted request')
					throw ((g.name = 'InternalError'), g)
				}
				return p && p.endsWith('</Error>') && (o.statusCode = 400), i
			},
			'throw200ExceptionsMiddleware',
		),
		z7 = Ne(
			(e = new Uint8Array(), t) =>
				e instanceof Uint8Array
					? Promise.resolve(e)
					: t.streamCollector(e) || Promise.resolve(new Uint8Array()),
			'collectBody',
		),
		KA = {
			relation: 'after',
			toMiddleware: 'deserializerMiddleware',
			tags: ['THROW_200_EXCEPTIONS', 'S3'],
			name: 'throw200ExceptionsMiddleware',
			override: !0,
		},
		H7 = Ne(
			(e) => ({
				applyToStack: (t) => {
					t.addRelativeTo(VA(e), KA)
				},
			}),
			'getThrow200ExceptionsPlugin',
		),
		$7 = Ov()
	function WA(e) {
		return (t, r) => async (n) => {
			var i, o, s, c
			if (e.bucketEndpoint) {
				let l = r.endpointV2
				if (l) {
					let u = n.input.Bucket
					if (typeof u == 'string')
						try {
							let m = new URL(u)
							l.url = m
						} catch (m) {
							let f = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${u} could not be parsed as URL.`
							throw (
								(((o = (i = r.logger) == null ? void 0 : i.constructor) == null
									? void 0
									: o.name) === 'NoOpLogger'
									? console.warn(f)
									: (c = (s = r.logger) == null ? void 0 : s.warn) == null ||
										c.call(s, f),
								m)
							)
						}
				}
			}
			return t(n)
		}
	}
	Ne(WA, 'bucketEndpointMiddleware')
	var V7 = {
		name: 'bucketEndpointMiddleware',
		override: !0,
		relation: 'after',
		toMiddleware: 'endpointV2Middleware',
	}
	function Fv({ bucketEndpoint: e }) {
		return (t) => async (r) => {
			let {
				input: { Bucket: n },
			} = r
			if (
				!e &&
				typeof n == 'string' &&
				!(0, $7.validate)(n) &&
				n.indexOf('/') >= 0
			) {
				let i = new Error(`Bucket name shouldn't contain '/', received '${n}'`)
				throw ((i.name = 'InvalidBucketName'), i)
			}
			return t({ ...r })
		}
	}
	Ne(Fv, 'validateBucketNameMiddleware')
	var XA = {
			step: 'initialize',
			tags: ['VALIDATE_BUCKET_NAME'],
			name: 'validateBucketNameMiddleware',
			override: !0,
		},
		K7 = Ne(
			(e) => ({
				applyToStack: (t) => {
					t.add(Fv(e), XA), t.addRelativeTo(WA(e), V7)
				},
			}),
			'getValidateBucketNamePlugin',
		)
})
var Is = E((ike, sO) => {
	var Cu = Object.defineProperty,
		W7 = Object.getOwnPropertyDescriptor,
		X7 = Object.getOwnPropertyNames,
		Y7 = Object.prototype.hasOwnProperty,
		qe = (e, t) => Cu(e, 'name', { value: t, configurable: !0 }),
		J7 = (e, t) => {
			for (var r in t) Cu(e, r, { get: t[r], enumerable: !0 })
		},
		Q7 = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of X7(t))
					!Y7.call(e, i) &&
						i !== r &&
						Cu(e, i, {
							get: () => t[i],
							enumerable: !(n = W7(t, i)) || n.enumerable,
						})
			return e
		},
		Z7 = (e) => Q7(Cu({}, '__esModule', { value: !0 }), e),
		JA = {}
	J7(JA, {
		EndpointError: () => hr,
		customEndpointFunctions: () => qv,
		isIpAddress: () => QA,
		isValidHostLabel: () => Uv,
		resolveEndpoint: () => _Y,
	})
	sO.exports = Z7(JA)
	var eY = new RegExp(
			'^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$',
		),
		QA = qe(
			(e) => eY.test(e) || (e.startsWith('[') && e.endsWith(']')),
			'isIpAddress',
		),
		tY = new RegExp('^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$'),
		Uv = qe((e, t = !1) => {
			if (!t) return tY.test(e)
			let r = e.split('.')
			for (let n of r) if (!Uv(n)) return !1
			return !0
		}, 'isValidHostLabel'),
		qv = {},
		Vc = 'endpoints'
	function Vn(e) {
		return typeof e != 'object' || e == null
			? e
			: 'ref' in e
				? `$${Vn(e.ref)}`
				: 'fn' in e
					? `${e.fn}(${(e.argv || []).map(Vn).join(', ')})`
					: JSON.stringify(e, null, 2)
	}
	qe(Vn, 'toDebugString')
	var ZA = class extends Error {
		constructor(t) {
			super(t), (this.name = 'EndpointError')
		}
	}
	qe(ZA, 'EndpointError')
	var hr = ZA,
		rY = qe((e, t) => e === t, 'booleanEquals'),
		nY = qe((e) => {
			let t = e.split('.'),
				r = []
			for (let n of t) {
				let i = n.indexOf('[')
				if (i !== -1) {
					if (n.indexOf(']') !== n.length - 1)
						throw new hr(`Path: '${e}' does not end with ']'`)
					let o = n.slice(i + 1, -1)
					if (Number.isNaN(parseInt(o)))
						throw new hr(`Invalid array index: '${o}' in path: '${e}'`)
					i !== 0 && r.push(n.slice(0, i)), r.push(o)
				} else r.push(n)
			}
			return r
		}, 'getAttrPathList'),
		eO = qe(
			(e, t) =>
				nY(t).reduce((r, n) => {
					if (typeof r != 'object')
						throw new hr(
							`Index '${n}' in '${t}' not found in '${JSON.stringify(e)}'`,
						)
					return Array.isArray(r) ? r[parseInt(n)] : r[n]
				}, e),
			'getAttr',
		),
		iY = qe((e) => e != null, 'isSet'),
		oY = qe((e) => !e, 'not'),
		jv = en(),
		Mv = { [jv.EndpointURLScheme.HTTP]: 80, [jv.EndpointURLScheme.HTTPS]: 443 },
		sY = qe((e) => {
			let t = (() => {
				try {
					if (e instanceof URL) return e
					if (typeof e == 'object' && 'hostname' in e) {
						let {
								hostname: p,
								port: g,
								protocol: v = '',
								path: _ = '',
								query: y = {},
							} = e,
							P = new URL(`${v}//${p}${g ? `:${g}` : ''}${_}`)
						return (
							(P.search = Object.entries(y)
								.map(([x, W]) => `${x}=${W}`)
								.join('&')),
							P
						)
					}
					return new URL(e)
				} catch {
					return null
				}
			})()
			if (!t)
				return (
					console.error(
						`Unable to parse ${JSON.stringify(e)} as a whatwg URL.`,
					),
					null
				)
			let r = t.href,
				{ host: n, hostname: i, pathname: o, protocol: s, search: c } = t
			if (c) return null
			let l = s.slice(0, -1)
			if (!Object.values(jv.EndpointURLScheme).includes(l)) return null
			let u = QA(i),
				m =
					r.includes(`${n}:${Mv[l]}`) ||
					(typeof e == 'string' && e.includes(`${n}:${Mv[l]}`)),
				f = `${n}${m ? `:${Mv[l]}` : ''}`
			return {
				scheme: l,
				authority: f,
				path: o,
				normalizedPath: o.endsWith('/') ? o : `${o}/`,
				isIp: u,
			}
		}, 'parseURL'),
		aY = qe((e, t) => e === t, 'stringEquals'),
		cY = qe(
			(e, t, r, n) =>
				t >= r || e.length < r
					? null
					: n
						? e.substring(e.length - r, e.length - t)
						: e.substring(t, r),
			'substring',
		),
		lY = qe(
			(e) =>
				encodeURIComponent(e).replace(
					/[!*'()]/g,
					(t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`,
				),
			'uriEncode',
		),
		dY = {
			booleanEquals: rY,
			getAttr: eO,
			isSet: iY,
			isValidHostLabel: Uv,
			not: oY,
			parseURL: sY,
			stringEquals: aY,
			substring: cY,
			uriEncode: lY,
		},
		tO = qe((e, t) => {
			let r = [],
				n = { ...t.endpointParams, ...t.referenceRecord },
				i = 0
			for (; i < e.length; ) {
				let o = e.indexOf('{', i)
				if (o === -1) {
					r.push(e.slice(i))
					break
				}
				r.push(e.slice(i, o))
				let s = e.indexOf('}', o)
				if (s === -1) {
					r.push(e.slice(o))
					break
				}
				e[o + 1] === '{' &&
					e[s + 1] === '}' &&
					(r.push(e.slice(o + 1, s)), (i = s + 2))
				let c = e.substring(o + 1, s)
				if (c.includes('#')) {
					let [l, u] = c.split('#')
					r.push(eO(n[l], u))
				} else r.push(n[c])
				i = s + 1
			}
			return r.join('')
		}, 'evaluateTemplate'),
		uY = qe(
			({ ref: e }, t) => ({ ...t.endpointParams, ...t.referenceRecord })[e],
			'getReferenceValue',
		),
		Eu = qe((e, t, r) => {
			if (typeof e == 'string') return tO(e, r)
			if (e.fn) return rO(e, r)
			if (e.ref) return uY(e, r)
			throw new hr(
				`'${t}': ${String(e)} is not a string, function or reference.`,
			)
		}, 'evaluateExpression'),
		rO = qe(({ fn: e, argv: t }, r) => {
			let n = t.map((o) =>
					['boolean', 'number'].includes(typeof o) ? o : Eu(o, 'arg', r),
				),
				i = e.split('.')
			return i[0] in qv && i[1] != null ? qv[i[0]][i[1]](...n) : dY[e](...n)
		}, 'callFunction'),
		mY = qe(({ assign: e, ...t }, r) => {
			var n, i
			if (e && e in r.referenceRecord)
				throw new hr(`'${e}' is already defined in Reference Record.`)
			let o = rO(t, r)
			return (
				(i = (n = r.logger) == null ? void 0 : n.debug) == null ||
					i.call(n, `${Vc} evaluateCondition: ${Vn(t)} = ${Vn(o)}`),
				{
					result: o === '' ? !0 : !!o,
					...(e != null && { toAssign: { name: e, value: o } }),
				}
			)
		}, 'evaluateCondition'),
		Gv = qe((e = [], t) => {
			var r, n
			let i = {}
			for (let o of e) {
				let { result: s, toAssign: c } = mY(o, {
					...t,
					referenceRecord: { ...t.referenceRecord, ...i },
				})
				if (!s) return { result: s }
				c &&
					((i[c.name] = c.value),
					(n = (r = t.logger) == null ? void 0 : r.debug) == null ||
						n.call(r, `${Vc} assign: ${c.name} := ${Vn(c.value)}`))
			}
			return { result: !0, referenceRecord: i }
		}, 'evaluateConditions'),
		fY = qe(
			(e, t) =>
				Object.entries(e).reduce(
					(r, [n, i]) => ({
						...r,
						[n]: i.map((o) => {
							let s = Eu(o, 'Header value entry', t)
							if (typeof s != 'string')
								throw new hr(`Header '${n}' value '${s}' is not a string`)
							return s
						}),
					}),
					{},
				),
			'getEndpointHeaders',
		),
		nO = qe((e, t) => {
			if (Array.isArray(e)) return e.map((r) => nO(r, t))
			switch (typeof e) {
				case 'string':
					return tO(e, t)
				case 'object':
					if (e === null) throw new hr(`Unexpected endpoint property: ${e}`)
					return iO(e, t)
				case 'boolean':
					return e
				default:
					throw new hr(`Unexpected endpoint property type: ${typeof e}`)
			}
		}, 'getEndpointProperty'),
		iO = qe(
			(e, t) =>
				Object.entries(e).reduce((r, [n, i]) => ({ ...r, [n]: nO(i, t) }), {}),
			'getEndpointProperties',
		),
		pY = qe((e, t) => {
			let r = Eu(e, 'Endpoint URL', t)
			if (typeof r == 'string')
				try {
					return new URL(r)
				} catch (n) {
					throw (console.error(`Failed to construct URL with ${r}`, n), n)
				}
			throw new hr(`Endpoint URL must be a string, got ${typeof r}`)
		}, 'getEndpointUrl'),
		gY = qe((e, t) => {
			var r, n
			let { conditions: i, endpoint: o } = e,
				{ result: s, referenceRecord: c } = Gv(i, t)
			if (!s) return
			let l = { ...t, referenceRecord: { ...t.referenceRecord, ...c } },
				{ url: u, properties: m, headers: f } = o
			return (
				(n = (r = t.logger) == null ? void 0 : r.debug) == null ||
					n.call(r, `${Vc} Resolving endpoint from template: ${Vn(o)}`),
				{
					...(f != null && { headers: fY(f, l) }),
					...(m != null && { properties: iO(m, l) }),
					url: pY(u, l),
				}
			)
		}, 'evaluateEndpointRule'),
		vY = qe((e, t) => {
			let { conditions: r, error: n } = e,
				{ result: i, referenceRecord: o } = Gv(r, t)
			if (i)
				throw new hr(
					Eu(n, 'Error', {
						...t,
						referenceRecord: { ...t.referenceRecord, ...o },
					}),
				)
		}, 'evaluateErrorRule'),
		hY = qe((e, t) => {
			let { conditions: r, rules: n } = e,
				{ result: i, referenceRecord: o } = Gv(r, t)
			if (i)
				return oO(n, { ...t, referenceRecord: { ...t.referenceRecord, ...o } })
		}, 'evaluateTreeRule'),
		oO = qe((e, t) => {
			for (let r of e)
				if (r.type === 'endpoint') {
					let n = gY(r, t)
					if (n) return n
				} else if (r.type === 'error') vY(r, t)
				else if (r.type === 'tree') {
					let n = hY(r, t)
					if (n) return n
				} else throw new hr(`Unknown endpoint rule: ${r}`)
			throw new hr('Rules evaluation failed')
		}, 'evaluateRules'),
		_Y = qe((e, t) => {
			var r, n, i, o, s
			let { endpointParams: c, logger: l } = t,
				{ parameters: u, rules: m } = e
			;(n = (r = t.logger) == null ? void 0 : r.debug) == null ||
				n.call(r, `${Vc} Initial EndpointParams: ${Vn(c)}`)
			let f = Object.entries(u)
				.filter(([, v]) => v.default != null)
				.map(([v, _]) => [v, _.default])
			if (f.length > 0) for (let [v, _] of f) c[v] = c[v] ?? _
			let p = Object.entries(u)
				.filter(([, v]) => v.required)
				.map(([v]) => v)
			for (let v of p)
				if (c[v] == null) throw new hr(`Missing required parameter: '${v}'`)
			let g = oO(m, { endpointParams: c, logger: l, referenceRecord: {} })
			if ((i = t.endpointParams) != null && i.Endpoint)
				try {
					let v = new URL(t.endpointParams.Endpoint),
						{ protocol: _, port: y } = v
					;(g.url.protocol = _), (g.url.port = y)
				} catch {}
			return (
				(s = (o = t.logger) == null ? void 0 : o.debug) == null ||
					s.call(o, `${Vc} Resolved endpoint: ${Vn(g)}`),
				g
			)
		}, 'resolveEndpoint')
})
var Bs = E((oke, vO) => {
	'use strict'
	var bu = Object.defineProperty,
		yY = Object.getOwnPropertyDescriptor,
		SY = Object.getOwnPropertyNames,
		CY = Object.prototype.hasOwnProperty,
		Ts = (e, t) => bu(e, 'name', { value: t, configurable: !0 }),
		EY = (e, t) => {
			for (var r in t) bu(e, r, { get: t[r], enumerable: !0 })
		},
		bY = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of SY(t))
					!CY.call(e, i) &&
						i !== r &&
						bu(e, i, {
							get: () => t[i],
							enumerable: !(n = yY(t, i)) || n.enumerable,
						})
			return e
		},
		wY = (e) => bY(bu({}, '__esModule', { value: !0 }), e),
		cO = {}
	EY(cO, {
		ConditionObject: () => Ye.ConditionObject,
		DeprecatedObject: () => Ye.DeprecatedObject,
		EndpointError: () => Ye.EndpointError,
		EndpointObject: () => Ye.EndpointObject,
		EndpointObjectHeaders: () => Ye.EndpointObjectHeaders,
		EndpointObjectProperties: () => Ye.EndpointObjectProperties,
		EndpointParams: () => Ye.EndpointParams,
		EndpointResolverOptions: () => Ye.EndpointResolverOptions,
		EndpointRuleObject: () => Ye.EndpointRuleObject,
		ErrorRuleObject: () => Ye.ErrorRuleObject,
		EvaluateOptions: () => Ye.EvaluateOptions,
		Expression: () => Ye.Expression,
		FunctionArgv: () => Ye.FunctionArgv,
		FunctionObject: () => Ye.FunctionObject,
		FunctionReturn: () => Ye.FunctionReturn,
		ParameterObject: () => Ye.ParameterObject,
		ReferenceObject: () => Ye.ReferenceObject,
		ReferenceRecord: () => Ye.ReferenceRecord,
		RuleSetObject: () => Ye.RuleSetObject,
		RuleSetRules: () => Ye.RuleSetRules,
		TreeRuleObject: () => Ye.TreeRuleObject,
		awsEndpointFunctions: () => gO,
		getUserAgentPrefix: () => OY,
		isIpAddress: () => Ye.isIpAddress,
		partition: () => fO,
		resolveEndpoint: () => Ye.resolveEndpoint,
		setPartitionInfo: () => pO,
		useDefaultPartitionInfo: () => AY,
	})
	vO.exports = wY(cO)
	var Ye = Is(),
		lO = Ts((e, t = !1) => {
			if (t) {
				for (let r of e.split('.')) if (!lO(r)) return !1
				return !0
			}
			return !(
				!(0, Ye.isValidHostLabel)(e) ||
				e.length < 3 ||
				e.length > 63 ||
				e !== e.toLowerCase() ||
				(0, Ye.isIpAddress)(e)
			)
		}, 'isVirtualHostableS3Bucket'),
		aO = ':',
		xY = '/',
		PY = Ts((e) => {
			let t = e.split(aO)
			if (t.length < 6) return null
			let [r, n, i, o, s, ...c] = t
			if (r !== 'arn' || n === '' || i === '' || c.join(aO) === '') return null
			let l = c.map((u) => u.split(xY)).flat()
			return {
				partition: n,
				service: i,
				region: o,
				accountId: s,
				resourceId: l,
			}
		}, 'parseArn'),
		dO = {
			partitions: [
				{
					id: 'aws',
					outputs: {
						dnsSuffix: 'amazonaws.com',
						dualStackDnsSuffix: 'api.aws',
						implicitGlobalRegion: 'us-east-1',
						name: 'aws',
						supportsDualStack: !0,
						supportsFIPS: !0,
					},
					regionRegex: '^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$',
					regions: {
						'af-south-1': { description: 'Africa (Cape Town)' },
						'ap-east-1': { description: 'Asia Pacific (Hong Kong)' },
						'ap-northeast-1': { description: 'Asia Pacific (Tokyo)' },
						'ap-northeast-2': { description: 'Asia Pacific (Seoul)' },
						'ap-northeast-3': { description: 'Asia Pacific (Osaka)' },
						'ap-south-1': { description: 'Asia Pacific (Mumbai)' },
						'ap-south-2': { description: 'Asia Pacific (Hyderabad)' },
						'ap-southeast-1': { description: 'Asia Pacific (Singapore)' },
						'ap-southeast-2': { description: 'Asia Pacific (Sydney)' },
						'ap-southeast-3': { description: 'Asia Pacific (Jakarta)' },
						'ap-southeast-4': { description: 'Asia Pacific (Melbourne)' },
						'ap-southeast-5': { description: 'Asia Pacific (Malaysia)' },
						'aws-global': { description: 'AWS Standard global region' },
						'ca-central-1': { description: 'Canada (Central)' },
						'ca-west-1': { description: 'Canada West (Calgary)' },
						'eu-central-1': { description: 'Europe (Frankfurt)' },
						'eu-central-2': { description: 'Europe (Zurich)' },
						'eu-north-1': { description: 'Europe (Stockholm)' },
						'eu-south-1': { description: 'Europe (Milan)' },
						'eu-south-2': { description: 'Europe (Spain)' },
						'eu-west-1': { description: 'Europe (Ireland)' },
						'eu-west-2': { description: 'Europe (London)' },
						'eu-west-3': { description: 'Europe (Paris)' },
						'il-central-1': { description: 'Israel (Tel Aviv)' },
						'me-central-1': { description: 'Middle East (UAE)' },
						'me-south-1': { description: 'Middle East (Bahrain)' },
						'sa-east-1': { description: 'South America (Sao Paulo)' },
						'us-east-1': { description: 'US East (N. Virginia)' },
						'us-east-2': { description: 'US East (Ohio)' },
						'us-west-1': { description: 'US West (N. California)' },
						'us-west-2': { description: 'US West (Oregon)' },
					},
				},
				{
					id: 'aws-cn',
					outputs: {
						dnsSuffix: 'amazonaws.com.cn',
						dualStackDnsSuffix: 'api.amazonwebservices.com.cn',
						implicitGlobalRegion: 'cn-northwest-1',
						name: 'aws-cn',
						supportsDualStack: !0,
						supportsFIPS: !0,
					},
					regionRegex: '^cn\\-\\w+\\-\\d+$',
					regions: {
						'aws-cn-global': { description: 'AWS China global region' },
						'cn-north-1': { description: 'China (Beijing)' },
						'cn-northwest-1': { description: 'China (Ningxia)' },
					},
				},
				{
					id: 'aws-us-gov',
					outputs: {
						dnsSuffix: 'amazonaws.com',
						dualStackDnsSuffix: 'api.aws',
						implicitGlobalRegion: 'us-gov-west-1',
						name: 'aws-us-gov',
						supportsDualStack: !0,
						supportsFIPS: !0,
					},
					regionRegex: '^us\\-gov\\-\\w+\\-\\d+$',
					regions: {
						'aws-us-gov-global': {
							description: 'AWS GovCloud (US) global region',
						},
						'us-gov-east-1': { description: 'AWS GovCloud (US-East)' },
						'us-gov-west-1': { description: 'AWS GovCloud (US-West)' },
					},
				},
				{
					id: 'aws-iso',
					outputs: {
						dnsSuffix: 'c2s.ic.gov',
						dualStackDnsSuffix: 'c2s.ic.gov',
						implicitGlobalRegion: 'us-iso-east-1',
						name: 'aws-iso',
						supportsDualStack: !1,
						supportsFIPS: !0,
					},
					regionRegex: '^us\\-iso\\-\\w+\\-\\d+$',
					regions: {
						'aws-iso-global': { description: 'AWS ISO (US) global region' },
						'us-iso-east-1': { description: 'US ISO East' },
						'us-iso-west-1': { description: 'US ISO WEST' },
					},
				},
				{
					id: 'aws-iso-b',
					outputs: {
						dnsSuffix: 'sc2s.sgov.gov',
						dualStackDnsSuffix: 'sc2s.sgov.gov',
						implicitGlobalRegion: 'us-isob-east-1',
						name: 'aws-iso-b',
						supportsDualStack: !1,
						supportsFIPS: !0,
					},
					regionRegex: '^us\\-isob\\-\\w+\\-\\d+$',
					regions: {
						'aws-iso-b-global': { description: 'AWS ISOB (US) global region' },
						'us-isob-east-1': { description: 'US ISOB East (Ohio)' },
					},
				},
				{
					id: 'aws-iso-e',
					outputs: {
						dnsSuffix: 'cloud.adc-e.uk',
						dualStackDnsSuffix: 'cloud.adc-e.uk',
						implicitGlobalRegion: 'eu-isoe-west-1',
						name: 'aws-iso-e',
						supportsDualStack: !1,
						supportsFIPS: !0,
					},
					regionRegex: '^eu\\-isoe\\-\\w+\\-\\d+$',
					regions: { 'eu-isoe-west-1': { description: 'EU ISOE West' } },
				},
				{
					id: 'aws-iso-f',
					outputs: {
						dnsSuffix: 'csp.hci.ic.gov',
						dualStackDnsSuffix: 'csp.hci.ic.gov',
						implicitGlobalRegion: 'us-isof-south-1',
						name: 'aws-iso-f',
						supportsDualStack: !1,
						supportsFIPS: !0,
					},
					regionRegex: '^us\\-isof\\-\\w+\\-\\d+$',
					regions: {},
				},
			],
			version: '1.1',
		},
		uO = dO,
		mO = '',
		fO = Ts((e) => {
			let { partitions: t } = uO
			for (let n of t) {
				let { regions: i, outputs: o } = n
				for (let [s, c] of Object.entries(i)) if (s === e) return { ...o, ...c }
			}
			for (let n of t) {
				let { regionRegex: i, outputs: o } = n
				if (new RegExp(i).test(e)) return { ...o }
			}
			let r = t.find((n) => n.id === 'aws')
			if (!r)
				throw new Error(
					"Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.",
				)
			return { ...r.outputs }
		}, 'partition'),
		pO = Ts((e, t = '') => {
			;(uO = e), (mO = t)
		}, 'setPartitionInfo'),
		AY = Ts(() => {
			pO(dO, '')
		}, 'useDefaultPartitionInfo'),
		OY = Ts(() => mO, 'getUserAgentPrefix'),
		gO = { isVirtualHostableS3Bucket: lO, parseArn: PY, partition: fO }
	Ye.customEndpointFunctions.aws = gO
})
var Kc = E((ske, wO) => {
	'use strict'
	var wu = Object.defineProperty,
		RY = Object.getOwnPropertyDescriptor,
		kY = Object.getOwnPropertyNames,
		IY = Object.prototype.hasOwnProperty,
		xu = (e, t) => wu(e, 'name', { value: t, configurable: !0 }),
		TY = (e, t) => {
			for (var r in t) wu(e, r, { get: t[r], enumerable: !0 })
		},
		BY = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of kY(t))
					!IY.call(e, i) &&
						i !== r &&
						wu(e, i, {
							get: () => t[i],
							enumerable: !(n = RY(t, i)) || n.enumerable,
						})
			return e
		},
		NY = (e) => BY(wu({}, '__esModule', { value: !0 }), e),
		SO = {}
	TY(SO, {
		getUserAgentMiddlewareOptions: () => bO,
		getUserAgentPlugin: () => qY,
		resolveUserAgentConfig: () => CO,
		userAgentMiddleware: () => EO,
	})
	wO.exports = NY(SO)
	function CO(e) {
		return {
			...e,
			customUserAgent:
				typeof e.customUserAgent == 'string'
					? [[e.customUserAgent]]
					: e.customUserAgent,
		}
	}
	xu(CO, 'resolveUserAgentConfig')
	var DY = Bs(),
		LY = Xe(),
		hO = 'user-agent',
		zv = 'x-amz-user-agent',
		_O = ' ',
		Hv = '/',
		FY = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g,
		MY = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g,
		yO = '-',
		EO = xu(
			(e) => (t, r) => async (n) => {
				var i, o
				let { request: s } = n
				if (!LY.HttpRequest.isInstance(s)) return t(n)
				let { headers: c } = s,
					l = ((i = r?.userAgent) == null ? void 0 : i.map($v)) || [],
					u = (await e.defaultUserAgentProvider()).map($v),
					m = ((o = e?.customUserAgent) == null ? void 0 : o.map($v)) || [],
					f = (0, DY.getUserAgentPrefix)(),
					p = (f ? [f] : []).concat([...u, ...l, ...m]).join(_O),
					g = [...u.filter((v) => v.startsWith('aws-sdk-')), ...m].join(_O)
				return (
					e.runtime !== 'browser'
						? (g && (c[zv] = c[zv] ? `${c[hO]} ${g}` : g), (c[hO] = p))
						: (c[zv] = p),
					t({ ...n, request: s })
				)
			},
			'userAgentMiddleware',
		),
		$v = xu((e) => {
			var t
			let r = e[0]
					.split(Hv)
					.map((c) => c.replace(FY, yO))
					.join(Hv),
				n = (t = e[1]) == null ? void 0 : t.replace(MY, yO),
				i = r.indexOf(Hv),
				o = r.substring(0, i),
				s = r.substring(i + 1)
			return (
				o === 'api' && (s = s.toLowerCase()),
				[o, s, n]
					.filter((c) => c && c.length > 0)
					.reduce((c, l, u) => {
						switch (u) {
							case 0:
								return l
							case 1:
								return `${c}/${l}`
							default:
								return `${c}#${l}`
						}
					}, '')
			)
		}, 'escapeUserAgent'),
		bO = {
			name: 'getUserAgentMiddleware',
			step: 'build',
			priority: 'low',
			tags: ['SET_USER_AGENT', 'USER_AGENT'],
			override: !0,
		},
		qY = xu(
			(e) => ({
				applyToStack: (t) => {
					t.add(EO(e), bO)
				},
			}),
			'getUserAgentPlugin',
		)
})
var wn = E((ake, DO) => {
	var Au = Object.defineProperty,
		jY = Object.getOwnPropertyDescriptor,
		UY = Object.getOwnPropertyNames,
		GY = Object.prototype.hasOwnProperty,
		nn = (e, t) => Au(e, 'name', { value: t, configurable: !0 }),
		zY = (e, t) => {
			for (var r in t) Au(e, r, { get: t[r], enumerable: !0 })
		},
		HY = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of UY(t))
					!GY.call(e, i) &&
						i !== r &&
						Au(e, i, {
							get: () => t[i],
							enumerable: !(n = jY(t, i)) || n.enumerable,
						})
			return e
		},
		$Y = (e) => HY(Au({}, '__esModule', { value: !0 }), e),
		AO = {}
	zY(AO, {
		CONFIG_USE_DUALSTACK_ENDPOINT: () => RO,
		CONFIG_USE_FIPS_ENDPOINT: () => IO,
		DEFAULT_USE_DUALSTACK_ENDPOINT: () => VY,
		DEFAULT_USE_FIPS_ENDPOINT: () => WY,
		ENV_USE_DUALSTACK_ENDPOINT: () => OO,
		ENV_USE_FIPS_ENDPOINT: () => kO,
		NODE_REGION_CONFIG_FILE_OPTIONS: () => eJ,
		NODE_REGION_CONFIG_OPTIONS: () => ZY,
		NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS: () => KY,
		NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS: () => XY,
		REGION_ENV_NAME: () => TO,
		REGION_INI_NAME: () => BO,
		getRegionInfo: () => oJ,
		resolveCustomEndpointsConfig: () => YY,
		resolveEndpointsConfig: () => QY,
		resolveRegionConfig: () => tJ,
	})
	DO.exports = $Y(AO)
	var Ci = zd(),
		OO = 'AWS_USE_DUALSTACK_ENDPOINT',
		RO = 'use_dualstack_endpoint',
		VY = !1,
		KY = {
			environmentVariableSelector: (e) =>
				(0, Ci.booleanSelector)(e, OO, Ci.SelectorType.ENV),
			configFileSelector: (e) =>
				(0, Ci.booleanSelector)(e, RO, Ci.SelectorType.CONFIG),
			default: !1,
		},
		kO = 'AWS_USE_FIPS_ENDPOINT',
		IO = 'use_fips_endpoint',
		WY = !1,
		XY = {
			environmentVariableSelector: (e) =>
				(0, Ci.booleanSelector)(e, kO, Ci.SelectorType.ENV),
			configFileSelector: (e) =>
				(0, Ci.booleanSelector)(e, IO, Ci.SelectorType.CONFIG),
			default: !1,
		},
		Pu = Tr(),
		YY = nn((e) => {
			let { endpoint: t, urlParser: r } = e
			return {
				...e,
				tls: e.tls ?? !0,
				endpoint: (0, Pu.normalizeProvider)(typeof t == 'string' ? r(t) : t),
				isCustomEndpoint: !0,
				useDualstackEndpoint: (0, Pu.normalizeProvider)(
					e.useDualstackEndpoint ?? !1,
				),
			}
		}, 'resolveCustomEndpointsConfig'),
		JY = nn(async (e) => {
			let { tls: t = !0 } = e,
				r = await e.region()
			if (
				!new RegExp(
					/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/,
				).test(r)
			)
				throw new Error('Invalid region in client config')
			let i = await e.useDualstackEndpoint(),
				o = await e.useFipsEndpoint(),
				{ hostname: s } =
					(await e.regionInfoProvider(r, {
						useDualstackEndpoint: i,
						useFipsEndpoint: o,
					})) ?? {}
			if (!s) throw new Error('Cannot resolve hostname from client config')
			return e.urlParser(`${t ? 'https:' : 'http:'}//${s}`)
		}, 'getEndpointFromRegion'),
		QY = nn((e) => {
			let t = (0, Pu.normalizeProvider)(e.useDualstackEndpoint ?? !1),
				{ endpoint: r, useFipsEndpoint: n, urlParser: i } = e
			return {
				...e,
				tls: e.tls ?? !0,
				endpoint: r
					? (0, Pu.normalizeProvider)(typeof r == 'string' ? i(r) : r)
					: () => JY({ ...e, useDualstackEndpoint: t, useFipsEndpoint: n }),
				isCustomEndpoint: !!r,
				useDualstackEndpoint: t,
			}
		}, 'resolveEndpointsConfig'),
		TO = 'AWS_REGION',
		BO = 'region',
		ZY = {
			environmentVariableSelector: (e) => e[TO],
			configFileSelector: (e) => e[BO],
			default: () => {
				throw new Error('Region is missing')
			},
		},
		eJ = { preferredFile: 'credentials' },
		NO = nn(
			(e) =>
				typeof e == 'string' && (e.startsWith('fips-') || e.endsWith('-fips')),
			'isFipsRegion',
		),
		xO = nn(
			(e) =>
				NO(e)
					? ['fips-aws-global', 'aws-fips'].includes(e)
						? 'us-east-1'
						: e.replace(/fips-(dkr-|prod-)?|-fips/, '')
					: e,
			'getRealRegion',
		),
		tJ = nn((e) => {
			let { region: t, useFipsEndpoint: r } = e
			if (!t) throw new Error('Region is missing')
			return {
				...e,
				region: async () => {
					if (typeof t == 'string') return xO(t)
					let n = await t()
					return xO(n)
				},
				useFipsEndpoint: async () => {
					let n = typeof t == 'string' ? t : await t()
					return NO(n)
						? !0
						: typeof r != 'function'
							? Promise.resolve(!!r)
							: r()
				},
			}
		}, 'resolveRegionConfig'),
		PO = nn((e = [], { useFipsEndpoint: t, useDualstackEndpoint: r }) => {
			var n
			return (n = e.find(
				({ tags: i }) =>
					t === i.includes('fips') && r === i.includes('dualstack'),
			)) == null
				? void 0
				: n.hostname
		}, 'getHostnameFromVariants'),
		rJ = nn(
			(e, { regionHostname: t, partitionHostname: r }) =>
				t || (r ? r.replace('{region}', e) : void 0),
			'getResolvedHostname',
		),
		nJ = nn(
			(e, { partitionHash: t }) =>
				Object.keys(t || {}).find((r) => t[r].regions.includes(e)) ?? 'aws',
			'getResolvedPartition',
		),
		iJ = nn((e, { signingRegion: t, regionRegex: r, useFipsEndpoint: n }) => {
			if (t) return t
			if (n) {
				let i = r
						.replace('\\\\', '\\')
						.replace(/^\^/g, '\\.')
						.replace(/\$$/g, '\\.'),
					o = e.match(i)
				if (o) return o[0].slice(1, -1)
			}
		}, 'getResolvedSigningRegion'),
		oJ = nn(
			(
				e,
				{
					useFipsEndpoint: t = !1,
					useDualstackEndpoint: r = !1,
					signingService: n,
					regionHash: i,
					partitionHash: o,
				},
			) => {
				var s, c, l, u, m
				let f = nJ(e, { partitionHash: o }),
					p = e in i ? e : ((s = o[f]) == null ? void 0 : s.endpoint) ?? e,
					g = { useFipsEndpoint: t, useDualstackEndpoint: r },
					v = PO((c = i[p]) == null ? void 0 : c.variants, g),
					_ = PO((l = o[f]) == null ? void 0 : l.variants, g),
					y = rJ(p, { regionHostname: v, partitionHostname: _ })
				if (y === void 0)
					throw new Error(
						`Endpoint resolution failed for: ${{ resolvedRegion: p, useFipsEndpoint: t, useDualstackEndpoint: r }}`,
					)
				let P = iJ(y, {
					signingRegion: (u = i[p]) == null ? void 0 : u.signingRegion,
					regionRegex: o[f].regionRegex,
					useFipsEndpoint: t,
				})
				return {
					partition: f,
					signingService: n,
					hostname: y,
					...(P && { signingRegion: P }),
					...(((m = i[p]) == null ? void 0 : m.signingService) && {
						signingService: i[p].signingService,
					}),
				}
			},
			'getRegionInfo',
		)
})
var MO = E((cke, FO) => {
	var Ou = Object.defineProperty,
		sJ = Object.getOwnPropertyDescriptor,
		aJ = Object.getOwnPropertyNames,
		cJ = Object.prototype.hasOwnProperty,
		lJ = (e, t) => Ou(e, 'name', { value: t, configurable: !0 }),
		dJ = (e, t) => {
			for (var r in t) Ou(e, r, { get: t[r], enumerable: !0 })
		},
		uJ = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of aJ(t))
					!cJ.call(e, i) &&
						i !== r &&
						Ou(e, i, {
							get: () => t[i],
							enumerable: !(n = sJ(t, i)) || n.enumerable,
						})
			return e
		},
		mJ = (e) => uJ(Ou({}, '__esModule', { value: !0 }), e),
		LO = {}
	dJ(LO, { resolveEventStreamSerdeConfig: () => fJ })
	FO.exports = mJ(LO)
	var fJ = lJ(
		(e) => ({ ...e, eventStreamMarshaller: e.eventStreamSerdeProvider(e) }),
		'resolveEventStreamSerdeConfig',
	)
})
var Wc = E((lke, zO) => {
	var Ru = Object.defineProperty,
		pJ = Object.getOwnPropertyDescriptor,
		gJ = Object.getOwnPropertyNames,
		vJ = Object.prototype.hasOwnProperty,
		jO = (e, t) => Ru(e, 'name', { value: t, configurable: !0 }),
		hJ = (e, t) => {
			for (var r in t) Ru(e, r, { get: t[r], enumerable: !0 })
		},
		_J = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of gJ(t))
					!vJ.call(e, i) &&
						i !== r &&
						Ru(e, i, {
							get: () => t[i],
							enumerable: !(n = pJ(t, i)) || n.enumerable,
						})
			return e
		},
		yJ = (e) => _J(Ru({}, '__esModule', { value: !0 }), e),
		UO = {}
	hJ(UO, {
		contentLengthMiddleware: () => Vv,
		contentLengthMiddlewareOptions: () => GO,
		getContentLengthPlugin: () => CJ,
	})
	zO.exports = yJ(UO)
	var SJ = Xe(),
		qO = 'content-length'
	function Vv(e) {
		return (t) => async (r) => {
			let n = r.request
			if (SJ.HttpRequest.isInstance(n)) {
				let { body: i, headers: o } = n
				if (
					i &&
					Object.keys(o)
						.map((s) => s.toLowerCase())
						.indexOf(qO) === -1
				)
					try {
						let s = e(i)
						n.headers = { ...n.headers, [qO]: String(s) }
					} catch {}
			}
			return t({ ...r, request: n })
		}
	}
	jO(Vv, 'contentLengthMiddleware')
	var GO = {
			step: 'build',
			tags: ['SET_CONTENT_LENGTH', 'CONTENT_LENGTH'],
			name: 'contentLengthMiddleware',
			override: !0,
		},
		CJ = jO(
			(e) => ({
				applyToStack: (t) => {
					t.add(Vv(e.bodyLengthChecker), GO)
				},
			}),
			'getContentLengthPlugin',
		)
})
var HO,
	EJ,
	$O = oe(() => {
		;(HO = !1),
			(EJ = (e) => {
				e &&
					!HO &&
					parseInt(e.substring(1, e.indexOf('.'))) < 18 &&
					((HO = !0),
					process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`))
			})
	})
var VO = oe(() => {
	$O()
})
var KO,
	Kv,
	WO = oe(() => {
		;(KO = Oe(Xe())),
			(Kv = (e) =>
				KO.HttpResponse.isInstance(e)
					? e.headers?.date ?? e.headers?.Date
					: void 0)
	})
var Ns,
	Wv = oe(() => {
		Ns = (e) => new Date(Date.now() + e)
	})
var XO,
	YO = oe(() => {
		Wv()
		XO = (e, t) => Math.abs(Ns(t).getTime() - e) >= 3e5
	})
var Xv,
	JO = oe(() => {
		YO()
		Xv = (e, t) => {
			let r = Date.parse(e)
			return XO(r, t) ? r - Date.now() : t
		}
	})
var Yv = oe(() => {
	WO()
	Wv()
	JO()
})
var QO,
	Xc,
	Yc,
	ho,
	ZO,
	Jv = oe(() => {
		QO = Oe(Xe())
		Yv()
		;(Xc = (e, t) => {
			if (!t)
				throw new Error(
					`Property \`${e}\` is not resolved for AWS SDK SigV4Auth`,
				)
			return t
		}),
			(Yc = async (e) => {
				let t = Xc('context', e.context),
					r = Xc('config', e.config),
					n = t.endpointV2?.properties?.authSchemes?.[0],
					o = await Xc('signer', r.signer)(n),
					s = e?.signingRegion,
					c = e?.signingRegionSet,
					l = e?.signingName
				return {
					config: r,
					signer: o,
					signingRegion: s,
					signingRegionSet: c,
					signingName: l,
				}
			}),
			(ho = class {
				async sign(t, r, n) {
					if (!QO.HttpRequest.isInstance(t))
						throw new Error(
							'The request is not an instance of `HttpRequest` and cannot be signed',
						)
					let i = await Yc(n),
						{ config: o, signer: s } = i,
						{ signingRegion: c, signingName: l } = i,
						u = n.context
					if (u?.authSchemes?.length ?? !1) {
						let [f, p] = u.authSchemes
						f?.name === 'sigv4a' &&
							p?.name === 'sigv4' &&
							((c = p?.signingRegion ?? c), (l = p?.signingName ?? l))
					}
					return await s.sign(t, {
						signingDate: Ns(o.systemClockOffset),
						signingRegion: c,
						signingService: l,
					})
				}
				errorHandler(t) {
					return (r) => {
						let n = r.ServerTime ?? Kv(r.$response)
						if (n) {
							let i = Xc('config', t.config),
								o = i.systemClockOffset
							;(i.systemClockOffset = Xv(n, i.systemClockOffset)),
								i.systemClockOffset !== o &&
									r.$metadata &&
									(r.$metadata.clockSkewCorrected = !0)
						}
						throw r
					}
				}
				successHandler(t, r) {
					let n = Kv(t)
					if (n) {
						let i = Xc('config', r.config)
						i.systemClockOffset = Xv(n, i.systemClockOffset)
					}
				}
			}),
			(ZO = ho)
	})
var eR,
	ku,
	tR = oe(() => {
		eR = Oe(Xe())
		Yv()
		Jv()
		ku = class extends ho {
			async sign(t, r, n) {
				if (!eR.HttpRequest.isInstance(t))
					throw new Error(
						'The request is not an instance of `HttpRequest` and cannot be signed',
					)
				let {
						config: i,
						signer: o,
						signingRegion: s,
						signingRegionSet: c,
						signingName: l,
					} = await Yc(n),
					m = ((await i.sigv4aSigningRegionSet?.()) ?? c ?? [s]).join(',')
				return await o.sign(t, {
					signingDate: Ns(i.systemClockOffset),
					signingRegion: m,
					signingService: l,
				})
			}
		}
	})
var Qv,
	bJ,
	wJ,
	rR = oe(() => {
		Ut()
		;(Qv = Oe(nr())),
			(bJ = (e) => (
				(e.sigv4aSigningRegionSet = Si(e.sigv4aSigningRegionSet)), e
			)),
			(wJ = {
				environmentVariableSelector(e) {
					if (e.AWS_SIGV4A_SIGNING_REGION_SET)
						return e.AWS_SIGV4A_SIGNING_REGION_SET.split(',').map((t) =>
							t.trim(),
						)
					throw new Qv.ProviderError(
						'AWS_SIGV4A_SIGNING_REGION_SET not set in env.',
						{ tryNextLink: !0 },
					)
				},
				configFileSelector(e) {
					if (e.sigv4a_signing_region_set)
						return (e.sigv4a_signing_region_set ?? '')
							.split(',')
							.map((t) => t.trim())
					throw new Qv.ProviderError(
						'sigv4a_signing_region_set not set in profile.',
						{ tryNextLink: !0 },
					)
				},
				default: void 0,
			})
	})
var Zv,
	nR,
	xJ,
	iR = oe(() => {
		Ut()
		;(Zv = Oe(Vg())),
			(nR = (e) => {
				let t
				e.credentials && (t = xv(e.credentials, wv, gu)),
					t ||
						(e.credentialDefaultProvider
							? (t = Si(
									e.credentialDefaultProvider(
										Object.assign({}, e, { parentClientConfig: e }),
									),
								))
							: (t = async () => {
									throw new Error('`credentials` is missing')
								}))
				let {
						signingEscapePath: r = !0,
						systemClockOffset: n = e.systemClockOffset || 0,
						sha256: i,
					} = e,
					o
				return (
					e.signer
						? (o = Si(e.signer))
						: e.regionInfoProvider
							? (o = () =>
									Si(e.region)()
										.then(async (s) => [
											(await e.regionInfoProvider(s, {
												useFipsEndpoint: await e.useFipsEndpoint(),
												useDualstackEndpoint: await e.useDualstackEndpoint(),
											})) || {},
											s,
										])
										.then(([s, c]) => {
											let { signingRegion: l, signingService: u } = s
											;(e.signingRegion = e.signingRegion || l || c),
												(e.signingName = e.signingName || u || e.serviceId)
											let m = {
													...e,
													credentials: t,
													region: e.signingRegion,
													service: e.signingName,
													sha256: i,
													uriEscapePath: r,
												},
												f = e.signerConstructor || Zv.SignatureV4
											return new f(m)
										}))
							: (o = async (s) => {
									s = Object.assign(
										{},
										{
											name: 'sigv4',
											signingName: e.signingName || e.defaultSigningName,
											signingRegion: await Si(e.region)(),
											properties: {},
										},
										s,
									)
									let c = s.signingRegion,
										l = s.signingName
									;(e.signingRegion = e.signingRegion || c),
										(e.signingName = e.signingName || l || e.serviceId)
									let u = {
											...e,
											credentials: t,
											region: e.signingRegion,
											service: e.signingName,
											sha256: i,
											uriEscapePath: r,
										},
										m = e.signerConstructor || Zv.SignatureV4
									return new m(u)
								}),
					{
						...e,
						systemClockOffset: n,
						signingEscapePath: r,
						credentials: t,
						signer: o,
					}
				)
			}),
			(xJ = nR)
	})
var oR = oe(() => {
	Jv()
	tR()
	rR()
	iR()
})
var sR = oe(() => {
	oR()
})
var PJ,
	AJ,
	OJ,
	aR = oe(() => {
		;(PJ = (e) => {
			if (e == null) return e
			if (typeof e == 'number' || typeof e == 'bigint') {
				let t = new Error(`Received number ${e} where a string was expected.`)
				return (t.name = 'Warning'), console.warn(t), String(e)
			}
			if (typeof e == 'boolean') {
				let t = new Error(`Received boolean ${e} where a string was expected.`)
				return (t.name = 'Warning'), console.warn(t), String(e)
			}
			return e
		}),
			(AJ = (e) => {
				if (e == null) return e
				if (typeof e == 'string') {
					let t = e.toLowerCase()
					if (e !== '' && t !== 'false' && t !== 'true') {
						let r = new Error(
							`Received string "${e}" where a boolean was expected.`,
						)
						;(r.name = 'Warning'), console.warn(r)
					}
					return e !== '' && t !== 'false'
				}
				return e
			}),
			(OJ = (e) => {
				if (e == null) return e
				if (typeof e == 'string') {
					let t = Number(e)
					if (t.toString() !== e) {
						let r = new Error(
							`Received string "${e}" where a number was expected.`,
						)
						return (r.name = 'Warning'), console.warn(r), e
					}
					return t
				}
				return e
			})
	})
var cR,
	RJ,
	lR = oe(() => {
		;(cR = Oe(ze())),
			(RJ = (e) => {
				if (e != null)
					return (
						typeof e == 'object' && '__type' in e && delete e.__type,
						(0, cR.expectUnion)(e)
					)
			})
	})
var dR,
	Iu,
	eh = oe(() => {
		;(dR = Oe(ze())),
			(Iu = (e, t) => (0, dR.collectBody)(e, t).then((r) => t.utf8Encoder(r)))
	})
var uR,
	kJ,
	IJ,
	mR = oe(() => {
		eh()
		;(uR = (e, t) =>
			Iu(e, t).then((r) => {
				if (r.length)
					try {
						return JSON.parse(r)
					} catch (n) {
						throw (
							(n?.name === 'SyntaxError' &&
								Object.defineProperty(n, '$responseBodyText', { value: r }),
							n)
						)
					}
				return {}
			})),
			(kJ = async (e, t) => {
				let r = await uR(e, t)
				return (r.message = r.message ?? r.Message), r
			}),
			(IJ = (e, t) => {
				let r = (o, s) =>
						Object.keys(o).find((c) => c.toLowerCase() === s.toLowerCase()),
					n = (o) => {
						let s = o
						return (
							typeof s == 'number' && (s = s.toString()),
							s.indexOf(',') >= 0 && (s = s.split(',')[0]),
							s.indexOf(':') >= 0 && (s = s.split(':')[0]),
							s.indexOf('#') >= 0 && (s = s.split('#')[1]),
							s
						)
					},
					i = r(e.headers, 'x-amzn-errortype')
				if (i !== void 0) return n(e.headers[i])
				if (t.code !== void 0) return n(t.code)
				if (t.__type !== void 0) return n(t.__type)
			})
	})
var Tu = E((Kn) => {
	'use strict'
	var fR =
			':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD',
		TJ = fR + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
		pR = '[' + fR + '][' + TJ + ']*',
		BJ = new RegExp('^' + pR + '$'),
		NJ = function (e, t) {
			let r = [],
				n = t.exec(e)
			for (; n; ) {
				let i = []
				i.startIndex = t.lastIndex - n[0].length
				let o = n.length
				for (let s = 0; s < o; s++) i.push(n[s])
				r.push(i), (n = t.exec(e))
			}
			return r
		},
		DJ = function (e) {
			let t = BJ.exec(e)
			return !(t === null || typeof t > 'u')
		}
	Kn.isExist = function (e) {
		return typeof e < 'u'
	}
	Kn.isEmptyObject = function (e) {
		return Object.keys(e).length === 0
	}
	Kn.merge = function (e, t, r) {
		if (t) {
			let n = Object.keys(t),
				i = n.length
			for (let o = 0; o < i; o++)
				r === 'strict' ? (e[n[o]] = [t[n[o]]]) : (e[n[o]] = t[n[o]])
		}
	}
	Kn.getValue = function (e) {
		return Kn.isExist(e) ? e : ''
	}
	Kn.isName = DJ
	Kn.getAllMatches = NJ
	Kn.nameRegexp = pR
})
var rh = E((yR) => {
	'use strict'
	var th = Tu(),
		LJ = { allowBooleanAttributes: !1, unpairedTags: [] }
	yR.validate = function (e, t) {
		t = Object.assign({}, LJ, t)
		let r = [],
			n = !1,
			i = !1
		e[0] === '\uFEFF' && (e = e.substr(1))
		for (let o = 0; o < e.length; o++)
			if (e[o] === '<' && e[o + 1] === '?') {
				if (((o += 2), (o = vR(e, o)), o.err)) return o
			} else if (e[o] === '<') {
				let s = o
				if ((o++, e[o] === '!')) {
					o = hR(e, o)
					continue
				} else {
					let c = !1
					e[o] === '/' && ((c = !0), o++)
					let l = ''
					for (
						;
						o < e.length &&
						e[o] !== '>' &&
						e[o] !== ' ' &&
						e[o] !== '	' &&
						e[o] !==
							`
` &&
						e[o] !== '\r';
						o++
					)
						l += e[o]
					if (
						((l = l.trim()),
						l[l.length - 1] === '/' &&
							((l = l.substring(0, l.length - 1)), o--),
						!HJ(l))
					) {
						let f
						return (
							l.trim().length === 0
								? (f = "Invalid space after '<'.")
								: (f = "Tag '" + l + "' is an invalid name."),
							vt('InvalidTag', f, or(e, o))
						)
					}
					let u = qJ(e, o)
					if (u === !1)
						return vt(
							'InvalidAttr',
							"Attributes for '" + l + "' have open quote.",
							or(e, o),
						)
					let m = u.value
					if (((o = u.index), m[m.length - 1] === '/')) {
						let f = o - m.length
						m = m.substring(0, m.length - 1)
						let p = _R(m, t)
						if (p === !0) n = !0
						else return vt(p.err.code, p.err.msg, or(e, f + p.err.line))
					} else if (c)
						if (u.tagClosed) {
							if (m.trim().length > 0)
								return vt(
									'InvalidTag',
									"Closing tag '" +
										l +
										"' can't have attributes or invalid starting.",
									or(e, s),
								)
							if (r.length === 0)
								return vt(
									'InvalidTag',
									"Closing tag '" + l + "' has not been opened.",
									or(e, s),
								)
							{
								let f = r.pop()
								if (l !== f.tagName) {
									let p = or(e, f.tagStartPos)
									return vt(
										'InvalidTag',
										"Expected closing tag '" +
											f.tagName +
											"' (opened in line " +
											p.line +
											', col ' +
											p.col +
											") instead of closing tag '" +
											l +
											"'.",
										or(e, s),
									)
								}
								r.length == 0 && (i = !0)
							}
						} else
							return vt(
								'InvalidTag',
								"Closing tag '" + l + "' doesn't have proper closing.",
								or(e, o),
							)
					else {
						let f = _R(m, t)
						if (f !== !0)
							return vt(f.err.code, f.err.msg, or(e, o - m.length + f.err.line))
						if (i === !0)
							return vt(
								'InvalidXml',
								'Multiple possible root nodes found.',
								or(e, o),
							)
						t.unpairedTags.indexOf(l) !== -1 ||
							r.push({ tagName: l, tagStartPos: s }),
							(n = !0)
					}
					for (o++; o < e.length; o++)
						if (e[o] === '<')
							if (e[o + 1] === '!') {
								o++, (o = hR(e, o))
								continue
							} else if (e[o + 1] === '?') {
								if (((o = vR(e, ++o)), o.err)) return o
							} else break
						else if (e[o] === '&') {
							let f = GJ(e, o)
							if (f == -1)
								return vt('InvalidChar', "char '&' is not expected.", or(e, o))
							o = f
						} else if (i === !0 && !gR(e[o]))
							return vt('InvalidXml', 'Extra text at the end', or(e, o))
					e[o] === '<' && o--
				}
			} else {
				if (gR(e[o])) continue
				return vt(
					'InvalidChar',
					"char '" + e[o] + "' is not expected.",
					or(e, o),
				)
			}
		if (n) {
			if (r.length == 1)
				return vt(
					'InvalidTag',
					"Unclosed tag '" + r[0].tagName + "'.",
					or(e, r[0].tagStartPos),
				)
			if (r.length > 0)
				return vt(
					'InvalidXml',
					"Invalid '" +
						JSON.stringify(
							r.map((o) => o.tagName),
							null,
							4,
						).replace(/\r?\n/g, '') +
						"' found.",
					{ line: 1, col: 1 },
				)
		} else return vt('InvalidXml', 'Start tag expected.', 1)
		return !0
	}
	function gR(e) {
		return (
			e === ' ' ||
			e === '	' ||
			e ===
				`
` ||
			e === '\r'
		)
	}
	function vR(e, t) {
		let r = t
		for (; t < e.length; t++)
			if (e[t] == '?' || e[t] == ' ') {
				let n = e.substr(r, t - r)
				if (t > 5 && n === 'xml')
					return vt(
						'InvalidXml',
						'XML declaration allowed only at the start of the document.',
						or(e, t),
					)
				if (e[t] == '?' && e[t + 1] == '>') {
					t++
					break
				} else continue
			}
		return t
	}
	function hR(e, t) {
		if (e.length > t + 5 && e[t + 1] === '-' && e[t + 2] === '-') {
			for (t += 3; t < e.length; t++)
				if (e[t] === '-' && e[t + 1] === '-' && e[t + 2] === '>') {
					t += 2
					break
				}
		} else if (
			e.length > t + 8 &&
			e[t + 1] === 'D' &&
			e[t + 2] === 'O' &&
			e[t + 3] === 'C' &&
			e[t + 4] === 'T' &&
			e[t + 5] === 'Y' &&
			e[t + 6] === 'P' &&
			e[t + 7] === 'E'
		) {
			let r = 1
			for (t += 8; t < e.length; t++)
				if (e[t] === '<') r++
				else if (e[t] === '>' && (r--, r === 0)) break
		} else if (
			e.length > t + 9 &&
			e[t + 1] === '[' &&
			e[t + 2] === 'C' &&
			e[t + 3] === 'D' &&
			e[t + 4] === 'A' &&
			e[t + 5] === 'T' &&
			e[t + 6] === 'A' &&
			e[t + 7] === '['
		) {
			for (t += 8; t < e.length; t++)
				if (e[t] === ']' && e[t + 1] === ']' && e[t + 2] === '>') {
					t += 2
					break
				}
		}
		return t
	}
	var FJ = '"',
		MJ = "'"
	function qJ(e, t) {
		let r = '',
			n = '',
			i = !1
		for (; t < e.length; t++) {
			if (e[t] === FJ || e[t] === MJ)
				n === '' ? (n = e[t]) : n !== e[t] || (n = '')
			else if (e[t] === '>' && n === '') {
				i = !0
				break
			}
			r += e[t]
		}
		return n !== '' ? !1 : { value: r, index: t, tagClosed: i }
	}
	var jJ = new RegExp(
		`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`,
		'g',
	)
	function _R(e, t) {
		let r = th.getAllMatches(e, jJ),
			n = {}
		for (let i = 0; i < r.length; i++) {
			if (r[i][1].length === 0)
				return vt(
					'InvalidAttr',
					"Attribute '" + r[i][2] + "' has no space in starting.",
					Jc(r[i]),
				)
			if (r[i][3] !== void 0 && r[i][4] === void 0)
				return vt(
					'InvalidAttr',
					"Attribute '" + r[i][2] + "' is without value.",
					Jc(r[i]),
				)
			if (r[i][3] === void 0 && !t.allowBooleanAttributes)
				return vt(
					'InvalidAttr',
					"boolean attribute '" + r[i][2] + "' is not allowed.",
					Jc(r[i]),
				)
			let o = r[i][2]
			if (!zJ(o))
				return vt(
					'InvalidAttr',
					"Attribute '" + o + "' is an invalid name.",
					Jc(r[i]),
				)
			if (!n.hasOwnProperty(o)) n[o] = 1
			else
				return vt('InvalidAttr', "Attribute '" + o + "' is repeated.", Jc(r[i]))
		}
		return !0
	}
	function UJ(e, t) {
		let r = /\d/
		for (e[t] === 'x' && (t++, (r = /[\da-fA-F]/)); t < e.length; t++) {
			if (e[t] === ';') return t
			if (!e[t].match(r)) break
		}
		return -1
	}
	function GJ(e, t) {
		if ((t++, e[t] === ';')) return -1
		if (e[t] === '#') return t++, UJ(e, t)
		let r = 0
		for (; t < e.length; t++, r++)
			if (!(e[t].match(/\w/) && r < 20)) {
				if (e[t] === ';') break
				return -1
			}
		return t
	}
	function vt(e, t, r) {
		return { err: { code: e, msg: t, line: r.line || r, col: r.col } }
	}
	function zJ(e) {
		return th.isName(e)
	}
	function HJ(e) {
		return th.isName(e)
	}
	function or(e, t) {
		let r = e.substring(0, t).split(/\r?\n/)
		return { line: r.length, col: r[r.length - 1].length + 1 }
	}
	function Jc(e) {
		return e.startIndex + e[1].length
	}
})
var CR = E((nh) => {
	var SR = {
			preserveOrder: !1,
			attributeNamePrefix: '@_',
			attributesGroupName: !1,
			textNodeName: '#text',
			ignoreAttributes: !0,
			removeNSPrefix: !1,
			allowBooleanAttributes: !1,
			parseTagValue: !0,
			parseAttributeValue: !1,
			trimValues: !0,
			cdataPropName: !1,
			numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 },
			tagValueProcessor: function (e, t) {
				return t
			},
			attributeValueProcessor: function (e, t) {
				return t
			},
			stopNodes: [],
			alwaysCreateTextNode: !1,
			isArray: () => !1,
			commentPropName: !1,
			unpairedTags: [],
			processEntities: !0,
			htmlEntities: !1,
			ignoreDeclaration: !1,
			ignorePiTags: !1,
			transformTagName: !1,
			transformAttributeName: !1,
			updateTag: function (e, t, r) {
				return e
			},
		},
		$J = function (e) {
			return Object.assign({}, SR, e)
		}
	nh.buildOptions = $J
	nh.defaultOptions = SR
})
var bR = E((Kke, ER) => {
	'use strict'
	var ih = class {
		constructor(t) {
			;(this.tagname = t), (this.child = []), (this[':@'] = {})
		}
		add(t, r) {
			t === '__proto__' && (t = '#__proto__'), this.child.push({ [t]: r })
		}
		addChild(t) {
			t.tagname === '__proto__' && (t.tagname = '#__proto__'),
				t[':@'] && Object.keys(t[':@']).length > 0
					? this.child.push({ [t.tagname]: t.child, ':@': t[':@'] })
					: this.child.push({ [t.tagname]: t.child })
		}
	}
	ER.exports = ih
})
var xR = E((Wke, wR) => {
	var VJ = Tu()
	function KJ(e, t) {
		let r = {}
		if (
			e[t + 3] === 'O' &&
			e[t + 4] === 'C' &&
			e[t + 5] === 'T' &&
			e[t + 6] === 'Y' &&
			e[t + 7] === 'P' &&
			e[t + 8] === 'E'
		) {
			t = t + 9
			let n = 1,
				i = !1,
				o = !1,
				s = ''
			for (; t < e.length; t++)
				if (e[t] === '<' && !o) {
					if (i && YJ(e, t))
						(t += 7),
							([entityName, val, t] = WJ(e, t + 1)),
							val.indexOf('&') === -1 &&
								(r[eQ(entityName)] = {
									regx: RegExp(`&${entityName};`, 'g'),
									val,
								})
					else if (i && JJ(e, t)) t += 8
					else if (i && QJ(e, t)) t += 8
					else if (i && ZJ(e, t)) t += 9
					else if (XJ) o = !0
					else throw new Error('Invalid DOCTYPE')
					n++, (s = '')
				} else if (e[t] === '>') {
					if (
						(o ? e[t - 1] === '-' && e[t - 2] === '-' && ((o = !1), n--) : n--,
						n === 0)
					)
						break
				} else e[t] === '[' ? (i = !0) : (s += e[t])
			if (n !== 0) throw new Error('Unclosed DOCTYPE')
		} else throw new Error('Invalid Tag instead of DOCTYPE')
		return { entities: r, i: t }
	}
	function WJ(e, t) {
		let r = ''
		for (; t < e.length && e[t] !== "'" && e[t] !== '"'; t++) r += e[t]
		if (((r = r.trim()), r.indexOf(' ') !== -1))
			throw new Error('External entites are not supported')
		let n = e[t++],
			i = ''
		for (; t < e.length && e[t] !== n; t++) i += e[t]
		return [r, i, t]
	}
	function XJ(e, t) {
		return e[t + 1] === '!' && e[t + 2] === '-' && e[t + 3] === '-'
	}
	function YJ(e, t) {
		return (
			e[t + 1] === '!' &&
			e[t + 2] === 'E' &&
			e[t + 3] === 'N' &&
			e[t + 4] === 'T' &&
			e[t + 5] === 'I' &&
			e[t + 6] === 'T' &&
			e[t + 7] === 'Y'
		)
	}
	function JJ(e, t) {
		return (
			e[t + 1] === '!' &&
			e[t + 2] === 'E' &&
			e[t + 3] === 'L' &&
			e[t + 4] === 'E' &&
			e[t + 5] === 'M' &&
			e[t + 6] === 'E' &&
			e[t + 7] === 'N' &&
			e[t + 8] === 'T'
		)
	}
	function QJ(e, t) {
		return (
			e[t + 1] === '!' &&
			e[t + 2] === 'A' &&
			e[t + 3] === 'T' &&
			e[t + 4] === 'T' &&
			e[t + 5] === 'L' &&
			e[t + 6] === 'I' &&
			e[t + 7] === 'S' &&
			e[t + 8] === 'T'
		)
	}
	function ZJ(e, t) {
		return (
			e[t + 1] === '!' &&
			e[t + 2] === 'N' &&
			e[t + 3] === 'O' &&
			e[t + 4] === 'T' &&
			e[t + 5] === 'A' &&
			e[t + 6] === 'T' &&
			e[t + 7] === 'I' &&
			e[t + 8] === 'O' &&
			e[t + 9] === 'N'
		)
	}
	function eQ(e) {
		if (VJ.isName(e)) return e
		throw new Error(`Invalid entity name ${e}`)
	}
	wR.exports = KJ
})
var AR = E((Xke, PR) => {
	var tQ = /^[-+]?0x[a-fA-F0-9]+$/,
		rQ =
			/^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/
	!Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt)
	!Number.parseFloat &&
		window.parseFloat &&
		(Number.parseFloat = window.parseFloat)
	var nQ = { hex: !0, leadingZeros: !0, decimalPoint: '.', eNotation: !0 }
	function iQ(e, t = {}) {
		if (((t = Object.assign({}, nQ, t)), !e || typeof e != 'string')) return e
		let r = e.trim()
		if (t.skipLike !== void 0 && t.skipLike.test(r)) return e
		if (t.hex && tQ.test(r)) return Number.parseInt(r, 16)
		{
			let n = rQ.exec(r)
			if (n) {
				let i = n[1],
					o = n[2],
					s = oQ(n[3]),
					c = n[4] || n[6]
				if (!t.leadingZeros && o.length > 0 && i && r[2] !== '.') return e
				if (!t.leadingZeros && o.length > 0 && !i && r[1] !== '.') return e
				{
					let l = Number(r),
						u = '' + l
					return u.search(/[eE]/) !== -1 || c
						? t.eNotation
							? l
							: e
						: r.indexOf('.') !== -1
							? (u === '0' && s === '') || u === s || (i && u === '-' + s)
								? l
								: e
							: o
								? s === u || i + s === u
									? l
									: e
								: r === u || r === i + u
									? l
									: e
				}
			} else return e
		}
	}
	function oQ(e) {
		return (
			e &&
				e.indexOf('.') !== -1 &&
				((e = e.replace(/0+$/, '')),
				e === '.'
					? (e = '0')
					: e[0] === '.'
						? (e = '0' + e)
						: e[e.length - 1] === '.' && (e = e.substr(0, e.length - 1))),
			e
		)
	}
	PR.exports = iQ
})
var kR = E((Yke, RR) => {
	'use strict'
	var OR = Tu(),
		Qc = bR(),
		sQ = xR(),
		aQ = AR(),
		oh = class {
			constructor(t) {
				;(this.options = t),
					(this.currentNode = null),
					(this.tagsNodeStack = []),
					(this.docTypeEntities = {}),
					(this.lastEntities = {
						apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
						gt: { regex: /&(gt|#62|#x3E);/g, val: '>' },
						lt: { regex: /&(lt|#60|#x3C);/g, val: '<' },
						quot: { regex: /&(quot|#34|#x22);/g, val: '"' },
					}),
					(this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: '&' }),
					(this.htmlEntities = {
						space: { regex: /&(nbsp|#160);/g, val: ' ' },
						cent: { regex: /&(cent|#162);/g, val: '\xA2' },
						pound: { regex: /&(pound|#163);/g, val: '\xA3' },
						yen: { regex: /&(yen|#165);/g, val: '\xA5' },
						euro: { regex: /&(euro|#8364);/g, val: '\u20AC' },
						copyright: { regex: /&(copy|#169);/g, val: '\xA9' },
						reg: { regex: /&(reg|#174);/g, val: '\xAE' },
						inr: { regex: /&(inr|#8377);/g, val: '\u20B9' },
						num_dec: {
							regex: /&#([0-9]{1,7});/g,
							val: (r, n) => String.fromCharCode(Number.parseInt(n, 10)),
						},
						num_hex: {
							regex: /&#x([0-9a-fA-F]{1,6});/g,
							val: (r, n) => String.fromCharCode(Number.parseInt(n, 16)),
						},
					}),
					(this.addExternalEntities = cQ),
					(this.parseXml = fQ),
					(this.parseTextData = lQ),
					(this.resolveNameSpace = dQ),
					(this.buildAttributesMap = mQ),
					(this.isItStopNode = hQ),
					(this.replaceEntitiesValue = gQ),
					(this.readStopNodeData = yQ),
					(this.saveTextToParentTag = vQ),
					(this.addChild = pQ)
			}
		}
	function cQ(e) {
		let t = Object.keys(e)
		for (let r = 0; r < t.length; r++) {
			let n = t[r]
			this.lastEntities[n] = {
				regex: new RegExp('&' + n + ';', 'g'),
				val: e[n],
			}
		}
	}
	function lQ(e, t, r, n, i, o, s) {
		if (
			e !== void 0 &&
			(this.options.trimValues && !n && (e = e.trim()), e.length > 0)
		) {
			s || (e = this.replaceEntitiesValue(e))
			let c = this.options.tagValueProcessor(t, e, r, i, o)
			return c == null
				? e
				: typeof c != typeof e || c !== e
					? c
					: this.options.trimValues
						? ah(e, this.options.parseTagValue, this.options.numberParseOptions)
						: e.trim() === e
							? ah(
									e,
									this.options.parseTagValue,
									this.options.numberParseOptions,
								)
							: e
		}
	}
	function dQ(e) {
		if (this.options.removeNSPrefix) {
			let t = e.split(':'),
				r = e.charAt(0) === '/' ? '/' : ''
			if (t[0] === 'xmlns') return ''
			t.length === 2 && (e = r + t[1])
		}
		return e
	}
	var uQ = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, 'gm')
	function mQ(e, t, r) {
		if (!this.options.ignoreAttributes && typeof e == 'string') {
			let n = OR.getAllMatches(e, uQ),
				i = n.length,
				o = {}
			for (let s = 0; s < i; s++) {
				let c = this.resolveNameSpace(n[s][1]),
					l = n[s][4],
					u = this.options.attributeNamePrefix + c
				if (c.length)
					if (
						(this.options.transformAttributeName &&
							(u = this.options.transformAttributeName(u)),
						u === '__proto__' && (u = '#__proto__'),
						l !== void 0)
					) {
						this.options.trimValues && (l = l.trim()),
							(l = this.replaceEntitiesValue(l))
						let m = this.options.attributeValueProcessor(c, l, t)
						m == null
							? (o[u] = l)
							: typeof m != typeof l || m !== l
								? (o[u] = m)
								: (o[u] = ah(
										l,
										this.options.parseAttributeValue,
										this.options.numberParseOptions,
									))
					} else this.options.allowBooleanAttributes && (o[u] = !0)
			}
			if (!Object.keys(o).length) return
			if (this.options.attributesGroupName) {
				let s = {}
				return (s[this.options.attributesGroupName] = o), s
			}
			return o
		}
	}
	var fQ = function (e) {
		e = e.replace(
			/\r\n?/g,
			`
`,
		)
		let t = new Qc('!xml'),
			r = t,
			n = '',
			i = ''
		for (let o = 0; o < e.length; o++)
			if (e[o] === '<')
				if (e[o + 1] === '/') {
					let c = _o(e, '>', o, 'Closing Tag is not closed.'),
						l = e.substring(o + 2, c).trim()
					if (this.options.removeNSPrefix) {
						let f = l.indexOf(':')
						f !== -1 && (l = l.substr(f + 1))
					}
					this.options.transformTagName &&
						(l = this.options.transformTagName(l)),
						r && (n = this.saveTextToParentTag(n, r, i))
					let u = i.substring(i.lastIndexOf('.') + 1)
					if (l && this.options.unpairedTags.indexOf(l) !== -1)
						throw new Error(
							`Unpaired tag can not be used as closing tag: </${l}>`,
						)
					let m = 0
					u && this.options.unpairedTags.indexOf(u) !== -1
						? ((m = i.lastIndexOf('.', i.lastIndexOf('.') - 1)),
							this.tagsNodeStack.pop())
						: (m = i.lastIndexOf('.')),
						(i = i.substring(0, m)),
						(r = this.tagsNodeStack.pop()),
						(n = ''),
						(o = c)
				} else if (e[o + 1] === '?') {
					let c = sh(e, o, !1, '?>')
					if (!c) throw new Error('Pi Tag is not closed.')
					if (
						((n = this.saveTextToParentTag(n, r, i)),
						!(
							(this.options.ignoreDeclaration && c.tagName === '?xml') ||
							this.options.ignorePiTags
						))
					) {
						let l = new Qc(c.tagName)
						l.add(this.options.textNodeName, ''),
							c.tagName !== c.tagExp &&
								c.attrExpPresent &&
								(l[':@'] = this.buildAttributesMap(c.tagExp, i, c.tagName)),
							this.addChild(r, l, i)
					}
					o = c.closeIndex + 1
				} else if (e.substr(o + 1, 3) === '!--') {
					let c = _o(e, '-->', o + 4, 'Comment is not closed.')
					if (this.options.commentPropName) {
						let l = e.substring(o + 4, c - 2)
						;(n = this.saveTextToParentTag(n, r, i)),
							r.add(this.options.commentPropName, [
								{ [this.options.textNodeName]: l },
							])
					}
					o = c
				} else if (e.substr(o + 1, 2) === '!D') {
					let c = sQ(e, o)
					;(this.docTypeEntities = c.entities), (o = c.i)
				} else if (e.substr(o + 1, 2) === '![') {
					let c = _o(e, ']]>', o, 'CDATA is not closed.') - 2,
						l = e.substring(o + 9, c)
					n = this.saveTextToParentTag(n, r, i)
					let u = this.parseTextData(l, r.tagname, i, !0, !1, !0, !0)
					u == null && (u = ''),
						this.options.cdataPropName
							? r.add(this.options.cdataPropName, [
									{ [this.options.textNodeName]: l },
								])
							: r.add(this.options.textNodeName, u),
						(o = c + 2)
				} else {
					let c = sh(e, o, this.options.removeNSPrefix),
						l = c.tagName,
						u = c.rawTagName,
						m = c.tagExp,
						f = c.attrExpPresent,
						p = c.closeIndex
					this.options.transformTagName &&
						(l = this.options.transformTagName(l)),
						r &&
							n &&
							r.tagname !== '!xml' &&
							(n = this.saveTextToParentTag(n, r, i, !1))
					let g = r
					if (
						(g &&
							this.options.unpairedTags.indexOf(g.tagname) !== -1 &&
							((r = this.tagsNodeStack.pop()),
							(i = i.substring(0, i.lastIndexOf('.')))),
						l !== t.tagname && (i += i ? '.' + l : l),
						this.isItStopNode(this.options.stopNodes, i, l))
					) {
						let v = ''
						if (m.length > 0 && m.lastIndexOf('/') === m.length - 1)
							l[l.length - 1] === '/'
								? ((l = l.substr(0, l.length - 1)),
									(i = i.substr(0, i.length - 1)),
									(m = l))
								: (m = m.substr(0, m.length - 1)),
								(o = c.closeIndex)
						else if (this.options.unpairedTags.indexOf(l) !== -1)
							o = c.closeIndex
						else {
							let y = this.readStopNodeData(e, u, p + 1)
							if (!y) throw new Error(`Unexpected end of ${u}`)
							;(o = y.i), (v = y.tagContent)
						}
						let _ = new Qc(l)
						l !== m && f && (_[':@'] = this.buildAttributesMap(m, i, l)),
							v && (v = this.parseTextData(v, l, i, !0, f, !0, !0)),
							(i = i.substr(0, i.lastIndexOf('.'))),
							_.add(this.options.textNodeName, v),
							this.addChild(r, _, i)
					} else {
						if (m.length > 0 && m.lastIndexOf('/') === m.length - 1) {
							l[l.length - 1] === '/'
								? ((l = l.substr(0, l.length - 1)),
									(i = i.substr(0, i.length - 1)),
									(m = l))
								: (m = m.substr(0, m.length - 1)),
								this.options.transformTagName &&
									(l = this.options.transformTagName(l))
							let v = new Qc(l)
							l !== m && f && (v[':@'] = this.buildAttributesMap(m, i, l)),
								this.addChild(r, v, i),
								(i = i.substr(0, i.lastIndexOf('.')))
						} else {
							let v = new Qc(l)
							this.tagsNodeStack.push(r),
								l !== m && f && (v[':@'] = this.buildAttributesMap(m, i, l)),
								this.addChild(r, v, i),
								(r = v)
						}
						;(n = ''), (o = p)
					}
				}
			else n += e[o]
		return t.child
	}
	function pQ(e, t, r) {
		let n = this.options.updateTag(t.tagname, r, t[':@'])
		n === !1 || (typeof n == 'string' && (t.tagname = n), e.addChild(t))
	}
	var gQ = function (e) {
		if (this.options.processEntities) {
			for (let t in this.docTypeEntities) {
				let r = this.docTypeEntities[t]
				e = e.replace(r.regx, r.val)
			}
			for (let t in this.lastEntities) {
				let r = this.lastEntities[t]
				e = e.replace(r.regex, r.val)
			}
			if (this.options.htmlEntities)
				for (let t in this.htmlEntities) {
					let r = this.htmlEntities[t]
					e = e.replace(r.regex, r.val)
				}
			e = e.replace(this.ampEntity.regex, this.ampEntity.val)
		}
		return e
	}
	function vQ(e, t, r, n) {
		return (
			e &&
				(n === void 0 && (n = Object.keys(t.child).length === 0),
				(e = this.parseTextData(
					e,
					t.tagname,
					r,
					!1,
					t[':@'] ? Object.keys(t[':@']).length !== 0 : !1,
					n,
				)),
				e !== void 0 && e !== '' && t.add(this.options.textNodeName, e),
				(e = '')),
			e
		)
	}
	function hQ(e, t, r) {
		let n = '*.' + r
		for (let i in e) {
			let o = e[i]
			if (n === o || t === o) return !0
		}
		return !1
	}
	function _Q(e, t, r = '>') {
		let n,
			i = ''
		for (let o = t; o < e.length; o++) {
			let s = e[o]
			if (n) s === n && (n = '')
			else if (s === '"' || s === "'") n = s
			else if (s === r[0])
				if (r[1]) {
					if (e[o + 1] === r[1]) return { data: i, index: o }
				} else return { data: i, index: o }
			else s === '	' && (s = ' ')
			i += s
		}
	}
	function _o(e, t, r, n) {
		let i = e.indexOf(t, r)
		if (i === -1) throw new Error(n)
		return i + t.length - 1
	}
	function sh(e, t, r, n = '>') {
		let i = _Q(e, t + 1, n)
		if (!i) return
		let o = i.data,
			s = i.index,
			c = o.search(/\s/),
			l = o,
			u = !0
		c !== -1 && ((l = o.substring(0, c)), (o = o.substring(c + 1).trimStart()))
		let m = l
		if (r) {
			let f = l.indexOf(':')
			f !== -1 && ((l = l.substr(f + 1)), (u = l !== i.data.substr(f + 1)))
		}
		return {
			tagName: l,
			tagExp: o,
			closeIndex: s,
			attrExpPresent: u,
			rawTagName: m,
		}
	}
	function yQ(e, t, r) {
		let n = r,
			i = 1
		for (; r < e.length; r++)
			if (e[r] === '<')
				if (e[r + 1] === '/') {
					let o = _o(e, '>', r, `${t} is not closed`)
					if (e.substring(r + 2, o).trim() === t && (i--, i === 0))
						return { tagContent: e.substring(n, r), i: o }
					r = o
				} else if (e[r + 1] === '?')
					r = _o(e, '?>', r + 1, 'StopNode is not closed.')
				else if (e.substr(r + 1, 3) === '!--')
					r = _o(e, '-->', r + 3, 'StopNode is not closed.')
				else if (e.substr(r + 1, 2) === '![')
					r = _o(e, ']]>', r, 'StopNode is not closed.') - 2
				else {
					let o = sh(e, r, '>')
					o &&
						((o && o.tagName) === t &&
							o.tagExp[o.tagExp.length - 1] !== '/' &&
							i++,
						(r = o.closeIndex))
				}
	}
	function ah(e, t, r) {
		if (t && typeof e == 'string') {
			let n = e.trim()
			return n === 'true' ? !0 : n === 'false' ? !1 : aQ(e, r)
		} else return OR.isExist(e) ? e : ''
	}
	RR.exports = oh
})
var BR = E((TR) => {
	'use strict'
	function SQ(e, t) {
		return IR(e, t)
	}
	function IR(e, t, r) {
		let n,
			i = {}
		for (let o = 0; o < e.length; o++) {
			let s = e[o],
				c = CQ(s),
				l = ''
			if ((r === void 0 ? (l = c) : (l = r + '.' + c), c === t.textNodeName))
				n === void 0 ? (n = s[c]) : (n += '' + s[c])
			else {
				if (c === void 0) continue
				if (s[c]) {
					let u = IR(s[c], t, l),
						m = bQ(u, t)
					s[':@']
						? EQ(u, s[':@'], l, t)
						: Object.keys(u).length === 1 &&
								u[t.textNodeName] !== void 0 &&
								!t.alwaysCreateTextNode
							? (u = u[t.textNodeName])
							: Object.keys(u).length === 0 &&
								(t.alwaysCreateTextNode ? (u[t.textNodeName] = '') : (u = '')),
						i[c] !== void 0 && i.hasOwnProperty(c)
							? (Array.isArray(i[c]) || (i[c] = [i[c]]), i[c].push(u))
							: t.isArray(c, l, m)
								? (i[c] = [u])
								: (i[c] = u)
				}
			}
		}
		return (
			typeof n == 'string'
				? n.length > 0 && (i[t.textNodeName] = n)
				: n !== void 0 && (i[t.textNodeName] = n),
			i
		)
	}
	function CQ(e) {
		let t = Object.keys(e)
		for (let r = 0; r < t.length; r++) {
			let n = t[r]
			if (n !== ':@') return n
		}
	}
	function EQ(e, t, r, n) {
		if (t) {
			let i = Object.keys(t),
				o = i.length
			for (let s = 0; s < o; s++) {
				let c = i[s]
				n.isArray(c, r + '.' + c, !0, !0) ? (e[c] = [t[c]]) : (e[c] = t[c])
			}
		}
	}
	function bQ(e, t) {
		let { textNodeName: r } = t,
			n = Object.keys(e).length
		return !!(
			n === 0 ||
			(n === 1 && (e[r] || typeof e[r] == 'boolean' || e[r] === 0))
		)
	}
	TR.prettify = SQ
})
var DR = E((Qke, NR) => {
	var { buildOptions: wQ } = CR(),
		xQ = kR(),
		{ prettify: PQ } = BR(),
		AQ = rh(),
		ch = class {
			constructor(t) {
				;(this.externalEntities = {}), (this.options = wQ(t))
			}
			parse(t, r) {
				if (typeof t != 'string')
					if (t.toString) t = t.toString()
					else
						throw new Error('XML data is accepted in String or Bytes[] form.')
				if (r) {
					r === !0 && (r = {})
					let o = AQ.validate(t, r)
					if (o !== !0) throw Error(`${o.err.msg}:${o.err.line}:${o.err.col}`)
				}
				let n = new xQ(this.options)
				n.addExternalEntities(this.externalEntities)
				let i = n.parseXml(t)
				return this.options.preserveOrder || i === void 0
					? i
					: PQ(i, this.options)
			}
			addEntity(t, r) {
				if (r.indexOf('&') !== -1)
					throw new Error("Entity value can't have '&'")
				if (t.indexOf('&') !== -1 || t.indexOf(';') !== -1)
					throw new Error(
						"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'",
					)
				if (r === '&')
					throw new Error("An entity with value '&' is not permitted")
				this.externalEntities[t] = r
			}
		}
	NR.exports = ch
})
var jR = E((Zke, qR) => {
	var OQ = `
`
	function RQ(e, t) {
		let r = ''
		return t.format && t.indentBy.length > 0 && (r = OQ), FR(e, t, '', r)
	}
	function FR(e, t, r, n) {
		let i = '',
			o = !1
		for (let s = 0; s < e.length; s++) {
			let c = e[s],
				l = kQ(c)
			if (l === void 0) continue
			let u = ''
			if (
				(r.length === 0 ? (u = l) : (u = `${r}.${l}`), l === t.textNodeName)
			) {
				let v = c[l]
				IQ(u, t) || ((v = t.tagValueProcessor(l, v)), (v = MR(v, t))),
					o && (i += n),
					(i += v),
					(o = !1)
				continue
			} else if (l === t.cdataPropName) {
				o && (i += n), (i += `<![CDATA[${c[l][0][t.textNodeName]}]]>`), (o = !1)
				continue
			} else if (l === t.commentPropName) {
				;(i += n + `<!--${c[l][0][t.textNodeName]}-->`), (o = !0)
				continue
			} else if (l[0] === '?') {
				let v = LR(c[':@'], t),
					_ = l === '?xml' ? '' : n,
					y = c[l][0][t.textNodeName]
				;(y = y.length !== 0 ? ' ' + y : ''),
					(i += _ + `<${l}${y}${v}?>`),
					(o = !0)
				continue
			}
			let m = n
			m !== '' && (m += t.indentBy)
			let f = LR(c[':@'], t),
				p = n + `<${l}${f}`,
				g = FR(c[l], t, u, m)
			t.unpairedTags.indexOf(l) !== -1
				? t.suppressUnpairedNode
					? (i += p + '>')
					: (i += p + '/>')
				: (!g || g.length === 0) && t.suppressEmptyNode
					? (i += p + '/>')
					: g && g.endsWith('>')
						? (i += p + `>${g}${n}</${l}>`)
						: ((i += p + '>'),
							g && n !== '' && (g.includes('/>') || g.includes('</'))
								? (i += n + t.indentBy + g + n)
								: (i += g),
							(i += `</${l}>`)),
				(o = !0)
		}
		return i
	}
	function kQ(e) {
		let t = Object.keys(e)
		for (let r = 0; r < t.length; r++) {
			let n = t[r]
			if (e.hasOwnProperty(n) && n !== ':@') return n
		}
	}
	function LR(e, t) {
		let r = ''
		if (e && !t.ignoreAttributes)
			for (let n in e) {
				if (!e.hasOwnProperty(n)) continue
				let i = t.attributeValueProcessor(n, e[n])
				;(i = MR(i, t)),
					i === !0 && t.suppressBooleanAttributes
						? (r += ` ${n.substr(t.attributeNamePrefix.length)}`)
						: (r += ` ${n.substr(t.attributeNamePrefix.length)}="${i}"`)
			}
		return r
	}
	function IQ(e, t) {
		e = e.substr(0, e.length - t.textNodeName.length - 1)
		let r = e.substr(e.lastIndexOf('.') + 1)
		for (let n in t.stopNodes)
			if (t.stopNodes[n] === e || t.stopNodes[n] === '*.' + r) return !0
		return !1
	}
	function MR(e, t) {
		if (e && e.length > 0 && t.processEntities)
			for (let r = 0; r < t.entities.length; r++) {
				let n = t.entities[r]
				e = e.replace(n.regex, n.val)
			}
		return e
	}
	qR.exports = RQ
})
var GR = E((eIe, UR) => {
	'use strict'
	var TQ = jR(),
		BQ = {
			attributeNamePrefix: '@_',
			attributesGroupName: !1,
			textNodeName: '#text',
			ignoreAttributes: !0,
			cdataPropName: !1,
			format: !1,
			indentBy: '  ',
			suppressEmptyNode: !1,
			suppressUnpairedNode: !0,
			suppressBooleanAttributes: !0,
			tagValueProcessor: function (e, t) {
				return t
			},
			attributeValueProcessor: function (e, t) {
				return t
			},
			preserveOrder: !1,
			commentPropName: !1,
			unpairedTags: [],
			entities: [
				{ regex: new RegExp('&', 'g'), val: '&amp;' },
				{ regex: new RegExp('>', 'g'), val: '&gt;' },
				{ regex: new RegExp('<', 'g'), val: '&lt;' },
				{ regex: new RegExp("'", 'g'), val: '&apos;' },
				{ regex: new RegExp('"', 'g'), val: '&quot;' },
			],
			processEntities: !0,
			stopNodes: [],
			oneListGroup: !1,
		}
	function Ei(e) {
		;(this.options = Object.assign({}, BQ, e)),
			this.options.ignoreAttributes || this.options.attributesGroupName
				? (this.isAttribute = function () {
						return !1
					})
				: ((this.attrPrefixLen = this.options.attributeNamePrefix.length),
					(this.isAttribute = LQ)),
			(this.processTextOrObjNode = NQ),
			this.options.format
				? ((this.indentate = DQ),
					(this.tagEndChar = `>
`),
					(this.newLine = `
`))
				: ((this.indentate = function () {
						return ''
					}),
					(this.tagEndChar = '>'),
					(this.newLine = ''))
	}
	Ei.prototype.build = function (e) {
		return this.options.preserveOrder
			? TQ(e, this.options)
			: (Array.isArray(e) &&
					this.options.arrayNodeName &&
					this.options.arrayNodeName.length > 1 &&
					(e = { [this.options.arrayNodeName]: e }),
				this.j2x(e, 0).val)
	}
	Ei.prototype.j2x = function (e, t) {
		let r = '',
			n = ''
		for (let i in e)
			if (Object.prototype.hasOwnProperty.call(e, i))
				if (typeof e[i] > 'u') this.isAttribute(i) && (n += '')
				else if (e[i] === null)
					this.isAttribute(i)
						? (n += '')
						: i[0] === '?'
							? (n += this.indentate(t) + '<' + i + '?' + this.tagEndChar)
							: (n += this.indentate(t) + '<' + i + '/' + this.tagEndChar)
				else if (e[i] instanceof Date)
					n += this.buildTextValNode(e[i], i, '', t)
				else if (typeof e[i] != 'object') {
					let o = this.isAttribute(i)
					if (o) r += this.buildAttrPairStr(o, '' + e[i])
					else if (i === this.options.textNodeName) {
						let s = this.options.tagValueProcessor(i, '' + e[i])
						n += this.replaceEntitiesValue(s)
					} else n += this.buildTextValNode(e[i], i, '', t)
				} else if (Array.isArray(e[i])) {
					let o = e[i].length,
						s = '',
						c = ''
					for (let l = 0; l < o; l++) {
						let u = e[i][l]
						if (!(typeof u > 'u'))
							if (u === null)
								i[0] === '?'
									? (n += this.indentate(t) + '<' + i + '?' + this.tagEndChar)
									: (n += this.indentate(t) + '<' + i + '/' + this.tagEndChar)
							else if (typeof u == 'object')
								if (this.options.oneListGroup) {
									let m = this.j2x(u, t + 1)
									;(s += m.val),
										this.options.attributesGroupName &&
											u.hasOwnProperty(this.options.attributesGroupName) &&
											(c += m.attrStr)
								} else s += this.processTextOrObjNode(u, i, t)
							else if (this.options.oneListGroup) {
								let m = this.options.tagValueProcessor(i, u)
								;(m = this.replaceEntitiesValue(m)), (s += m)
							} else s += this.buildTextValNode(u, i, '', t)
					}
					this.options.oneListGroup && (s = this.buildObjectNode(s, i, c, t)),
						(n += s)
				} else if (
					this.options.attributesGroupName &&
					i === this.options.attributesGroupName
				) {
					let o = Object.keys(e[i]),
						s = o.length
					for (let c = 0; c < s; c++)
						r += this.buildAttrPairStr(o[c], '' + e[i][o[c]])
				} else n += this.processTextOrObjNode(e[i], i, t)
		return { attrStr: r, val: n }
	}
	Ei.prototype.buildAttrPairStr = function (e, t) {
		return (
			(t = this.options.attributeValueProcessor(e, '' + t)),
			(t = this.replaceEntitiesValue(t)),
			this.options.suppressBooleanAttributes && t === 'true'
				? ' ' + e
				: ' ' + e + '="' + t + '"'
		)
	}
	function NQ(e, t, r) {
		let n = this.j2x(e, r + 1)
		return e[this.options.textNodeName] !== void 0 &&
			Object.keys(e).length === 1
			? this.buildTextValNode(e[this.options.textNodeName], t, n.attrStr, r)
			: this.buildObjectNode(n.val, t, n.attrStr, r)
	}
	Ei.prototype.buildObjectNode = function (e, t, r, n) {
		if (e === '')
			return t[0] === '?'
				? this.indentate(n) + '<' + t + r + '?' + this.tagEndChar
				: this.indentate(n) + '<' + t + r + this.closeTag(t) + this.tagEndChar
		{
			let i = '</' + t + this.tagEndChar,
				o = ''
			return (
				t[0] === '?' && ((o = '?'), (i = '')),
				(r || r === '') && e.indexOf('<') === -1
					? this.indentate(n) + '<' + t + r + o + '>' + e + i
					: this.options.commentPropName !== !1 &&
							t === this.options.commentPropName &&
							o.length === 0
						? this.indentate(n) + `<!--${e}-->` + this.newLine
						: this.indentate(n) +
							'<' +
							t +
							r +
							o +
							this.tagEndChar +
							e +
							this.indentate(n) +
							i
			)
		}
	}
	Ei.prototype.closeTag = function (e) {
		let t = ''
		return (
			this.options.unpairedTags.indexOf(e) !== -1
				? this.options.suppressUnpairedNode || (t = '/')
				: this.options.suppressEmptyNode
					? (t = '/')
					: (t = `></${e}`),
			t
		)
	}
	Ei.prototype.buildTextValNode = function (e, t, r, n) {
		if (this.options.cdataPropName !== !1 && t === this.options.cdataPropName)
			return this.indentate(n) + `<![CDATA[${e}]]>` + this.newLine
		if (
			this.options.commentPropName !== !1 &&
			t === this.options.commentPropName
		)
			return this.indentate(n) + `<!--${e}-->` + this.newLine
		if (t[0] === '?')
			return this.indentate(n) + '<' + t + r + '?' + this.tagEndChar
		{
			let i = this.options.tagValueProcessor(t, e)
			return (
				(i = this.replaceEntitiesValue(i)),
				i === ''
					? this.indentate(n) + '<' + t + r + this.closeTag(t) + this.tagEndChar
					: this.indentate(n) +
						'<' +
						t +
						r +
						'>' +
						i +
						'</' +
						t +
						this.tagEndChar
			)
		}
	}
	Ei.prototype.replaceEntitiesValue = function (e) {
		if (e && e.length > 0 && this.options.processEntities)
			for (let t = 0; t < this.options.entities.length; t++) {
				let r = this.options.entities[t]
				e = e.replace(r.regex, r.val)
			}
		return e
	}
	function DQ(e) {
		return this.options.indentBy.repeat(e)
	}
	function LQ(e) {
		return e.startsWith(this.options.attributeNamePrefix) &&
			e !== this.options.textNodeName
			? e.substr(this.attrPrefixLen)
			: !1
	}
	UR.exports = Ei
})
var HR = E((tIe, zR) => {
	'use strict'
	var FQ = rh(),
		MQ = DR(),
		qQ = GR()
	zR.exports = { XMLParser: MQ, XMLValidator: FQ, XMLBuilder: qQ }
})
var $R,
	VR,
	KR,
	jQ,
	UQ,
	WR = oe(() => {
		;($R = Oe(ze())), (VR = Oe(HR()))
		eh()
		;(KR = (e, t) =>
			Iu(e, t).then((r) => {
				if (r.length) {
					let n = new VR.XMLParser({
						attributeNamePrefix: '',
						htmlEntities: !0,
						ignoreAttributes: !1,
						ignoreDeclaration: !0,
						parseTagValue: !1,
						trimValues: !1,
						tagValueProcessor: (l, u) =>
							u.trim() === '' &&
							u.includes(`
`)
								? ''
								: void 0,
					})
					n.addEntity('#xD', '\r'),
						n.addEntity(
							'#10',
							`
`,
						)
					let i
					try {
						i = n.parse(r, !0)
					} catch (l) {
						throw (
							(l &&
								typeof l == 'object' &&
								Object.defineProperty(l, '$responseBodyText', { value: r }),
							l)
						)
					}
					let o = '#text',
						s = Object.keys(i)[0],
						c = i[s]
					return (
						c[o] && ((c[s] = c[o]), delete c[o]),
						(0, $R.getValueFromTextNode)(c)
					)
				}
				return {}
			})),
			(jQ = async (e, t) => {
				let r = await KR(e, t)
				return (
					r.Error && (r.Error.message = r.Error.message ?? r.Error.Message), r
				)
			}),
			(UQ = (e, t) => {
				if (t?.Error?.Code !== void 0) return t.Error.Code
				if (t?.Code !== void 0) return t.Code
				if (e.statusCode == 404) return 'NotFound'
			})
	})
var XR = oe(() => {
	aR()
	lR()
	mR()
	WR()
})
var Gt = {}
Sc(Gt, {
	AWSSDKSigV4Signer: () => ZO,
	AwsSdkSigV4ASigner: () => ku,
	AwsSdkSigV4Signer: () => ho,
	NODE_SIGV4A_CONFIG_OPTIONS: () => wJ,
	_toBool: () => AJ,
	_toNum: () => OJ,
	_toStr: () => PJ,
	awsExpectUnion: () => RJ,
	emitWarningIfUnsupportedVersion: () => EJ,
	loadRestJsonErrorCode: () => IJ,
	loadRestXmlErrorCode: () => UQ,
	parseJsonBody: () => uR,
	parseJsonErrorBody: () => kJ,
	parseXmlBody: () => KR,
	parseXmlErrorBody: () => jQ,
	resolveAWSSDKSigV4Config: () => xJ,
	resolveAwsSdkSigV4AConfig: () => bJ,
	resolveAwsSdkSigV4Config: () => nR,
	validateSigningProperties: () => Yc,
})
var zt = oe(() => {
	VO()
	sR()
	XR()
})
var lh = E((fIe, ZR) => {
	'use strict'
	var Bu = Object.defineProperty,
		GQ = Object.getOwnPropertyDescriptor,
		zQ = Object.getOwnPropertyNames,
		HQ = Object.prototype.hasOwnProperty,
		$Q = (e, t) => Bu(e, 'name', { value: t, configurable: !0 }),
		VQ = (e, t) => {
			for (var r in t) Bu(e, r, { get: t[r], enumerable: !0 })
		},
		KQ = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of zQ(t))
					!HQ.call(e, i) &&
						i !== r &&
						Bu(e, i, {
							get: () => t[i],
							enumerable: !(n = GQ(t, i)) || n.enumerable,
						})
			return e
		},
		WQ = (e) => KQ(Bu({}, '__esModule', { value: !0 }), e),
		YR = {}
	VQ(YR, {
		SignatureV4MultiRegion: () => YQ,
		signatureV4CrtContainer: () => JR,
	})
	ZR.exports = WQ(YR)
	var XQ = re(),
		JR = { CrtSignerV4: null },
		QR = class {
			constructor(t) {
				;(this.sigv4Signer = new XQ.SignatureV4S3Express(t)),
					(this.signerOptions = t)
			}
			async sign(t, r = {}) {
				if (r.signingRegion === '*') {
					if (this.signerOptions.runtime !== 'node')
						throw new Error(
							"This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js",
						)
					return this.getSigv4aSigner().sign(t, r)
				}
				return this.sigv4Signer.sign(t, r)
			}
			async signWithCredentials(t, r, n = {}) {
				if (n.signingRegion === '*') {
					if (this.signerOptions.runtime !== 'node')
						throw new Error(
							"This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js",
						)
					return this.getSigv4aSigner().signWithCredentials(t, r, n)
				}
				return this.sigv4Signer.signWithCredentials(t, r, n)
			}
			async presign(t, r = {}) {
				if (r.signingRegion === '*') {
					if (this.signerOptions.runtime !== 'node')
						throw new Error(
							"This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js",
						)
					return this.getSigv4aSigner().presign(t, r)
				}
				return this.sigv4Signer.presign(t, r)
			}
			async presignWithCredentials(t, r, n = {}) {
				if (n.signingRegion === '*')
					throw new Error(
						'Method presignWithCredentials is not supported for [signingRegion=*].',
					)
				return this.sigv4Signer.presignWithCredentials(t, r, n)
			}
			getSigv4aSigner() {
				if (!this.sigv4aSigner) {
					let t = null
					try {
						if (((t = JR.CrtSignerV4), typeof t != 'function'))
							throw new Error()
					} catch (r) {
						throw (
							((r.message = `${r.message}
Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`),
							r)
						)
					}
					this.sigv4aSigner = new t({
						...this.signerOptions,
						signingAlgorithm: 1,
					})
				}
				return this.sigv4aSigner
			}
		}
	$Q(QR, 'SignatureV4MultiRegion')
	var YQ = QR
})
var yI = E((Hu) => {
	'use strict'
	Object.defineProperty(Hu, '__esModule', { value: !0 })
	Hu.ruleSet = void 0
	var Dh = 'required',
		h = 'type',
		C = 'conditions',
		B = 'fn',
		N = 'argv',
		ue = 'ref',
		mt = 'assign',
		Q = 'url',
		Z = 'properties',
		eI = 'backend',
		an = 'authSchemes',
		xr = 'disableDoubleEncoding',
		Pr = 'signingName',
		An = 'signingRegion',
		ee = 'headers',
		Lh = 'signingRegionSet',
		JQ = !1,
		on = !0,
		Nr = 'isSet',
		Dt = 'booleanEquals',
		te = 'error',
		ju = 'aws.partition',
		et = 'stringEquals',
		ht = 'getAttr',
		Wt = 'name',
		xn = 'substring',
		ek = 'bucketSuffix',
		tI = 'parseURL',
		tk = '{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}',
		M = 'endpoint',
		L = 'tree',
		rI = 'aws.isVirtualHostableS3Bucket',
		Fu = '{url#scheme}://{Bucket}.{url#authority}{url#path}',
		Pn = 'not',
		Mu = '{url#scheme}://{url#authority}{url#path}',
		nI = 'hardwareType',
		iI = 'regionPrefix',
		rk = 'bucketAliasSuffix',
		Bh = 'outpostId',
		So = 'isValidHostLabel',
		Fh = 'sigv4a',
		tl = 's3-outposts',
		Ms = 's3',
		oI = '{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}',
		sI = 'https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}',
		nk = 'https://{Bucket}.s3.{partitionResult#dnsSuffix}',
		aI = 'aws.parseArn',
		cI = 'bucketArn',
		lI = 'arnType',
		Uu = '',
		Mh = 's3-object-lambda',
		dI = 'accesspoint',
		qh = 'accessPointName',
		ik =
			'{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}',
		ok = 'mrapPartition',
		sk = 'outpostType',
		ak = 'arnPrefix',
		uI =
			'{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}',
		ck = 'https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}',
		lk = 'https://s3.{partitionResult#dnsSuffix}',
		Ds = { [Dh]: !1, [h]: 'String' },
		Ls = { [Dh]: !0, default: !1, [h]: 'Boolean' },
		Zc = { [Dh]: !1, [h]: 'Boolean' },
		sn = { [B]: Dt, [N]: [{ [ue]: 'Accelerate' }, !0] },
		Qe = { [B]: Dt, [N]: [{ [ue]: 'UseFIPS' }, !0] },
		Je = { [B]: Dt, [N]: [{ [ue]: 'UseDualStack' }, !0] },
		St = { [B]: Nr, [N]: [{ [ue]: 'Endpoint' }] },
		mI = { [B]: ju, [N]: [{ [ue]: 'Region' }], [mt]: 'partitionResult' },
		dk = {
			[B]: et,
			[N]: [{ [B]: ht, [N]: [{ [ue]: 'partitionResult' }, Wt] }, 'aws-cn'],
		},
		Gu = { [B]: Nr, [N]: [{ [ue]: 'Bucket' }] },
		ar = { [ue]: 'Bucket' },
		sr = { [B]: tI, [N]: [{ [ue]: 'Endpoint' }], [mt]: 'url' },
		qu = { [B]: Dt, [N]: [{ [B]: ht, [N]: [{ [ue]: 'url' }, 'isIp'] }, !0] },
		fI = { [ue]: 'url' },
		pI = { [B]: 'uriEncode', [N]: [ar], [mt]: 'uri_encoded_bucket' },
		Wn = {
			[eI]: 'S3Express',
			[an]: [{ [xr]: !0, [Wt]: 'sigv4', [Pr]: 's3express', [An]: '{Region}' }],
		},
		fe = {},
		gI = { [B]: rI, [N]: [ar, !1] },
		dh = {
			[te]: 'S3Express bucket name is not a valid virtual hostable name.',
			[h]: te,
		},
		zu = {
			[eI]: 'S3Express',
			[an]: [
				{
					[xr]: !0,
					[Wt]: 'sigv4-s3express',
					[Pr]: 's3express',
					[An]: '{Region}',
				},
			],
		},
		uk = { [B]: Nr, [N]: [{ [ue]: 'UseS3ExpressControlEndpoint' }] },
		mk = { [B]: Dt, [N]: [{ [ue]: 'UseS3ExpressControlEndpoint' }, !0] },
		ge = { [B]: Pn, [N]: [St] },
		fk = { [te]: 'Unrecognized S3Express bucket name format.', [h]: te },
		pk = { [B]: Pn, [N]: [Gu] },
		gk = { [ue]: nI },
		vk = {
			[C]: [ge],
			[te]: 'Expected a endpoint to be specified but no endpoint was found',
			[h]: te,
		},
		Nu = {
			[an]: [
				{ [xr]: !0, [Wt]: Fh, [Pr]: tl, [Lh]: ['*'] },
				{ [xr]: !0, [Wt]: 'sigv4', [Pr]: tl, [An]: '{Region}' },
			],
		},
		uh = { [B]: Dt, [N]: [{ [ue]: 'ForcePathStyle' }, !1] },
		QQ = { [ue]: 'ForcePathStyle' },
		yt = { [B]: Dt, [N]: [{ [ue]: 'Accelerate' }, !1] },
		bt = { [B]: et, [N]: [{ [ue]: 'Region' }, 'aws-global'] },
		Tt = { [an]: [{ [xr]: !0, [Wt]: 'sigv4', [Pr]: Ms, [An]: 'us-east-1' }] },
		Re = { [B]: Pn, [N]: [bt] },
		Bt = { [B]: Dt, [N]: [{ [ue]: 'UseGlobalEndpoint' }, !0] },
		hk = {
			[Q]: 'https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}',
			[Z]: { [an]: [{ [xr]: !0, [Wt]: 'sigv4', [Pr]: Ms, [An]: '{Region}' }] },
			[ee]: {},
		},
		Ct = { [an]: [{ [xr]: !0, [Wt]: 'sigv4', [Pr]: Ms, [An]: '{Region}' }] },
		Nt = { [B]: Dt, [N]: [{ [ue]: 'UseGlobalEndpoint' }, !1] },
		we = { [B]: Dt, [N]: [{ [ue]: 'UseDualStack' }, !1] },
		_k = {
			[Q]: 'https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}',
			[Z]: Ct,
			[ee]: {},
		},
		ye = { [B]: Dt, [N]: [{ [ue]: 'UseFIPS' }, !1] },
		yk = {
			[Q]: 'https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}',
			[Z]: Ct,
			[ee]: {},
		},
		Sk = {
			[Q]: 'https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}',
			[Z]: Ct,
			[ee]: {},
		},
		mh = { [B]: Dt, [N]: [{ [B]: ht, [N]: [fI, 'isIp'] }, !1] },
		fh = { [Q]: oI, [Z]: Ct, [ee]: {} },
		Nh = { [Q]: Fu, [Z]: Ct, [ee]: {} },
		Ck = { [M]: Nh, [h]: M },
		ph = { [Q]: sI, [Z]: Ct, [ee]: {} },
		Ek = {
			[Q]: 'https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}',
			[Z]: Ct,
			[ee]: {},
		},
		Du = { [te]: 'Invalid region: region was not a valid DNS name.', [h]: te },
		_r = { [ue]: cI },
		vI = { [ue]: lI },
		gh = { [B]: ht, [N]: [_r, 'service'] },
		jh = { [ue]: qh },
		bk = {
			[C]: [Je],
			[te]: 'S3 Object Lambda does not support Dual-stack',
			[h]: te,
		},
		wk = {
			[C]: [sn],
			[te]: 'S3 Object Lambda does not support S3 Accelerate',
			[h]: te,
		},
		xk = {
			[C]: [
				{ [B]: Nr, [N]: [{ [ue]: 'DisableAccessPoints' }] },
				{ [B]: Dt, [N]: [{ [ue]: 'DisableAccessPoints' }, !0] },
			],
			[te]: 'Access points are not supported for this operation',
			[h]: te,
		},
		vh = {
			[C]: [
				{ [B]: Nr, [N]: [{ [ue]: 'UseArnRegion' }] },
				{ [B]: Dt, [N]: [{ [ue]: 'UseArnRegion' }, !1] },
				{
					[B]: Pn,
					[N]: [
						{ [B]: et, [N]: [{ [B]: ht, [N]: [_r, 'region'] }, '{Region}'] },
					],
				},
			],
			[te]: 'Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`',
			[h]: te,
		},
		hI = { [B]: ht, [N]: [{ [ue]: 'bucketPartition' }, Wt] },
		_I = { [B]: ht, [N]: [_r, 'accountId'] },
		hh = {
			[an]: [{ [xr]: !0, [Wt]: 'sigv4', [Pr]: Mh, [An]: '{bucketArn#region}' }],
		},
		Pk = {
			[te]: 'Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`',
			[h]: te,
		},
		_h = {
			[te]: 'Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`',
			[h]: te,
		},
		yh = {
			[te]: 'Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)',
			[h]: te,
		},
		Sh = {
			[te]: 'Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`',
			[h]: te,
		},
		Ak = {
			[te]: 'Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.',
			[h]: te,
		},
		Ok = {
			[te]: 'Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided',
			[h]: te,
		},
		el = {
			[an]: [{ [xr]: !0, [Wt]: 'sigv4', [Pr]: Ms, [An]: '{bucketArn#region}' }],
		},
		Rk = {
			[an]: [
				{ [xr]: !0, [Wt]: Fh, [Pr]: tl, [Lh]: ['*'] },
				{ [xr]: !0, [Wt]: 'sigv4', [Pr]: tl, [An]: '{bucketArn#region}' },
			],
		},
		kk = { [B]: aI, [N]: [ar] },
		Ik = {
			[Q]: 'https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}',
			[Z]: Ct,
			[ee]: {},
		},
		Tk = {
			[Q]: 'https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}',
			[Z]: Ct,
			[ee]: {},
		},
		Bk = {
			[Q]: 'https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}',
			[Z]: Ct,
			[ee]: {},
		},
		Ch = { [Q]: uI, [Z]: Ct, [ee]: {} },
		Nk = {
			[Q]: 'https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}',
			[Z]: Ct,
			[ee]: {},
		},
		Dk = { [ue]: 'UseObjectLambdaEndpoint' },
		Eh = { [an]: [{ [xr]: !0, [Wt]: 'sigv4', [Pr]: Mh, [An]: '{Region}' }] },
		Lk = {
			[Q]: 'https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}',
			[Z]: Ct,
			[ee]: {},
		},
		Fk = {
			[Q]: 'https://s3-fips.{Region}.{partitionResult#dnsSuffix}',
			[Z]: Ct,
			[ee]: {},
		},
		Mk = {
			[Q]: 'https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}',
			[Z]: Ct,
			[ee]: {},
		},
		bh = { [Q]: Mu, [Z]: Ct, [ee]: {} },
		qk = {
			[Q]: 'https://s3.{Region}.{partitionResult#dnsSuffix}',
			[Z]: Ct,
			[ee]: {},
		},
		wh = [{ [ue]: 'Region' }],
		ZQ = [{ [ue]: 'Endpoint' }],
		eZ = [ar],
		xh = [Je],
		Lu = [sn],
		yo = [St, sr],
		jk = [
			{ [B]: Nr, [N]: [{ [ue]: 'DisableS3ExpressSessionAuth' }] },
			{ [B]: Dt, [N]: [{ [ue]: 'DisableS3ExpressSessionAuth' }, !0] },
		],
		Uk = [qu],
		Ph = [pI],
		Ah = [gI],
		Fs = [Qe],
		Gk = [
			{ [B]: xn, [N]: [ar, 6, 14, !0], [mt]: 's3expressAvailabilityZoneId' },
			{
				[B]: xn,
				[N]: [ar, 14, 16, !0],
				[mt]: 's3expressAvailabilityZoneDelim',
			},
			{ [B]: et, [N]: [{ [ue]: 's3expressAvailabilityZoneDelim' }, '--'] },
		],
		zk = [
			{
				[C]: [Qe],
				[M]: {
					[Q]: 'https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com',
					[Z]: Wn,
					[ee]: {},
				},
				[h]: M,
			},
			{
				[M]: {
					[Q]: 'https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com',
					[Z]: Wn,
					[ee]: {},
				},
				[h]: M,
			},
		],
		Hk = [
			{ [B]: xn, [N]: [ar, 6, 15, !0], [mt]: 's3expressAvailabilityZoneId' },
			{
				[B]: xn,
				[N]: [ar, 15, 17, !0],
				[mt]: 's3expressAvailabilityZoneDelim',
			},
			{ [B]: et, [N]: [{ [ue]: 's3expressAvailabilityZoneDelim' }, '--'] },
		],
		$k = [
			{
				[C]: [Qe],
				[M]: {
					[Q]: 'https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com',
					[Z]: zu,
					[ee]: {},
				},
				[h]: M,
			},
			{
				[M]: {
					[Q]: 'https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com',
					[Z]: zu,
					[ee]: {},
				},
				[h]: M,
			},
		],
		tZ = [Gu],
		Vk = [{ [B]: So, [N]: [{ [ue]: Bh }, !1] }],
		Kk = [{ [B]: et, [N]: [{ [ue]: iI }, 'beta'] }],
		rZ = ['*'],
		bi = [mI],
		Wk = [{ [B]: So, [N]: [{ [ue]: 'Region' }, !1] }],
		wi = [{ [B]: et, [N]: [{ [ue]: 'Region' }, 'us-east-1'] }],
		Oh = [{ [B]: et, [N]: [vI, dI] }],
		Xk = [
			{ [B]: ht, [N]: [_r, 'resourceId[1]'], [mt]: qh },
			{ [B]: Pn, [N]: [{ [B]: et, [N]: [jh, Uu] }] },
		],
		nZ = [_r, 'resourceId[1]'],
		Rh = [
			{
				[B]: Pn,
				[N]: [{ [B]: et, [N]: [{ [B]: ht, [N]: [_r, 'region'] }, Uu] }],
			},
		],
		Yk = [
			{
				[B]: Pn,
				[N]: [{ [B]: Nr, [N]: [{ [B]: ht, [N]: [_r, 'resourceId[2]'] }] }],
			},
		],
		iZ = [_r, 'resourceId[2]'],
		kh = [
			{
				[B]: ju,
				[N]: [{ [B]: ht, [N]: [_r, 'region'] }],
				[mt]: 'bucketPartition',
			},
		],
		Jk = [
			{
				[B]: et,
				[N]: [hI, { [B]: ht, [N]: [{ [ue]: 'partitionResult' }, Wt] }],
			},
		],
		Ih = [{ [B]: So, [N]: [{ [B]: ht, [N]: [_r, 'region'] }, !0] }],
		Th = [{ [B]: So, [N]: [_I, !1] }],
		Qk = [{ [B]: So, [N]: [jh, !1] }],
		Zk = [{ [B]: So, [N]: [{ [ue]: 'Region' }, !0] }],
		oZ = {
			version: '1.0',
			parameters: {
				Bucket: Ds,
				Region: Ds,
				UseFIPS: Ls,
				UseDualStack: Ls,
				Endpoint: Ds,
				ForcePathStyle: Ls,
				Accelerate: Ls,
				UseGlobalEndpoint: Ls,
				UseObjectLambdaEndpoint: Zc,
				Key: Ds,
				Prefix: Ds,
				CopySource: Ds,
				DisableAccessPoints: Zc,
				DisableMultiRegionAccessPoints: Ls,
				UseArnRegion: Zc,
				UseS3ExpressControlEndpoint: Zc,
				DisableS3ExpressSessionAuth: Zc,
			},
			rules: [
				{
					[C]: [{ [B]: Nr, [N]: wh }],
					rules: [
						{
							[C]: [sn, Qe],
							error: 'Accelerate cannot be used with FIPS',
							[h]: te,
						},
						{
							[C]: [Je, St],
							error:
								'Cannot set dual-stack in combination with a custom endpoint.',
							[h]: te,
						},
						{
							[C]: [St, Qe],
							error: 'A custom endpoint cannot be combined with FIPS',
							[h]: te,
						},
						{
							[C]: [St, sn],
							error: 'A custom endpoint cannot be combined with S3 Accelerate',
							[h]: te,
						},
						{
							[C]: [Qe, mI, dk],
							error: 'Partition does not support FIPS',
							[h]: te,
						},
						{
							[C]: [
								Gu,
								{ [B]: xn, [N]: [ar, 0, 6, on], [mt]: ek },
								{ [B]: et, [N]: [{ [ue]: ek }, '--x-s3'] },
							],
							rules: [
								{
									[C]: xh,
									error: 'S3Express does not support Dual-stack.',
									[h]: te,
								},
								{
									[C]: Lu,
									error: 'S3Express does not support S3 Accelerate.',
									[h]: te,
								},
								{
									[C]: yo,
									rules: [
										{
											[C]: jk,
											rules: [
												{
													[C]: Uk,
													rules: [
														{
															[C]: Ph,
															rules: [
																{
																	endpoint: { [Q]: tk, [Z]: Wn, [ee]: fe },
																	[h]: M,
																},
															],
															[h]: L,
														},
													],
													[h]: L,
												},
												{
													[C]: Ah,
													rules: [
														{
															endpoint: { [Q]: Fu, [Z]: Wn, [ee]: fe },
															[h]: M,
														},
													],
													[h]: L,
												},
												dh,
											],
											[h]: L,
										},
										{
											[C]: Uk,
											rules: [
												{
													[C]: Ph,
													rules: [
														{
															endpoint: { [Q]: tk, [Z]: zu, [ee]: fe },
															[h]: M,
														},
													],
													[h]: L,
												},
											],
											[h]: L,
										},
										{
											[C]: Ah,
											rules: [
												{ endpoint: { [Q]: Fu, [Z]: zu, [ee]: fe }, [h]: M },
											],
											[h]: L,
										},
										dh,
									],
									[h]: L,
								},
								{
									[C]: [uk, mk],
									rules: [
										{
											[C]: [pI, ge],
											rules: [
												{
													[C]: Fs,
													endpoint: {
														[Q]: 'https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}',
														[Z]: Wn,
														[ee]: fe,
													},
													[h]: M,
												},
												{
													endpoint: {
														[Q]: 'https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}',
														[Z]: Wn,
														[ee]: fe,
													},
													[h]: M,
												},
											],
											[h]: L,
										},
									],
									[h]: L,
								},
								{
									[C]: Ah,
									rules: [
										{
											[C]: jk,
											rules: [
												{ [C]: Gk, rules: zk, [h]: L },
												{ [C]: Hk, rules: zk, [h]: L },
												fk,
											],
											[h]: L,
										},
										{ [C]: Gk, rules: $k, [h]: L },
										{ [C]: Hk, rules: $k, [h]: L },
										fk,
									],
									[h]: L,
								},
								dh,
							],
							[h]: L,
						},
						{
							[C]: [pk, uk, mk],
							rules: [
								{ [C]: yo, endpoint: { [Q]: Mu, [Z]: Wn, [ee]: fe }, [h]: M },
								{
									[C]: Fs,
									endpoint: {
										[Q]: 'https://s3express-control-fips.{Region}.amazonaws.com',
										[Z]: Wn,
										[ee]: fe,
									},
									[h]: M,
								},
								{
									endpoint: {
										[Q]: 'https://s3express-control.{Region}.amazonaws.com',
										[Z]: Wn,
										[ee]: fe,
									},
									[h]: M,
								},
							],
							[h]: L,
						},
						{
							[C]: [
								Gu,
								{ [B]: xn, [N]: [ar, 49, 50, on], [mt]: nI },
								{ [B]: xn, [N]: [ar, 8, 12, on], [mt]: iI },
								{ [B]: xn, [N]: [ar, 0, 7, on], [mt]: rk },
								{ [B]: xn, [N]: [ar, 32, 49, on], [mt]: Bh },
								{ [B]: ju, [N]: wh, [mt]: 'regionPartition' },
								{ [B]: et, [N]: [{ [ue]: rk }, '--op-s3'] },
							],
							rules: [
								{
									[C]: Vk,
									rules: [
										{
											[C]: [{ [B]: et, [N]: [gk, 'e'] }],
											rules: [
												{
													[C]: Kk,
													rules: [
														vk,
														{
															[C]: yo,
															endpoint: {
																[Q]: 'https://{Bucket}.ec2.{url#authority}',
																[Z]: Nu,
																[ee]: fe,
															},
															[h]: M,
														},
													],
													[h]: L,
												},
												{
													endpoint: {
														[Q]: 'https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}',
														[Z]: Nu,
														[ee]: fe,
													},
													[h]: M,
												},
											],
											[h]: L,
										},
										{
											[C]: [{ [B]: et, [N]: [gk, 'o'] }],
											rules: [
												{
													[C]: Kk,
													rules: [
														vk,
														{
															[C]: yo,
															endpoint: {
																[Q]: 'https://{Bucket}.op-{outpostId}.{url#authority}',
																[Z]: Nu,
																[ee]: fe,
															},
															[h]: M,
														},
													],
													[h]: L,
												},
												{
													endpoint: {
														[Q]: 'https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}',
														[Z]: Nu,
														[ee]: fe,
													},
													[h]: M,
												},
											],
											[h]: L,
										},
										{
											error:
												'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"',
											[h]: te,
										},
									],
									[h]: L,
								},
								{
									error:
										'Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.',
									[h]: te,
								},
							],
							[h]: L,
						},
						{
							[C]: tZ,
							rules: [
								{
									[C]: [
										St,
										{
											[B]: Pn,
											[N]: [{ [B]: Nr, [N]: [{ [B]: tI, [N]: ZQ }] }],
										},
									],
									error: 'Custom endpoint `{Endpoint}` was not a valid URI',
									[h]: te,
								},
								{
									[C]: [uh, gI],
									rules: [
										{
											[C]: bi,
											rules: [
												{
													[C]: Wk,
													rules: [
														{
															[C]: [sn, dk],
															error:
																'S3 Accelerate cannot be used in this region',
															[h]: te,
														},
														{
															[C]: [Je, Qe, yt, ge, bt],
															endpoint: {
																[Q]: 'https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}',
																[Z]: Tt,
																[ee]: fe,
															},
															[h]: M,
														},
														{
															[C]: [Je, Qe, yt, ge, Re, Bt],
															rules: [{ endpoint: hk, [h]: M }],
															[h]: L,
														},
														{
															[C]: [Je, Qe, yt, ge, Re, Nt],
															endpoint: hk,
															[h]: M,
														},
														{
															[C]: [we, Qe, yt, ge, bt],
															endpoint: {
																[Q]: 'https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}',
																[Z]: Tt,
																[ee]: fe,
															},
															[h]: M,
														},
														{
															[C]: [we, Qe, yt, ge, Re, Bt],
															rules: [{ endpoint: _k, [h]: M }],
															[h]: L,
														},
														{
															[C]: [we, Qe, yt, ge, Re, Nt],
															endpoint: _k,
															[h]: M,
														},
														{
															[C]: [Je, ye, sn, ge, bt],
															endpoint: {
																[Q]: 'https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}',
																[Z]: Tt,
																[ee]: fe,
															},
															[h]: M,
														},
														{
															[C]: [Je, ye, sn, ge, Re, Bt],
															rules: [{ endpoint: yk, [h]: M }],
															[h]: L,
														},
														{
															[C]: [Je, ye, sn, ge, Re, Nt],
															endpoint: yk,
															[h]: M,
														},
														{
															[C]: [Je, ye, yt, ge, bt],
															endpoint: {
																[Q]: 'https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}',
																[Z]: Tt,
																[ee]: fe,
															},
															[h]: M,
														},
														{
															[C]: [Je, ye, yt, ge, Re, Bt],
															rules: [{ endpoint: Sk, [h]: M }],
															[h]: L,
														},
														{
															[C]: [Je, ye, yt, ge, Re, Nt],
															endpoint: Sk,
															[h]: M,
														},
														{
															[C]: [we, ye, yt, St, sr, qu, bt],
															endpoint: { [Q]: oI, [Z]: Tt, [ee]: fe },
															[h]: M,
														},
														{
															[C]: [we, ye, yt, St, sr, mh, bt],
															endpoint: { [Q]: Fu, [Z]: Tt, [ee]: fe },
															[h]: M,
														},
														{
															[C]: [we, ye, yt, St, sr, qu, Re, Bt],
															rules: [
																{ [C]: wi, endpoint: fh, [h]: M },
																{ endpoint: fh, [h]: M },
															],
															[h]: L,
														},
														{
															[C]: [we, ye, yt, St, sr, mh, Re, Bt],
															rules: [{ [C]: wi, endpoint: Nh, [h]: M }, Ck],
															[h]: L,
														},
														{
															[C]: [we, ye, yt, St, sr, qu, Re, Nt],
															endpoint: fh,
															[h]: M,
														},
														{
															[C]: [we, ye, yt, St, sr, mh, Re, Nt],
															endpoint: Nh,
															[h]: M,
														},
														{
															[C]: [we, ye, sn, ge, bt],
															endpoint: { [Q]: sI, [Z]: Tt, [ee]: fe },
															[h]: M,
														},
														{
															[C]: [we, ye, sn, ge, Re, Bt],
															rules: [
																{ [C]: wi, endpoint: ph, [h]: M },
																{ endpoint: ph, [h]: M },
															],
															[h]: L,
														},
														{
															[C]: [we, ye, sn, ge, Re, Nt],
															endpoint: ph,
															[h]: M,
														},
														{
															[C]: [we, ye, yt, ge, bt],
															endpoint: { [Q]: nk, [Z]: Tt, [ee]: fe },
															[h]: M,
														},
														{
															[C]: [we, ye, yt, ge, Re, Bt],
															rules: [
																{
																	[C]: wi,
																	endpoint: { [Q]: nk, [Z]: Ct, [ee]: fe },
																	[h]: M,
																},
																{ endpoint: Ek, [h]: M },
															],
															[h]: L,
														},
														{
															[C]: [we, ye, yt, ge, Re, Nt],
															endpoint: Ek,
															[h]: M,
														},
													],
													[h]: L,
												},
												Du,
											],
											[h]: L,
										},
									],
									[h]: L,
								},
								{
									[C]: [
										St,
										sr,
										{
											[B]: et,
											[N]: [{ [B]: ht, [N]: [fI, 'scheme'] }, 'http'],
										},
										{ [B]: rI, [N]: [ar, on] },
										uh,
										ye,
										we,
										yt,
									],
									rules: [
										{
											[C]: bi,
											rules: [{ [C]: Wk, rules: [Ck], [h]: L }, Du],
											[h]: L,
										},
									],
									[h]: L,
								},
								{
									[C]: [uh, { [B]: aI, [N]: eZ, [mt]: cI }],
									rules: [
										{
											[C]: [
												{ [B]: ht, [N]: [_r, 'resourceId[0]'], [mt]: lI },
												{ [B]: Pn, [N]: [{ [B]: et, [N]: [vI, Uu] }] },
											],
											rules: [
												{
													[C]: [{ [B]: et, [N]: [gh, Mh] }],
													rules: [
														{
															[C]: Oh,
															rules: [
																{
																	[C]: Xk,
																	rules: [
																		bk,
																		wk,
																		{
																			[C]: Rh,
																			rules: [
																				xk,
																				{
																					[C]: Yk,
																					rules: [
																						vh,
																						{
																							[C]: kh,
																							rules: [
																								{
																									[C]: bi,
																									rules: [
																										{
																											[C]: Jk,
																											rules: [
																												{
																													[C]: Ih,
																													rules: [
																														{
																															[C]: [
																																{
																																	[B]: et,
																																	[N]: [_I, Uu],
																																},
																															],
																															error:
																																'Invalid ARN: Missing account id',
																															[h]: te,
																														},
																														{
																															[C]: Th,
																															rules: [
																																{
																																	[C]: Qk,
																																	rules: [
																																		{
																																			[C]: yo,
																																			endpoint:
																																				{
																																					[Q]: ik,
																																					[Z]: hh,
																																					[ee]: fe,
																																				},
																																			[h]: M,
																																		},
																																		{
																																			[C]: Fs,
																																			endpoint:
																																				{
																																					[Q]: 'https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}',
																																					[Z]: hh,
																																					[ee]: fe,
																																				},
																																			[h]: M,
																																		},
																																		{
																																			endpoint:
																																				{
																																					[Q]: 'https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}',
																																					[Z]: hh,
																																					[ee]: fe,
																																				},
																																			[h]: M,
																																		},
																																	],
																																	[h]: L,
																																},
																																Pk,
																															],
																															[h]: L,
																														},
																														_h,
																													],
																													[h]: L,
																												},
																												yh,
																											],
																											[h]: L,
																										},
																										Sh,
																									],
																									[h]: L,
																								},
																							],
																							[h]: L,
																						},
																					],
																					[h]: L,
																				},
																				Ak,
																			],
																			[h]: L,
																		},
																		{
																			error:
																				'Invalid ARN: bucket ARN is missing a region',
																			[h]: te,
																		},
																	],
																	[h]: L,
																},
																Ok,
															],
															[h]: L,
														},
														{
															error:
																'Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`',
															[h]: te,
														},
													],
													[h]: L,
												},
												{
													[C]: Oh,
													rules: [
														{
															[C]: Xk,
															rules: [
																{
																	[C]: Rh,
																	rules: [
																		{
																			[C]: Oh,
																			rules: [
																				{
																					[C]: Rh,
																					rules: [
																						xk,
																						{
																							[C]: Yk,
																							rules: [
																								vh,
																								{
																									[C]: kh,
																									rules: [
																										{
																											[C]: bi,
																											rules: [
																												{
																													[C]: [
																														{
																															[B]: et,
																															[N]: [
																																hI,
																																'{partitionResult#name}',
																															],
																														},
																													],
																													rules: [
																														{
																															[C]: Ih,
																															rules: [
																																{
																																	[C]: [
																																		{
																																			[B]: et,
																																			[N]: [
																																				gh,
																																				Ms,
																																			],
																																		},
																																	],
																																	rules: [
																																		{
																																			[C]: Th,
																																			rules: [
																																				{
																																					[C]: Qk,
																																					rules:
																																						[
																																							{
																																								[C]: Lu,
																																								error:
																																									'Access Points do not support S3 Accelerate',
																																								[h]: te,
																																							},
																																							{
																																								[C]: [
																																									Qe,
																																									Je,
																																								],
																																								endpoint:
																																									{
																																										[Q]: 'https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}',
																																										[Z]: el,
																																										[ee]: fe,
																																									},
																																								[h]: M,
																																							},
																																							{
																																								[C]: [
																																									Qe,
																																									we,
																																								],
																																								endpoint:
																																									{
																																										[Q]: 'https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}',
																																										[Z]: el,
																																										[ee]: fe,
																																									},
																																								[h]: M,
																																							},
																																							{
																																								[C]: [
																																									ye,
																																									Je,
																																								],
																																								endpoint:
																																									{
																																										[Q]: 'https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}',
																																										[Z]: el,
																																										[ee]: fe,
																																									},
																																								[h]: M,
																																							},
																																							{
																																								[C]: [
																																									ye,
																																									we,
																																									St,
																																									sr,
																																								],
																																								endpoint:
																																									{
																																										[Q]: ik,
																																										[Z]: el,
																																										[ee]: fe,
																																									},
																																								[h]: M,
																																							},
																																							{
																																								[C]: [
																																									ye,
																																									we,
																																								],
																																								endpoint:
																																									{
																																										[Q]: 'https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}',
																																										[Z]: el,
																																										[ee]: fe,
																																									},
																																								[h]: M,
																																							},
																																						],
																																					[h]: L,
																																				},
																																				Pk,
																																			],
																																			[h]: L,
																																		},
																																		_h,
																																	],
																																	[h]: L,
																																},
																																{
																																	error:
																																		'Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}',
																																	[h]: te,
																																},
																															],
																															[h]: L,
																														},
																														yh,
																													],
																													[h]: L,
																												},
																												Sh,
																											],
																											[h]: L,
																										},
																									],
																									[h]: L,
																								},
																							],
																							[h]: L,
																						},
																						Ak,
																					],
																					[h]: L,
																				},
																			],
																			[h]: L,
																		},
																	],
																	[h]: L,
																},
																{
																	[C]: [{ [B]: So, [N]: [jh, on] }],
																	rules: [
																		{
																			[C]: xh,
																			error:
																				'S3 MRAP does not support dual-stack',
																			[h]: te,
																		},
																		{
																			[C]: Fs,
																			error: 'S3 MRAP does not support FIPS',
																			[h]: te,
																		},
																		{
																			[C]: Lu,
																			error:
																				'S3 MRAP does not support S3 Accelerate',
																			[h]: te,
																		},
																		{
																			[C]: [
																				{
																					[B]: Dt,
																					[N]: [
																						{
																							[ue]: 'DisableMultiRegionAccessPoints',
																						},
																						on,
																					],
																				},
																			],
																			error:
																				'Invalid configuration: Multi-Region Access Point ARNs are disabled.',
																			[h]: te,
																		},
																		{
																			[C]: [{ [B]: ju, [N]: wh, [mt]: ok }],
																			rules: [
																				{
																					[C]: [
																						{
																							[B]: et,
																							[N]: [
																								{
																									[B]: ht,
																									[N]: [{ [ue]: ok }, Wt],
																								},
																								{
																									[B]: ht,
																									[N]: [_r, 'partition'],
																								},
																							],
																						},
																					],
																					rules: [
																						{
																							endpoint: {
																								[Q]: 'https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}',
																								[Z]: {
																									[an]: [
																										{
																											[xr]: on,
																											name: Fh,
																											[Pr]: Ms,
																											[Lh]: rZ,
																										},
																									],
																								},
																								[ee]: fe,
																							},
																							[h]: M,
																						},
																					],
																					[h]: L,
																				},
																				{
																					error:
																						'Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`',
																					[h]: te,
																				},
																			],
																			[h]: L,
																		},
																	],
																	[h]: L,
																},
																{ error: 'Invalid Access Point Name', [h]: te },
															],
															[h]: L,
														},
														Ok,
													],
													[h]: L,
												},
												{
													[C]: [{ [B]: et, [N]: [gh, tl] }],
													rules: [
														{
															[C]: xh,
															error: 'S3 Outposts does not support Dual-stack',
															[h]: te,
														},
														{
															[C]: Fs,
															error: 'S3 Outposts does not support FIPS',
															[h]: te,
														},
														{
															[C]: Lu,
															error:
																'S3 Outposts does not support S3 Accelerate',
															[h]: te,
														},
														{
															[C]: [
																{
																	[B]: Nr,
																	[N]: [
																		{ [B]: ht, [N]: [_r, 'resourceId[4]'] },
																	],
																},
															],
															error:
																'Invalid Arn: Outpost Access Point ARN contains sub resources',
															[h]: te,
														},
														{
															[C]: [{ [B]: ht, [N]: nZ, [mt]: Bh }],
															rules: [
																{
																	[C]: Vk,
																	rules: [
																		vh,
																		{
																			[C]: kh,
																			rules: [
																				{
																					[C]: bi,
																					rules: [
																						{
																							[C]: Jk,
																							rules: [
																								{
																									[C]: Ih,
																									rules: [
																										{
																											[C]: Th,
																											rules: [
																												{
																													[C]: [
																														{
																															[B]: ht,
																															[N]: iZ,
																															[mt]: sk,
																														},
																													],
																													rules: [
																														{
																															[C]: [
																																{
																																	[B]: ht,
																																	[N]: [
																																		_r,
																																		'resourceId[3]',
																																	],
																																	[mt]: qh,
																																},
																															],
																															rules: [
																																{
																																	[C]: [
																																		{
																																			[B]: et,
																																			[N]: [
																																				{
																																					[ue]: sk,
																																				},
																																				dI,
																																			],
																																		},
																																	],
																																	rules: [
																																		{
																																			[C]: yo,
																																			endpoint:
																																				{
																																					[Q]: 'https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}',
																																					[Z]: Rk,
																																					[ee]: fe,
																																				},
																																			[h]: M,
																																		},
																																		{
																																			endpoint:
																																				{
																																					[Q]: 'https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}',
																																					[Z]: Rk,
																																					[ee]: fe,
																																				},
																																			[h]: M,
																																		},
																																	],
																																	[h]: L,
																																},
																																{
																																	error:
																																		'Expected an outpost type `accesspoint`, found {outpostType}',
																																	[h]: te,
																																},
																															],
																															[h]: L,
																														},
																														{
																															error:
																																'Invalid ARN: expected an access point name',
																															[h]: te,
																														},
																													],
																													[h]: L,
																												},
																												{
																													error:
																														'Invalid ARN: Expected a 4-component resource',
																													[h]: te,
																												},
																											],
																											[h]: L,
																										},
																										_h,
																									],
																									[h]: L,
																								},
																								yh,
																							],
																							[h]: L,
																						},
																						Sh,
																					],
																					[h]: L,
																				},
																			],
																			[h]: L,
																		},
																	],
																	[h]: L,
																},
																{
																	error:
																		'Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`',
																	[h]: te,
																},
															],
															[h]: L,
														},
														{
															error: 'Invalid ARN: The Outpost Id was not set',
															[h]: te,
														},
													],
													[h]: L,
												},
												{
													error:
														'Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})',
													[h]: te,
												},
											],
											[h]: L,
										},
										{ error: 'Invalid ARN: No ARN type specified', [h]: te },
									],
									[h]: L,
								},
								{
									[C]: [
										{ [B]: xn, [N]: [ar, 0, 4, JQ], [mt]: ak },
										{ [B]: et, [N]: [{ [ue]: ak }, 'arn:'] },
										{ [B]: Pn, [N]: [{ [B]: Nr, [N]: [kk] }] },
									],
									error: 'Invalid ARN: `{Bucket}` was not a valid ARN',
									[h]: te,
								},
								{
									[C]: [{ [B]: Dt, [N]: [QQ, on] }, kk],
									error:
										'Path-style addressing cannot be used with ARN buckets',
									[h]: te,
								},
								{
									[C]: Ph,
									rules: [
										{
											[C]: bi,
											rules: [
												{
													[C]: [yt],
													rules: [
														{
															[C]: [Je, ge, Qe, bt],
															endpoint: {
																[Q]: 'https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}',
																[Z]: Tt,
																[ee]: fe,
															},
															[h]: M,
														},
														{
															[C]: [Je, ge, Qe, Re, Bt],
															rules: [{ endpoint: Ik, [h]: M }],
															[h]: L,
														},
														{ [C]: [Je, ge, Qe, Re, Nt], endpoint: Ik, [h]: M },
														{
															[C]: [we, ge, Qe, bt],
															endpoint: {
																[Q]: 'https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}',
																[Z]: Tt,
																[ee]: fe,
															},
															[h]: M,
														},
														{
															[C]: [we, ge, Qe, Re, Bt],
															rules: [{ endpoint: Tk, [h]: M }],
															[h]: L,
														},
														{ [C]: [we, ge, Qe, Re, Nt], endpoint: Tk, [h]: M },
														{
															[C]: [Je, ge, ye, bt],
															endpoint: {
																[Q]: 'https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}',
																[Z]: Tt,
																[ee]: fe,
															},
															[h]: M,
														},
														{
															[C]: [Je, ge, ye, Re, Bt],
															rules: [{ endpoint: Bk, [h]: M }],
															[h]: L,
														},
														{ [C]: [Je, ge, ye, Re, Nt], endpoint: Bk, [h]: M },
														{
															[C]: [we, St, sr, ye, bt],
															endpoint: { [Q]: uI, [Z]: Tt, [ee]: fe },
															[h]: M,
														},
														{
															[C]: [we, St, sr, ye, Re, Bt],
															rules: [
																{ [C]: wi, endpoint: Ch, [h]: M },
																{ endpoint: Ch, [h]: M },
															],
															[h]: L,
														},
														{
															[C]: [we, St, sr, ye, Re, Nt],
															endpoint: Ch,
															[h]: M,
														},
														{
															[C]: [we, ge, ye, bt],
															endpoint: { [Q]: ck, [Z]: Tt, [ee]: fe },
															[h]: M,
														},
														{
															[C]: [we, ge, ye, Re, Bt],
															rules: [
																{
																	[C]: wi,
																	endpoint: { [Q]: ck, [Z]: Ct, [ee]: fe },
																	[h]: M,
																},
																{ endpoint: Nk, [h]: M },
															],
															[h]: L,
														},
														{ [C]: [we, ge, ye, Re, Nt], endpoint: Nk, [h]: M },
													],
													[h]: L,
												},
												{
													error:
														'Path-style addressing cannot be used with S3 Accelerate',
													[h]: te,
												},
											],
											[h]: L,
										},
									],
									[h]: L,
								},
							],
							[h]: L,
						},
						{
							[C]: [
								{ [B]: Nr, [N]: [Dk] },
								{ [B]: Dt, [N]: [Dk, on] },
							],
							rules: [
								{
									[C]: bi,
									rules: [
										{
											[C]: Zk,
											rules: [
												bk,
												wk,
												{
													[C]: yo,
													endpoint: { [Q]: Mu, [Z]: Eh, [ee]: fe },
													[h]: M,
												},
												{
													[C]: Fs,
													endpoint: {
														[Q]: 'https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}',
														[Z]: Eh,
														[ee]: fe,
													},
													[h]: M,
												},
												{
													endpoint: {
														[Q]: 'https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}',
														[Z]: Eh,
														[ee]: fe,
													},
													[h]: M,
												},
											],
											[h]: L,
										},
										Du,
									],
									[h]: L,
								},
							],
							[h]: L,
						},
						{
							[C]: [pk],
							rules: [
								{
									[C]: bi,
									rules: [
										{
											[C]: Zk,
											rules: [
												{
													[C]: [Qe, Je, ge, bt],
													endpoint: {
														[Q]: 'https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}',
														[Z]: Tt,
														[ee]: fe,
													},
													[h]: M,
												},
												{
													[C]: [Qe, Je, ge, Re, Bt],
													rules: [{ endpoint: Lk, [h]: M }],
													[h]: L,
												},
												{ [C]: [Qe, Je, ge, Re, Nt], endpoint: Lk, [h]: M },
												{
													[C]: [Qe, we, ge, bt],
													endpoint: {
														[Q]: 'https://s3-fips.us-east-1.{partitionResult#dnsSuffix}',
														[Z]: Tt,
														[ee]: fe,
													},
													[h]: M,
												},
												{
													[C]: [Qe, we, ge, Re, Bt],
													rules: [{ endpoint: Fk, [h]: M }],
													[h]: L,
												},
												{ [C]: [Qe, we, ge, Re, Nt], endpoint: Fk, [h]: M },
												{
													[C]: [ye, Je, ge, bt],
													endpoint: {
														[Q]: 'https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}',
														[Z]: Tt,
														[ee]: fe,
													},
													[h]: M,
												},
												{
													[C]: [ye, Je, ge, Re, Bt],
													rules: [{ endpoint: Mk, [h]: M }],
													[h]: L,
												},
												{ [C]: [ye, Je, ge, Re, Nt], endpoint: Mk, [h]: M },
												{
													[C]: [ye, we, St, sr, bt],
													endpoint: { [Q]: Mu, [Z]: Tt, [ee]: fe },
													[h]: M,
												},
												{
													[C]: [ye, we, St, sr, Re, Bt],
													rules: [
														{ [C]: wi, endpoint: bh, [h]: M },
														{ endpoint: bh, [h]: M },
													],
													[h]: L,
												},
												{ [C]: [ye, we, St, sr, Re, Nt], endpoint: bh, [h]: M },
												{
													[C]: [ye, we, ge, bt],
													endpoint: { [Q]: lk, [Z]: Tt, [ee]: fe },
													[h]: M,
												},
												{
													[C]: [ye, we, ge, Re, Bt],
													rules: [
														{
															[C]: wi,
															endpoint: { [Q]: lk, [Z]: Ct, [ee]: fe },
															[h]: M,
														},
														{ endpoint: qk, [h]: M },
													],
													[h]: L,
												},
												{ [C]: [ye, we, ge, Re, Nt], endpoint: qk, [h]: M },
											],
											[h]: L,
										},
										Du,
									],
									[h]: L,
								},
							],
							[h]: L,
						},
					],
					[h]: L,
				},
				{ error: 'A region must be set when sending requests to S3.', [h]: te },
			],
		}
	Hu.ruleSet = oZ
})
var Uh = E(($u) => {
	'use strict'
	Object.defineProperty($u, '__esModule', { value: !0 })
	$u.defaultEndpointResolver = void 0
	var sZ = Bs(),
		SI = Is(),
		aZ = yI(),
		cZ = (e, t = {}) =>
			(0, SI.resolveEndpoint)(aZ.ruleSet, {
				endpointParams: e,
				logger: t.logger,
			})
	$u.defaultEndpointResolver = cZ
	SI.customEndpointFunctions.aws = sZ.awsEndpointFunctions
})
var zh = E((xi) => {
	'use strict'
	Object.defineProperty(xi, '__esModule', { value: !0 })
	xi.resolveHttpAuthSchemeConfig =
		xi.defaultS3HttpAuthSchemeProvider =
		xi.defaultS3HttpAuthSchemeParametersProvider =
			void 0
	var CI = (zt(), ve(Gt)),
		lZ = lh(),
		dZ = $n(),
		Gh = Tr(),
		uZ = Uh(),
		mZ = (e) => async (t, r, n) => {
			if (!n)
				throw new Error(
					'Could not find `input` for `defaultEndpointRuleSetHttpAuthSchemeParametersProvider`',
				)
			let i = await e(t, r, n),
				o = (0, Gh.getSmithyContext)(r)?.commandInstance?.constructor
					?.getEndpointParameterInstructions
			if (!o)
				throw new Error(
					`getEndpointParameterInstructions() is not defined on \`${r.commandName}\``,
				)
			let s = await (0, dZ.resolveParams)(
				n,
				{ getEndpointParameterInstructions: o },
				t,
			)
			return Object.assign(i, s)
		},
		fZ = async (e, t, r) => ({
			operation: (0, Gh.getSmithyContext)(t).operation,
			region:
				(await (0, Gh.normalizeProvider)(e.region)()) ||
				(() => {
					throw new Error(
						'expected `region` to be configured for `aws.auth#sigv4`',
					)
				})(),
		})
	xi.defaultS3HttpAuthSchemeParametersProvider = mZ(fZ)
	function EI(e) {
		return {
			schemeId: 'aws.auth#sigv4',
			signingProperties: { name: 's3', region: e.region },
			propertiesExtractor: (t, r) => ({
				signingProperties: { config: t, context: r },
			}),
		}
	}
	function bI(e) {
		return {
			schemeId: 'aws.auth#sigv4a',
			signingProperties: { name: 's3', region: e.region },
			propertiesExtractor: (t, r) => ({
				signingProperties: { config: t, context: r },
			}),
		}
	}
	var pZ = (e, t, r) => (i) => {
			let s = e(i).properties?.authSchemes
			if (!s) return t(i)
			let c = []
			for (let l of s) {
				let { name: u, properties: m = {}, ...f } = l,
					p = u.toLowerCase()
				u !== p &&
					console.warn(
						`HttpAuthScheme has been normalized with lowercasing: \`${u}\` to \`${p}\``,
					)
				let g
				if (p === 'sigv4a') {
					g = 'aws.auth#sigv4a'
					let y = s.find((P) => {
						let x = P.name.toLowerCase()
						return x !== 'sigv4a' && x.startsWith('sigv4')
					})
					if (!lZ.signatureV4CrtContainer.CrtSignerV4 && y) continue
				} else if (p.startsWith('sigv4')) g = 'aws.auth#sigv4'
				else
					throw new Error(
						`Unknown HttpAuthScheme found in \`@smithy.rules#endpointRuleSet\`: \`${p}\``,
					)
				let v = r[g]
				if (!v)
					throw new Error(
						`Could not find HttpAuthOption create function for \`${g}\``,
					)
				let _ = v(i)
				;(_.schemeId = g),
					(_.signingProperties = {
						...(_.signingProperties || {}),
						...f,
						...m,
					}),
					c.push(_)
			}
			return c
		},
		gZ = (e) => {
			let t = []
			switch (e.operation) {
				default:
					t.push(EI(e)), t.push(bI(e))
			}
			return t
		}
	xi.defaultS3HttpAuthSchemeProvider = pZ(uZ.defaultEndpointResolver, gZ, {
		'aws.auth#sigv4': EI,
		'aws.auth#sigv4a': bI,
	})
	var vZ = (e) => {
		let t = (0, CI.resolveAwsSdkSigV4Config)(e)
		return { ...(0, CI.resolveAwsSdkSigV4AConfig)(t) }
	}
	xi.resolveHttpAuthSchemeConfig = vZ
})
var II = E((_Ie, kI) => {
	'use strict'
	var Ku = Object.defineProperty,
		hZ = Object.getOwnPropertyDescriptor,
		_Z = Object.getOwnPropertyNames,
		yZ = Object.prototype.hasOwnProperty,
		Wu = (e, t) => Ku(e, 'name', { value: t, configurable: !0 }),
		SZ = (e, t) => {
			for (var r in t) Ku(e, r, { get: t[r], enumerable: !0 })
		},
		CZ = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of _Z(t))
					!yZ.call(e, i) &&
						i !== r &&
						Ku(e, i, {
							get: () => t[i],
							enumerable: !(n = hZ(t, i)) || n.enumerable,
						})
			return e
		},
		EZ = (e) => CZ(Ku({}, '__esModule', { value: !0 }), e),
		wI = {}
	SZ(wI, { XmlNode: () => bZ, XmlText: () => OI })
	kI.exports = EZ(wI)
	function xI(e) {
		return e
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;')
	}
	Wu(xI, 'escapeAttribute')
	function PI(e) {
		return e
			.replace(/&/g, '&amp;')
			.replace(/"/g, '&quot;')
			.replace(/'/g, '&apos;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/\r/g, '&#x0D;')
			.replace(/\n/g, '&#x0A;')
			.replace(/\u0085/g, '&#x85;')
			.replace(/\u2028/, '&#x2028;')
	}
	Wu(PI, 'escapeElement')
	var AI = class {
		constructor(t) {
			this.value = t
		}
		toString() {
			return PI('' + this.value)
		}
	}
	Wu(AI, 'XmlText')
	var OI = AI,
		RI = class Vu {
			constructor(t, r = []) {
				;(this.name = t), (this.children = r), (this.attributes = {})
			}
			static of(t, r, n) {
				let i = new Vu(t)
				return (
					r !== void 0 && i.addChildNode(new OI(r)),
					n !== void 0 && i.withName(n),
					i
				)
			}
			withName(t) {
				return (this.name = t), this
			}
			addAttribute(t, r) {
				return (this.attributes[t] = r), this
			}
			addChildNode(t) {
				return this.children.push(t), this
			}
			removeAttribute(t) {
				return delete this.attributes[t], this
			}
			n(t) {
				return (this.name = t), this
			}
			c(t) {
				return this.children.push(t), this
			}
			a(t, r) {
				return r != null && (this.attributes[t] = r), this
			}
			cc(t, r, n = r) {
				if (t[r] != null) {
					let i = Vu.of(r, t[r]).withName(n)
					this.c(i)
				}
			}
			l(t, r, n, i) {
				t[r] != null &&
					i().map((s) => {
						s.withName(n), this.c(s)
					})
			}
			lc(t, r, n, i) {
				if (t[r] != null) {
					let o = i(),
						s = new Vu(n)
					o.map((c) => {
						s.c(c)
					}),
						this.c(s)
				}
			}
			toString() {
				let t = !!this.children.length,
					r = `<${this.name}`,
					n = this.attributes
				for (let i of Object.keys(n)) {
					let o = n[i]
					o != null && (r += ` ${i}="${xI('' + o)}"`)
				}
				return (r += t
					? `>${this.children.map((i) => i.toString()).join('')}</${this.name}>`
					: '/>')
			}
		}
	Wu(RI, 'XmlNode')
	var bZ = RI
})
var On = {}
Sc(On, {
	__addDisposableResource: () => QI,
	__assign: () => Xu,
	__asyncDelegator: () => HI,
	__asyncGenerator: () => zI,
	__asyncValues: () => $I,
	__await: () => qs,
	__awaiter: () => FI,
	__classPrivateFieldGet: () => XI,
	__classPrivateFieldIn: () => JI,
	__classPrivateFieldSet: () => YI,
	__createBinding: () => Ju,
	__decorate: () => NI,
	__disposeResources: () => ZI,
	__esDecorate: () => wZ,
	__exportStar: () => qI,
	__extends: () => TI,
	__generator: () => MI,
	__importDefault: () => WI,
	__importStar: () => KI,
	__makeTemplateObject: () => VI,
	__metadata: () => LI,
	__param: () => DI,
	__propKey: () => PZ,
	__read: () => $h,
	__rest: () => BI,
	__runInitializers: () => xZ,
	__setFunctionName: () => AZ,
	__spread: () => jI,
	__spreadArray: () => GI,
	__spreadArrays: () => UI,
	__values: () => Yu,
	default: () => kZ,
})
function TI(e, t) {
	if (typeof t != 'function' && t !== null)
		throw new TypeError(
			'Class extends value ' + String(t) + ' is not a constructor or null',
		)
	Hh(e, t)
	function r() {
		this.constructor = e
	}
	e.prototype =
		t === null ? Object.create(t) : ((r.prototype = t.prototype), new r())
}
function BI(e, t) {
	var r = {}
	for (var n in e)
		Object.prototype.hasOwnProperty.call(e, n) &&
			t.indexOf(n) < 0 &&
			(r[n] = e[n])
	if (e != null && typeof Object.getOwnPropertySymbols == 'function')
		for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
			t.indexOf(n[i]) < 0 &&
				Object.prototype.propertyIsEnumerable.call(e, n[i]) &&
				(r[n[i]] = e[n[i]])
	return r
}
function NI(e, t, r, n) {
	var i = arguments.length,
		o =
			i < 3 ? t : n === null ? (n = Object.getOwnPropertyDescriptor(t, r)) : n,
		s
	if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
		o = Reflect.decorate(e, t, r, n)
	else
		for (var c = e.length - 1; c >= 0; c--)
			(s = e[c]) && (o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o)
	return i > 3 && o && Object.defineProperty(t, r, o), o
}
function DI(e, t) {
	return function (r, n) {
		t(r, n, e)
	}
}
function wZ(e, t, r, n, i, o) {
	function s(P) {
		if (P !== void 0 && typeof P != 'function')
			throw new TypeError('Function expected')
		return P
	}
	for (
		var c = n.kind,
			l = c === 'getter' ? 'get' : c === 'setter' ? 'set' : 'value',
			u = !t && e ? (n.static ? e : e.prototype) : null,
			m = t || (u ? Object.getOwnPropertyDescriptor(u, n.name) : {}),
			f,
			p = !1,
			g = r.length - 1;
		g >= 0;
		g--
	) {
		var v = {}
		for (var _ in n) v[_] = _ === 'access' ? {} : n[_]
		for (var _ in n.access) v.access[_] = n.access[_]
		v.addInitializer = function (P) {
			if (p)
				throw new TypeError(
					'Cannot add initializers after decoration has completed',
				)
			o.push(s(P || null))
		}
		var y = (0, r[g])(c === 'accessor' ? { get: m.get, set: m.set } : m[l], v)
		if (c === 'accessor') {
			if (y === void 0) continue
			if (y === null || typeof y != 'object')
				throw new TypeError('Object expected')
			;(f = s(y.get)) && (m.get = f),
				(f = s(y.set)) && (m.set = f),
				(f = s(y.init)) && i.unshift(f)
		} else (f = s(y)) && (c === 'field' ? i.unshift(f) : (m[l] = f))
	}
	u && Object.defineProperty(u, n.name, m), (p = !0)
}
function xZ(e, t, r) {
	for (var n = arguments.length > 2, i = 0; i < t.length; i++)
		r = n ? t[i].call(e, r) : t[i].call(e)
	return n ? r : void 0
}
function PZ(e) {
	return typeof e == 'symbol' ? e : ''.concat(e)
}
function AZ(e, t, r) {
	return (
		typeof t == 'symbol' &&
			(t = t.description ? '['.concat(t.description, ']') : ''),
		Object.defineProperty(e, 'name', {
			configurable: !0,
			value: r ? ''.concat(r, ' ', t) : t,
		})
	)
}
function LI(e, t) {
	if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function')
		return Reflect.metadata(e, t)
}
function FI(e, t, r, n) {
	function i(o) {
		return o instanceof r
			? o
			: new r(function (s) {
					s(o)
				})
	}
	return new (r || (r = Promise))(function (o, s) {
		function c(m) {
			try {
				u(n.next(m))
			} catch (f) {
				s(f)
			}
		}
		function l(m) {
			try {
				u(n.throw(m))
			} catch (f) {
				s(f)
			}
		}
		function u(m) {
			m.done ? o(m.value) : i(m.value).then(c, l)
		}
		u((n = n.apply(e, t || [])).next())
	})
}
function MI(e, t) {
	var r = {
			label: 0,
			sent: function () {
				if (o[0] & 1) throw o[1]
				return o[1]
			},
			trys: [],
			ops: [],
		},
		n,
		i,
		o,
		s = Object.create(
			(typeof Iterator == 'function' ? Iterator : Object).prototype,
		)
	return (
		(s.next = c(0)),
		(s.throw = c(1)),
		(s.return = c(2)),
		typeof Symbol == 'function' &&
			(s[Symbol.iterator] = function () {
				return this
			}),
		s
	)
	function c(u) {
		return function (m) {
			return l([u, m])
		}
	}
	function l(u) {
		if (n) throw new TypeError('Generator is already executing.')
		for (; s && ((s = 0), u[0] && (r = 0)), r; )
			try {
				if (
					((n = 1),
					i &&
						(o =
							u[0] & 2
								? i.return
								: u[0]
									? i.throw || ((o = i.return) && o.call(i), 0)
									: i.next) &&
						!(o = o.call(i, u[1])).done)
				)
					return o
				switch (((i = 0), o && (u = [u[0] & 2, o.value]), u[0])) {
					case 0:
					case 1:
						o = u
						break
					case 4:
						return r.label++, { value: u[1], done: !1 }
					case 5:
						r.label++, (i = u[1]), (u = [0])
						continue
					case 7:
						;(u = r.ops.pop()), r.trys.pop()
						continue
					default:
						if (
							((o = r.trys),
							!(o = o.length > 0 && o[o.length - 1]) &&
								(u[0] === 6 || u[0] === 2))
						) {
							r = 0
							continue
						}
						if (u[0] === 3 && (!o || (u[1] > o[0] && u[1] < o[3]))) {
							r.label = u[1]
							break
						}
						if (u[0] === 6 && r.label < o[1]) {
							;(r.label = o[1]), (o = u)
							break
						}
						if (o && r.label < o[2]) {
							;(r.label = o[2]), r.ops.push(u)
							break
						}
						o[2] && r.ops.pop(), r.trys.pop()
						continue
				}
				u = t.call(e, r)
			} catch (m) {
				;(u = [6, m]), (i = 0)
			} finally {
				n = o = 0
			}
		if (u[0] & 5) throw u[1]
		return { value: u[0] ? u[1] : void 0, done: !0 }
	}
}
function qI(e, t) {
	for (var r in e)
		r !== 'default' &&
			!Object.prototype.hasOwnProperty.call(t, r) &&
			Ju(t, e, r)
}
function Yu(e) {
	var t = typeof Symbol == 'function' && Symbol.iterator,
		r = t && e[t],
		n = 0
	if (r) return r.call(e)
	if (e && typeof e.length == 'number')
		return {
			next: function () {
				return (
					e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e }
				)
			},
		}
	throw new TypeError(
		t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.',
	)
}
function $h(e, t) {
	var r = typeof Symbol == 'function' && e[Symbol.iterator]
	if (!r) return e
	var n = r.call(e),
		i,
		o = [],
		s
	try {
		for (; (t === void 0 || t-- > 0) && !(i = n.next()).done; ) o.push(i.value)
	} catch (c) {
		s = { error: c }
	} finally {
		try {
			i && !i.done && (r = n.return) && r.call(n)
		} finally {
			if (s) throw s.error
		}
	}
	return o
}
function jI() {
	for (var e = [], t = 0; t < arguments.length; t++)
		e = e.concat($h(arguments[t]))
	return e
}
function UI() {
	for (var e = 0, t = 0, r = arguments.length; t < r; t++)
		e += arguments[t].length
	for (var n = Array(e), i = 0, t = 0; t < r; t++)
		for (var o = arguments[t], s = 0, c = o.length; s < c; s++, i++) n[i] = o[s]
	return n
}
function GI(e, t, r) {
	if (r || arguments.length === 2)
		for (var n = 0, i = t.length, o; n < i; n++)
			(o || !(n in t)) &&
				(o || (o = Array.prototype.slice.call(t, 0, n)), (o[n] = t[n]))
	return e.concat(o || Array.prototype.slice.call(t))
}
function qs(e) {
	return this instanceof qs ? ((this.v = e), this) : new qs(e)
}
function zI(e, t, r) {
	if (!Symbol.asyncIterator)
		throw new TypeError('Symbol.asyncIterator is not defined.')
	var n = r.apply(e, t || []),
		i,
		o = []
	return (
		(i = Object.create(
			(typeof AsyncIterator == 'function' ? AsyncIterator : Object).prototype,
		)),
		c('next'),
		c('throw'),
		c('return', s),
		(i[Symbol.asyncIterator] = function () {
			return this
		}),
		i
	)
	function s(g) {
		return function (v) {
			return Promise.resolve(v).then(g, f)
		}
	}
	function c(g, v) {
		n[g] &&
			((i[g] = function (_) {
				return new Promise(function (y, P) {
					o.push([g, _, y, P]) > 1 || l(g, _)
				})
			}),
			v && (i[g] = v(i[g])))
	}
	function l(g, v) {
		try {
			u(n[g](v))
		} catch (_) {
			p(o[0][3], _)
		}
	}
	function u(g) {
		g.value instanceof qs
			? Promise.resolve(g.value.v).then(m, f)
			: p(o[0][2], g)
	}
	function m(g) {
		l('next', g)
	}
	function f(g) {
		l('throw', g)
	}
	function p(g, v) {
		g(v), o.shift(), o.length && l(o[0][0], o[0][1])
	}
}
function HI(e) {
	var t, r
	return (
		(t = {}),
		n('next'),
		n('throw', function (i) {
			throw i
		}),
		n('return'),
		(t[Symbol.iterator] = function () {
			return this
		}),
		t
	)
	function n(i, o) {
		t[i] = e[i]
			? function (s) {
					return (r = !r) ? { value: qs(e[i](s)), done: !1 } : o ? o(s) : s
				}
			: o
	}
}
function $I(e) {
	if (!Symbol.asyncIterator)
		throw new TypeError('Symbol.asyncIterator is not defined.')
	var t = e[Symbol.asyncIterator],
		r
	return t
		? t.call(e)
		: ((e = typeof Yu == 'function' ? Yu(e) : e[Symbol.iterator]()),
			(r = {}),
			n('next'),
			n('throw'),
			n('return'),
			(r[Symbol.asyncIterator] = function () {
				return this
			}),
			r)
	function n(o) {
		r[o] =
			e[o] &&
			function (s) {
				return new Promise(function (c, l) {
					;(s = e[o](s)), i(c, l, s.done, s.value)
				})
			}
	}
	function i(o, s, c, l) {
		Promise.resolve(l).then(function (u) {
			o({ value: u, done: c })
		}, s)
	}
}
function VI(e, t) {
	return (
		Object.defineProperty
			? Object.defineProperty(e, 'raw', { value: t })
			: (e.raw = t),
		e
	)
}
function KI(e) {
	if (e && e.__esModule) return e
	var t = {}
	if (e != null)
		for (var r in e)
			r !== 'default' &&
				Object.prototype.hasOwnProperty.call(e, r) &&
				Ju(t, e, r)
	return OZ(t, e), t
}
function WI(e) {
	return e && e.__esModule ? e : { default: e }
}
function XI(e, t, r, n) {
	if (r === 'a' && !n)
		throw new TypeError('Private accessor was defined without a getter')
	if (typeof t == 'function' ? e !== t || !n : !t.has(e))
		throw new TypeError(
			'Cannot read private member from an object whose class did not declare it',
		)
	return r === 'm' ? n : r === 'a' ? n.call(e) : n ? n.value : t.get(e)
}
function YI(e, t, r, n, i) {
	if (n === 'm') throw new TypeError('Private method is not writable')
	if (n === 'a' && !i)
		throw new TypeError('Private accessor was defined without a setter')
	if (typeof t == 'function' ? e !== t || !i : !t.has(e))
		throw new TypeError(
			'Cannot write private member to an object whose class did not declare it',
		)
	return n === 'a' ? i.call(e, r) : i ? (i.value = r) : t.set(e, r), r
}
function JI(e, t) {
	if (t === null || (typeof t != 'object' && typeof t != 'function'))
		throw new TypeError("Cannot use 'in' operator on non-object")
	return typeof e == 'function' ? t === e : e.has(t)
}
function QI(e, t, r) {
	if (t != null) {
		if (typeof t != 'object' && typeof t != 'function')
			throw new TypeError('Object expected.')
		var n, i
		if (r) {
			if (!Symbol.asyncDispose)
				throw new TypeError('Symbol.asyncDispose is not defined.')
			n = t[Symbol.asyncDispose]
		}
		if (n === void 0) {
			if (!Symbol.dispose) throw new TypeError('Symbol.dispose is not defined.')
			;(n = t[Symbol.dispose]), r && (i = n)
		}
		if (typeof n != 'function') throw new TypeError('Object not disposable.')
		i &&
			(n = function () {
				try {
					i.call(this)
				} catch (o) {
					return Promise.reject(o)
				}
			}),
			e.stack.push({ value: t, dispose: n, async: r })
	} else r && e.stack.push({ async: !0 })
	return t
}
function ZI(e) {
	function t(o) {
		;(e.error = e.hasError
			? new RZ(o, e.error, 'An error was suppressed during disposal.')
			: o),
			(e.hasError = !0)
	}
	var r,
		n = 0
	function i() {
		for (; (r = e.stack.pop()); )
			try {
				if (!r.async && n === 1)
					return (n = 0), e.stack.push(r), Promise.resolve().then(i)
				if (r.dispose) {
					var o = r.dispose.call(r.value)
					if (r.async)
						return (
							(n |= 2),
							Promise.resolve(o).then(i, function (s) {
								return t(s), i()
							})
						)
				} else n |= 1
			} catch (s) {
				t(s)
			}
		if (n === 1) return e.hasError ? Promise.reject(e.error) : Promise.resolve()
		if (e.hasError) throw e.error
	}
	return i()
}
var Hh,
	Xu,
	Ju,
	OZ,
	RZ,
	kZ,
	Rn = oe(() => {
		Hh = function (e, t) {
			return (
				(Hh =
					Object.setPrototypeOf ||
					({ __proto__: [] } instanceof Array &&
						function (r, n) {
							r.__proto__ = n
						}) ||
					function (r, n) {
						for (var i in n)
							Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i])
					}),
				Hh(e, t)
			)
		}
		Xu = function () {
			return (
				(Xu =
					Object.assign ||
					function (t) {
						for (var r, n = 1, i = arguments.length; n < i; n++) {
							r = arguments[n]
							for (var o in r)
								Object.prototype.hasOwnProperty.call(r, o) && (t[o] = r[o])
						}
						return t
					}),
				Xu.apply(this, arguments)
			)
		}
		Ju = Object.create
			? function (e, t, r, n) {
					n === void 0 && (n = r)
					var i = Object.getOwnPropertyDescriptor(t, r)
					;(!i ||
						('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
						(i = {
							enumerable: !0,
							get: function () {
								return t[r]
							},
						}),
						Object.defineProperty(e, n, i)
				}
			: function (e, t, r, n) {
					n === void 0 && (n = r), (e[n] = t[r])
				}
		OZ = Object.create
			? function (e, t) {
					Object.defineProperty(e, 'default', { enumerable: !0, value: t })
				}
			: function (e, t) {
					e.default = t
				}
		RZ =
			typeof SuppressedError == 'function'
				? SuppressedError
				: function (e, t, r) {
						var n = new Error(r)
						return (
							(n.name = 'SuppressedError'), (n.error = e), (n.suppressed = t), n
						)
					}
		kZ = {
			__extends: TI,
			__assign: Xu,
			__rest: BI,
			__decorate: NI,
			__param: DI,
			__metadata: LI,
			__awaiter: FI,
			__generator: MI,
			__createBinding: Ju,
			__exportStar: qI,
			__values: Yu,
			__read: $h,
			__spread: jI,
			__spreadArrays: UI,
			__spreadArray: GI,
			__await: qs,
			__asyncGenerator: zI,
			__asyncDelegator: HI,
			__asyncValues: $I,
			__makeTemplateObject: VI,
			__importStar: KI,
			__importDefault: WI,
			__classPrivateFieldGet: XI,
			__classPrivateFieldSet: YI,
			__classPrivateFieldIn: JI,
			__addDisposableResource: QI,
			__disposeResources: ZI,
		}
	})
var eT = E((yIe, IZ) => {
	IZ.exports = {
		name: '@aws-sdk/client-s3',
		description:
			'AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native',
		version: '3.645.0',
		scripts: {
			build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
			'build:cjs': 'node ../../scripts/compilation/inline client-s3',
			'build:es': 'tsc -p tsconfig.es.json',
			'build:include:deps':
				'lerna run --scope $npm_package_name --include-dependencies build',
			'build:types': 'tsc -p tsconfig.types.json',
			'build:types:downlevel': 'downlevel-dts dist-types dist-types/ts3.4',
			clean: 'rimraf ./dist-* && rimraf *.tsbuildinfo',
			'extract:docs': 'api-extractor run --local',
			'generate:client':
				'node ../../scripts/generate-clients/single-service --solo s3',
			test: 'yarn test:unit',
			'test:e2e': 'yarn test:e2e:node && yarn test:e2e:browser',
			'test:e2e:browser':
				'ts-mocha test/**/*.browser.ispec.ts && karma start karma.conf.js',
			'test:e2e:node': 'jest --c jest.config.e2e.js',
			'test:unit': 'ts-mocha test/unit/**/*.spec.ts',
		},
		main: './dist-cjs/index.js',
		types: './dist-types/index.d.ts',
		module: './dist-es/index.js',
		sideEffects: !1,
		dependencies: {
			'@aws-crypto/sha1-browser': '5.2.0',
			'@aws-crypto/sha256-browser': '5.2.0',
			'@aws-crypto/sha256-js': '5.2.0',
			'@aws-sdk/client-sso-oidc': '3.645.0',
			'@aws-sdk/client-sts': '3.645.0',
			'@aws-sdk/core': '3.635.0',
			'@aws-sdk/credential-provider-node': '3.645.0',
			'@aws-sdk/middleware-bucket-endpoint': '3.620.0',
			'@aws-sdk/middleware-expect-continue': '3.620.0',
			'@aws-sdk/middleware-flexible-checksums': '3.620.0',
			'@aws-sdk/middleware-host-header': '3.620.0',
			'@aws-sdk/middleware-location-constraint': '3.609.0',
			'@aws-sdk/middleware-logger': '3.609.0',
			'@aws-sdk/middleware-recursion-detection': '3.620.0',
			'@aws-sdk/middleware-sdk-s3': '3.635.0',
			'@aws-sdk/middleware-ssec': '3.609.0',
			'@aws-sdk/middleware-user-agent': '3.645.0',
			'@aws-sdk/region-config-resolver': '3.614.0',
			'@aws-sdk/signature-v4-multi-region': '3.635.0',
			'@aws-sdk/types': '3.609.0',
			'@aws-sdk/util-endpoints': '3.645.0',
			'@aws-sdk/util-user-agent-browser': '3.609.0',
			'@aws-sdk/util-user-agent-node': '3.614.0',
			'@aws-sdk/xml-builder': '3.609.0',
			'@smithy/config-resolver': '^3.0.5',
			'@smithy/core': '^2.4.0',
			'@smithy/eventstream-serde-browser': '^3.0.6',
			'@smithy/eventstream-serde-config-resolver': '^3.0.3',
			'@smithy/eventstream-serde-node': '^3.0.5',
			'@smithy/fetch-http-handler': '^3.2.4',
			'@smithy/hash-blob-browser': '^3.1.2',
			'@smithy/hash-node': '^3.0.3',
			'@smithy/hash-stream-node': '^3.1.2',
			'@smithy/invalid-dependency': '^3.0.3',
			'@smithy/md5-js': '^3.0.3',
			'@smithy/middleware-content-length': '^3.0.5',
			'@smithy/middleware-endpoint': '^3.1.0',
			'@smithy/middleware-retry': '^3.0.15',
			'@smithy/middleware-serde': '^3.0.3',
			'@smithy/middleware-stack': '^3.0.3',
			'@smithy/node-config-provider': '^3.1.4',
			'@smithy/node-http-handler': '^3.1.4',
			'@smithy/protocol-http': '^4.1.0',
			'@smithy/smithy-client': '^3.2.0',
			'@smithy/types': '^3.3.0',
			'@smithy/url-parser': '^3.0.3',
			'@smithy/util-base64': '^3.0.0',
			'@smithy/util-body-length-browser': '^3.0.0',
			'@smithy/util-body-length-node': '^3.0.0',
			'@smithy/util-defaults-mode-browser': '^3.0.15',
			'@smithy/util-defaults-mode-node': '^3.0.15',
			'@smithy/util-endpoints': '^2.0.5',
			'@smithy/util-middleware': '^3.0.3',
			'@smithy/util-retry': '^3.0.3',
			'@smithy/util-stream': '^3.1.3',
			'@smithy/util-utf8': '^3.0.0',
			'@smithy/util-waiter': '^3.1.2',
			tslib: '^2.6.2',
		},
		devDependencies: {
			'@aws-sdk/signature-v4-crt': '3.635.0',
			'@tsconfig/node16': '16.1.3',
			'@types/chai': '^4.2.11',
			'@types/mocha': '^8.0.4',
			'@types/node': '^16.18.96',
			concurrently: '7.0.0',
			'downlevel-dts': '0.10.1',
			rimraf: '3.0.2',
			typescript: '~4.9.5',
		},
		engines: { node: '>=16.0.0' },
		typesVersions: { '<4.0': { 'dist-types/*': ['dist-types/ts3.4/*'] } },
		files: ['dist-*/**'],
		author: {
			name: 'AWS SDK for JavaScript Team',
			url: 'https://aws.amazon.com/javascript/',
		},
		license: 'Apache-2.0',
		browser: { './dist-es/runtimeConfig': './dist-es/runtimeConfig.browser' },
		'react-native': {
			'./dist-es/runtimeConfig': './dist-es/runtimeConfig.native',
		},
		homepage:
			'https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3',
		repository: {
			type: 'git',
			url: 'https://github.com/aws/aws-sdk-js-v3.git',
			directory: 'clients/client-s3',
		},
	}
})
var Vh = E((SIe, cT) => {
	'use strict'
	var Qu = Object.defineProperty,
		TZ = Object.getOwnPropertyDescriptor,
		BZ = Object.getOwnPropertyNames,
		NZ = Object.prototype.hasOwnProperty,
		DZ = (e, t) => Qu(e, 'name', { value: t, configurable: !0 }),
		LZ = (e, t) => {
			for (var r in t) Qu(e, r, { get: t[r], enumerable: !0 })
		},
		FZ = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of BZ(t))
					!NZ.call(e, i) &&
						i !== r &&
						Qu(e, i, {
							get: () => t[i],
							enumerable: !(n = TZ(t, i)) || n.enumerable,
						})
			return e
		},
		MZ = (e) => FZ(Qu({}, '__esModule', { value: !0 }), e),
		tT = {}
	LZ(tT, {
		ENV_ACCOUNT_ID: () => aT,
		ENV_CREDENTIAL_SCOPE: () => sT,
		ENV_EXPIRATION: () => oT,
		ENV_KEY: () => rT,
		ENV_SECRET: () => nT,
		ENV_SESSION: () => iT,
		fromEnv: () => jZ,
	})
	cT.exports = MZ(tT)
	var qZ = nr(),
		rT = 'AWS_ACCESS_KEY_ID',
		nT = 'AWS_SECRET_ACCESS_KEY',
		iT = 'AWS_SESSION_TOKEN',
		oT = 'AWS_CREDENTIAL_EXPIRATION',
		sT = 'AWS_CREDENTIAL_SCOPE',
		aT = 'AWS_ACCOUNT_ID',
		jZ = DZ(
			(e) => async () => {
				var t
				;(t = e?.logger) == null ||
					t.debug('@aws-sdk/credential-provider-env - fromEnv')
				let r = process.env[rT],
					n = process.env[nT],
					i = process.env[iT],
					o = process.env[oT],
					s = process.env[sT],
					c = process.env[aT]
				if (r && n)
					return {
						accessKeyId: r,
						secretAccessKey: n,
						...(i && { sessionToken: i }),
						...(o && { expiration: new Date(o) }),
						...(s && { credentialScope: s }),
						...(c && { accountId: c }),
					}
				throw new qZ.CredentialsProviderError(
					'Unable to find environment variable credentials.',
					{ logger: e?.logger },
				)
			},
			'fromEnv',
		)
})
var rl = E((CIe, bT) => {
	var tm = Object.defineProperty,
		UZ = Object.getOwnPropertyDescriptor,
		GZ = Object.getOwnPropertyNames,
		zZ = Object.prototype.hasOwnProperty,
		Et = (e, t) => tm(e, 'name', { value: t, configurable: !0 }),
		HZ = (e, t) => {
			for (var r in t) tm(e, r, { get: t[r], enumerable: !0 })
		},
		$Z = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of GZ(t))
					!zZ.call(e, i) &&
						i !== r &&
						tm(e, i, {
							get: () => t[i],
							enumerable: !(n = UZ(t, i)) || n.enumerable,
						})
			return e
		},
		VZ = (e) => $Z(tm({}, '__esModule', { value: !0 }), e),
		mT = {}
	HZ(mT, {
		DEFAULT_MAX_RETRIES: () => vT,
		DEFAULT_TIMEOUT: () => gT,
		ENV_CMDS_AUTH_TOKEN: () => Xh,
		ENV_CMDS_FULL_URI: () => Zu,
		ENV_CMDS_RELATIVE_URI: () => em,
		Endpoint: () => yT,
		fromContainerMetadata: () => YZ,
		fromInstanceMetadata: () => hee,
		getInstanceMetadataEndpoint: () => CT,
		httpRequest: () => js,
		providerConfigFromInit: () => Yh,
	})
	bT.exports = VZ(mT)
	var KZ = require('url'),
		kn = nr(),
		WZ = require('buffer'),
		XZ = require('http')
	function js(e) {
		return new Promise((t, r) => {
			var n
			let i = (0, XZ.request)({
				method: 'GET',
				...e,
				hostname:
					(n = e.hostname) == null ? void 0 : n.replace(/^\[(.+)\]$/, '$1'),
			})
			i.on('error', (o) => {
				r(
					Object.assign(
						new kn.ProviderError(
							'Unable to connect to instance metadata service',
						),
						o,
					),
				),
					i.destroy()
			}),
				i.on('timeout', () => {
					r(
						new kn.ProviderError('TimeoutError from instance metadata service'),
					),
						i.destroy()
				}),
				i.on('response', (o) => {
					let { statusCode: s = 400 } = o
					;(s < 200 || 300 <= s) &&
						(r(
							Object.assign(
								new kn.ProviderError(
									'Error response received from instance metadata service',
								),
								{ statusCode: s },
							),
						),
						i.destroy())
					let c = []
					o.on('data', (l) => {
						c.push(l)
					}),
						o.on('end', () => {
							t(WZ.Buffer.concat(c)), i.destroy()
						})
				}),
				i.end()
		})
	}
	Et(js, 'httpRequest')
	var fT = Et(
			(e) =>
				!!e &&
				typeof e == 'object' &&
				typeof e.AccessKeyId == 'string' &&
				typeof e.SecretAccessKey == 'string' &&
				typeof e.Token == 'string' &&
				typeof e.Expiration == 'string',
			'isImdsCredentials',
		),
		pT = Et(
			(e) => ({
				accessKeyId: e.AccessKeyId,
				secretAccessKey: e.SecretAccessKey,
				sessionToken: e.Token,
				expiration: new Date(e.Expiration),
				...(e.AccountId && { accountId: e.AccountId }),
			}),
			'fromImdsCredentials',
		),
		gT = 1e3,
		vT = 0,
		Yh = Et(
			({ maxRetries: e = vT, timeout: t = gT }) => ({
				maxRetries: e,
				timeout: t,
			}),
			'providerConfigFromInit',
		),
		Wh = Et((e, t) => {
			let r = e()
			for (let n = 0; n < t; n++) r = r.catch(e)
			return r
		}, 'retry'),
		Zu = 'AWS_CONTAINER_CREDENTIALS_FULL_URI',
		em = 'AWS_CONTAINER_CREDENTIALS_RELATIVE_URI',
		Xh = 'AWS_CONTAINER_AUTHORIZATION_TOKEN',
		YZ = Et((e = {}) => {
			let { timeout: t, maxRetries: r } = Yh(e)
			return () =>
				Wh(async () => {
					let n = await tee({ logger: e.logger }),
						i = JSON.parse(await JZ(t, n))
					if (!fT(i))
						throw new kn.CredentialsProviderError(
							'Invalid response received from instance metadata service.',
							{ logger: e.logger },
						)
					return pT(i)
				}, r)
		}, 'fromContainerMetadata'),
		JZ = Et(
			async (e, t) => (
				process.env[Xh] &&
					(t.headers = { ...t.headers, Authorization: process.env[Xh] }),
				(await js({ ...t, timeout: e })).toString()
			),
			'requestFromEcsImds',
		),
		QZ = '169.254.170.2',
		ZZ = { localhost: !0, '127.0.0.1': !0 },
		eee = { 'http:': !0, 'https:': !0 },
		tee = Et(async ({ logger: e }) => {
			if (process.env[em]) return { hostname: QZ, path: process.env[em] }
			if (process.env[Zu]) {
				let t = (0, KZ.parse)(process.env[Zu])
				if (!t.hostname || !(t.hostname in ZZ))
					throw new kn.CredentialsProviderError(
						`${t.hostname} is not a valid container metadata service hostname`,
						{ tryNextLink: !1, logger: e },
					)
				if (!t.protocol || !(t.protocol in eee))
					throw new kn.CredentialsProviderError(
						`${t.protocol} is not a valid container metadata service protocol`,
						{ tryNextLink: !1, logger: e },
					)
				return { ...t, port: t.port ? parseInt(t.port, 10) : void 0 }
			}
			throw new kn.CredentialsProviderError(
				`The container metadata credential provider cannot be used unless the ${em} or ${Zu} environment variable is set`,
				{ tryNextLink: !1, logger: e },
			)
		}, 'getCmdsUri'),
		hT = class _T extends kn.CredentialsProviderError {
			constructor(t, r = !0) {
				super(t, r),
					(this.tryNextLink = r),
					(this.name = 'InstanceMetadataV1FallbackError'),
					Object.setPrototypeOf(this, _T.prototype)
			}
		}
	Et(hT, 'InstanceMetadataV1FallbackError')
	var ree = hT,
		Jh = Hn(),
		nee = po(),
		yT = ((e) => (
			(e.IPv4 = 'http://169.254.169.254'),
			(e.IPv6 = 'http://[fd00:ec2::254]'),
			e
		))(yT || {}),
		iee = 'AWS_EC2_METADATA_SERVICE_ENDPOINT',
		oee = 'ec2_metadata_service_endpoint',
		see = {
			environmentVariableSelector: (e) => e[iee],
			configFileSelector: (e) => e[oee],
			default: void 0,
		},
		ST = ((e) => ((e.IPv4 = 'IPv4'), (e.IPv6 = 'IPv6'), e))(ST || {}),
		aee = 'AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE',
		cee = 'ec2_metadata_service_endpoint_mode',
		lee = {
			environmentVariableSelector: (e) => e[aee],
			configFileSelector: (e) => e[cee],
			default: 'IPv4',
		},
		CT = Et(
			async () => (0, nee.parseUrl)((await dee()) || (await uee())),
			'getInstanceMetadataEndpoint',
		),
		dee = Et(async () => (0, Jh.loadConfig)(see)(), 'getFromEndpointConfig'),
		uee = Et(async () => {
			let e = await (0, Jh.loadConfig)(lee)()
			switch (e) {
				case 'IPv4':
					return 'http://169.254.169.254'
				case 'IPv6':
					return 'http://[fd00:ec2::254]'
				default:
					throw new Error(
						`Unsupported endpoint mode: ${e}. Select from ${Object.values(ST)}`,
					)
			}
		}, 'getFromEndpointModeConfig'),
		mee = 5 * 60,
		fee = 5 * 60,
		pee =
			'https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html',
		lT = Et((e, t) => {
			let r = mee + Math.floor(Math.random() * fee),
				n = new Date(Date.now() + r * 1e3)
			t.warn(
				`Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(n)}.
For more information, please visit: ` + pee,
			)
			let i = e.originalExpiration ?? e.expiration
			return { ...e, ...(i ? { originalExpiration: i } : {}), expiration: n }
		}, 'getExtendedInstanceMetadataCredentials'),
		gee = Et((e, t = {}) => {
			let r = t?.logger || console,
				n
			return async () => {
				let i
				try {
					;(i = await e()),
						i.expiration &&
							i.expiration.getTime() < Date.now() &&
							(i = lT(i, r))
				} catch (o) {
					if (n) r.warn('Credential renew failed: ', o), (i = lT(n, r))
					else throw o
				}
				return (n = i), i
			}
		}, 'staticStabilityProvider'),
		ET = '/latest/meta-data/iam/security-credentials/',
		vee = '/latest/api/token',
		Kh = 'AWS_EC2_METADATA_V1_DISABLED',
		dT = 'ec2_metadata_v1_disabled',
		uT = 'x-aws-ec2-metadata-token',
		hee = Et(
			(e = {}) => gee(_ee(e), { logger: e.logger }),
			'fromInstanceMetadata',
		),
		_ee = Et((e = {}) => {
			let t = !1,
				{ logger: r, profile: n } = e,
				{ timeout: i, maxRetries: o } = Yh(e),
				s = Et(async (c, l) => {
					var u
					if (t || ((u = l.headers) == null ? void 0 : u[uT]) == null) {
						let p = !1,
							g = !1,
							v = await (0, Jh.loadConfig)(
								{
									environmentVariableSelector: (_) => {
										let y = _[Kh]
										if (((g = !!y && y !== 'false'), y === void 0))
											throw new kn.CredentialsProviderError(
												`${Kh} not set in env, checking config file next.`,
												{ logger: e.logger },
											)
										return g
									},
									configFileSelector: (_) => {
										let y = _[dT]
										return (p = !!y && y !== 'false'), p
									},
									default: !1,
								},
								{ profile: n },
							)()
						if (e.ec2MetadataV1Disabled || v) {
							let _ = []
							throw (
								(e.ec2MetadataV1Disabled &&
									_.push(
										'credential provider initialization (runtime option ec2MetadataV1Disabled)',
									),
								p && _.push(`config file profile (${dT})`),
								g && _.push(`process environment variable (${Kh})`),
								new ree(
									`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${_.join(', ')}].`,
								))
							)
						}
					}
					let f = (
						await Wh(async () => {
							let p
							try {
								p = await See(l)
							} catch (g) {
								throw (g.statusCode === 401 && (t = !1), g)
							}
							return p
						}, c)
					).trim()
					return Wh(async () => {
						let p
						try {
							p = await Cee(f, l, e)
						} catch (g) {
							throw (g.statusCode === 401 && (t = !1), g)
						}
						return p
					}, c)
				}, 'getCredentials')
			return async () => {
				let c = await CT()
				if (t)
					return (
						r?.debug(
							'AWS SDK Instance Metadata',
							'using v1 fallback (no token fetch)',
						),
						s(o, { ...c, timeout: i })
					)
				{
					let l
					try {
						l = (await yee({ ...c, timeout: i })).toString()
					} catch (u) {
						if (u?.statusCode === 400)
							throw Object.assign(u, {
								message: 'EC2 Metadata token request returned error',
							})
						return (
							(u.message === 'TimeoutError' ||
								[403, 404, 405].includes(u.statusCode)) &&
								(t = !0),
							r?.debug(
								'AWS SDK Instance Metadata',
								'using v1 fallback (initial)',
							),
							s(o, { ...c, timeout: i })
						)
					}
					return s(o, { ...c, headers: { [uT]: l }, timeout: i })
				}
			}
		}, 'getInstanceMetadataProvider'),
		yee = Et(
			async (e) =>
				js({
					...e,
					path: vee,
					method: 'PUT',
					headers: { 'x-aws-ec2-metadata-token-ttl-seconds': '21600' },
				}),
			'getMetadataToken',
		),
		See = Et(
			async (e) => (await js({ ...e, path: ET })).toString(),
			'getProfile',
		),
		Cee = Et(async (e, t, r) => {
			let n = JSON.parse((await js({ ...t, path: ET + e })).toString())
			if (!fT(n))
				throw new kn.CredentialsProviderError(
					'Invalid response received from instance metadata service.',
					{ logger: r.logger },
				)
			return pT(n)
		}, 'getCredentialsFromProfile')
})
var wT = E((rm) => {
	'use strict'
	Object.defineProperty(rm, '__esModule', { value: !0 })
	rm.checkUrl = void 0
	var Eee = nr(),
		bee = '169.254.170.2',
		wee = '169.254.170.23',
		xee = '[fd00:ec2::23]',
		Pee = (e, t) => {
			if (
				e.protocol !== 'https:' &&
				!(e.hostname === bee || e.hostname === wee || e.hostname === xee)
			) {
				if (e.hostname.includes('[')) {
					if (
						e.hostname === '[::1]' ||
						e.hostname === '[0000:0000:0000:0000:0000:0000:0000:0001]'
					)
						return
				} else {
					if (e.hostname === 'localhost') return
					let r = e.hostname.split('.'),
						n = (i) => {
							let o = parseInt(i, 10)
							return 0 <= o && o <= 255
						}
					if (r[0] === '127' && n(r[1]) && n(r[2]) && n(r[3]) && r.length === 4)
						return
				}
				throw new Eee.CredentialsProviderError(
					`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`,
					{ logger: t },
				)
			}
		}
	rm.checkUrl = Pee
})
var xT = E((Us) => {
	'use strict'
	Object.defineProperty(Us, '__esModule', { value: !0 })
	Us.getCredentials = Us.createGetRequest = void 0
	var Qh = nr(),
		Aee = Xe(),
		Oee = ze(),
		Ree = Rc()
	function kee(e) {
		return new Aee.HttpRequest({
			protocol: e.protocol,
			hostname: e.hostname,
			port: Number(e.port),
			path: e.pathname,
			query: Array.from(e.searchParams.entries()).reduce(
				(t, [r, n]) => ((t[r] = n), t),
				{},
			),
			fragment: e.hash,
		})
	}
	Us.createGetRequest = kee
	async function Iee(e, t) {
		let n = await (0, Ree.sdkStreamMixin)(e.body).transformToString()
		if (e.statusCode === 200) {
			let i = JSON.parse(n)
			if (
				typeof i.AccessKeyId != 'string' ||
				typeof i.SecretAccessKey != 'string' ||
				typeof i.Token != 'string' ||
				typeof i.Expiration != 'string'
			)
				throw new Qh.CredentialsProviderError(
					'HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }',
					{ logger: t },
				)
			return {
				accessKeyId: i.AccessKeyId,
				secretAccessKey: i.SecretAccessKey,
				sessionToken: i.Token,
				expiration: (0, Oee.parseRfc3339DateTime)(i.Expiration),
			}
		}
		if (e.statusCode >= 400 && e.statusCode < 500) {
			let i = {}
			try {
				i = JSON.parse(n)
			} catch {}
			throw Object.assign(
				new Qh.CredentialsProviderError(
					`Server responded with status: ${e.statusCode}`,
					{ logger: t },
				),
				{ Code: i.Code, Message: i.Message },
			)
		}
		throw new Qh.CredentialsProviderError(
			`Server responded with status: ${e.statusCode}`,
			{ logger: t },
		)
	}
	Us.getCredentials = Iee
})
var PT = E((nm) => {
	'use strict'
	Object.defineProperty(nm, '__esModule', { value: !0 })
	nm.retryWrapper = void 0
	var Tee = (e, t, r) => async () => {
		for (let n = 0; n < t; ++n)
			try {
				return await e()
			} catch {
				await new Promise((o) => setTimeout(o, r))
			}
		return await e()
	}
	nm.retryWrapper = Tee
})
var RT = E((im) => {
	'use strict'
	Object.defineProperty(im, '__esModule', { value: !0 })
	im.fromHttp = void 0
	var Bee = (Rn(), ve(On)),
		Nee = co(),
		AT = nr(),
		Dee = Bee.__importDefault(require('fs/promises')),
		Lee = wT(),
		OT = xT(),
		Fee = PT(),
		Mee = 'AWS_CONTAINER_CREDENTIALS_RELATIVE_URI',
		qee = 'http://169.254.170.2',
		jee = 'AWS_CONTAINER_CREDENTIALS_FULL_URI',
		Uee = 'AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE',
		Gee = 'AWS_CONTAINER_AUTHORIZATION_TOKEN',
		zee = (e = {}) => {
			e.logger?.debug('@aws-sdk/credential-provider-http - fromHttp')
			let t,
				r = e.awsContainerCredentialsRelativeUri ?? process.env[Mee],
				n = e.awsContainerCredentialsFullUri ?? process.env[jee],
				i = e.awsContainerAuthorizationToken ?? process.env[Gee],
				o = e.awsContainerAuthorizationTokenFile ?? process.env[Uee],
				s =
					e.logger?.constructor?.name === 'NoOpLogger' || !e.logger
						? console.warn
						: e.logger.warn
			if (
				(r &&
					n &&
					(s(
						'@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.',
					),
					s('awsContainerCredentialsFullUri will take precedence.')),
				i &&
					o &&
					(s(
						'@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.',
					),
					s('awsContainerAuthorizationToken will take precedence.')),
				n)
			)
				t = n
			else if (r) t = `${qee}${r}`
			else
				throw new AT.CredentialsProviderError(
					`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`,
					{ logger: e.logger },
				)
			let c = new URL(t)
			;(0, Lee.checkUrl)(c, e.logger)
			let l = new Nee.NodeHttpHandler({
				requestTimeout: e.timeout ?? 1e3,
				connectionTimeout: e.timeout ?? 1e3,
			})
			return (0, Fee.retryWrapper)(
				async () => {
					let u = (0, OT.createGetRequest)(c)
					i
						? (u.headers.Authorization = i)
						: o &&
							(u.headers.Authorization = (
								await Dee.default.readFile(o)
							).toString())
					try {
						let m = await l.handle(u)
						return (0, OT.getCredentials)(m.response)
					} catch (m) {
						throw new AT.CredentialsProviderError(String(m), {
							logger: e.logger,
						})
					}
				},
				e.maxRetries ?? 3,
				e.timeout ?? 1e3,
			)
		}
	im.fromHttp = zee
})
var Zh = E((om) => {
	'use strict'
	Object.defineProperty(om, '__esModule', { value: !0 })
	om.fromHttp = void 0
	var Hee = RT()
	Object.defineProperty(om, 'fromHttp', {
		enumerable: !0,
		get: function () {
			return Hee.fromHttp
		},
	})
})
var e_ = E((Pi) => {
	'use strict'
	Object.defineProperty(Pi, '__esModule', { value: !0 })
	Pi.resolveHttpAuthSchemeConfig =
		Pi.defaultSSOHttpAuthSchemeProvider =
		Pi.defaultSSOHttpAuthSchemeParametersProvider =
			void 0
	var $ee = (zt(), ve(Gt)),
		kT = Tr(),
		Vee = async (e, t, r) => ({
			operation: (0, kT.getSmithyContext)(t).operation,
			region:
				(await (0, kT.normalizeProvider)(e.region)()) ||
				(() => {
					throw new Error(
						'expected `region` to be configured for `aws.auth#sigv4`',
					)
				})(),
		})
	Pi.defaultSSOHttpAuthSchemeParametersProvider = Vee
	function Kee(e) {
		return {
			schemeId: 'aws.auth#sigv4',
			signingProperties: { name: 'awsssoportal', region: e.region },
			propertiesExtractor: (t, r) => ({
				signingProperties: { config: t, context: r },
			}),
		}
	}
	function sm(e) {
		return { schemeId: 'smithy.api#noAuth' }
	}
	var Wee = (e) => {
		let t = []
		switch (e.operation) {
			case 'GetRoleCredentials': {
				t.push(sm(e))
				break
			}
			case 'ListAccountRoles': {
				t.push(sm(e))
				break
			}
			case 'ListAccounts': {
				t.push(sm(e))
				break
			}
			case 'Logout': {
				t.push(sm(e))
				break
			}
			default:
				t.push(Kee(e))
		}
		return t
	}
	Pi.defaultSSOHttpAuthSchemeProvider = Wee
	var Xee = (e) => ({ ...(0, $ee.resolveAwsSdkSigV4Config)(e) })
	Pi.resolveHttpAuthSchemeConfig = Xee
})
var IT = E((OIe, Yee) => {
	Yee.exports = {
		name: '@aws-sdk/client-sso',
		description:
			'AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native',
		version: '3.645.0',
		scripts: {
			build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
			'build:cjs': 'node ../../scripts/compilation/inline client-sso',
			'build:es': 'tsc -p tsconfig.es.json',
			'build:include:deps':
				'lerna run --scope $npm_package_name --include-dependencies build',
			'build:types': 'tsc -p tsconfig.types.json',
			'build:types:downlevel': 'downlevel-dts dist-types dist-types/ts3.4',
			clean: 'rimraf ./dist-* && rimraf *.tsbuildinfo',
			'extract:docs': 'api-extractor run --local',
			'generate:client':
				'node ../../scripts/generate-clients/single-service --solo sso',
		},
		main: './dist-cjs/index.js',
		types: './dist-types/index.d.ts',
		module: './dist-es/index.js',
		sideEffects: !1,
		dependencies: {
			'@aws-crypto/sha256-browser': '5.2.0',
			'@aws-crypto/sha256-js': '5.2.0',
			'@aws-sdk/core': '3.635.0',
			'@aws-sdk/middleware-host-header': '3.620.0',
			'@aws-sdk/middleware-logger': '3.609.0',
			'@aws-sdk/middleware-recursion-detection': '3.620.0',
			'@aws-sdk/middleware-user-agent': '3.645.0',
			'@aws-sdk/region-config-resolver': '3.614.0',
			'@aws-sdk/types': '3.609.0',
			'@aws-sdk/util-endpoints': '3.645.0',
			'@aws-sdk/util-user-agent-browser': '3.609.0',
			'@aws-sdk/util-user-agent-node': '3.614.0',
			'@smithy/config-resolver': '^3.0.5',
			'@smithy/core': '^2.4.0',
			'@smithy/fetch-http-handler': '^3.2.4',
			'@smithy/hash-node': '^3.0.3',
			'@smithy/invalid-dependency': '^3.0.3',
			'@smithy/middleware-content-length': '^3.0.5',
			'@smithy/middleware-endpoint': '^3.1.0',
			'@smithy/middleware-retry': '^3.0.15',
			'@smithy/middleware-serde': '^3.0.3',
			'@smithy/middleware-stack': '^3.0.3',
			'@smithy/node-config-provider': '^3.1.4',
			'@smithy/node-http-handler': '^3.1.4',
			'@smithy/protocol-http': '^4.1.0',
			'@smithy/smithy-client': '^3.2.0',
			'@smithy/types': '^3.3.0',
			'@smithy/url-parser': '^3.0.3',
			'@smithy/util-base64': '^3.0.0',
			'@smithy/util-body-length-browser': '^3.0.0',
			'@smithy/util-body-length-node': '^3.0.0',
			'@smithy/util-defaults-mode-browser': '^3.0.15',
			'@smithy/util-defaults-mode-node': '^3.0.15',
			'@smithy/util-endpoints': '^2.0.5',
			'@smithy/util-middleware': '^3.0.3',
			'@smithy/util-retry': '^3.0.3',
			'@smithy/util-utf8': '^3.0.0',
			tslib: '^2.6.2',
		},
		devDependencies: {
			'@tsconfig/node16': '16.1.3',
			'@types/node': '^16.18.96',
			concurrently: '7.0.0',
			'downlevel-dts': '0.10.1',
			rimraf: '3.0.2',
			typescript: '~4.9.5',
		},
		engines: { node: '>=16.0.0' },
		typesVersions: { '<4.0': { 'dist-types/*': ['dist-types/ts3.4/*'] } },
		files: ['dist-*/**'],
		author: {
			name: 'AWS SDK for JavaScript Team',
			url: 'https://aws.amazon.com/javascript/',
		},
		license: 'Apache-2.0',
		browser: { './dist-es/runtimeConfig': './dist-es/runtimeConfig.browser' },
		'react-native': {
			'./dist-es/runtimeConfig': './dist-es/runtimeConfig.native',
		},
		homepage:
			'https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso',
		repository: {
			type: 'git',
			url: 'https://github.com/aws/aws-sdk-js-v3.git',
			directory: 'clients/client-sso',
		},
	}
})
var nl = E((RIe, MT) => {
	'use strict'
	var am = Object.defineProperty,
		Jee = Object.getOwnPropertyDescriptor,
		Qee = Object.getOwnPropertyNames,
		Zee = Object.prototype.hasOwnProperty,
		BT = (e, t) => am(e, 'name', { value: t, configurable: !0 }),
		ete = (e, t) => {
			for (var r in t) am(e, r, { get: t[r], enumerable: !0 })
		},
		tte = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Qee(t))
					!Zee.call(e, i) &&
						i !== r &&
						am(e, i, {
							get: () => t[i],
							enumerable: !(n = Jee(t, i)) || n.enumerable,
						})
			return e
		},
		rte = (e) => tte(am({}, '__esModule', { value: !0 }), e),
		NT = {}
	ete(NT, {
		UA_APP_ID_ENV_NAME: () => LT,
		UA_APP_ID_INI_NAME: () => FT,
		crtAvailability: () => DT,
		defaultUserAgent: () => ote,
	})
	MT.exports = rte(NT)
	var nte = Hn(),
		TT = require('os'),
		t_ = require('process'),
		DT = { isCrtAvailable: !1 },
		ite = BT(
			() => (DT.isCrtAvailable ? ['md/crt-avail'] : null),
			'isCrtAvailable',
		),
		LT = 'AWS_SDK_UA_APP_ID',
		FT = 'sdk-ua-app-id',
		ote = BT(({ serviceId: e, clientVersion: t }) => {
			let r = [
					['aws-sdk-js', t],
					['ua', '2.0'],
					[`os/${(0, TT.platform)()}`, (0, TT.release)()],
					['lang/js'],
					['md/nodejs', `${t_.versions.node}`],
				],
				n = ite()
			n && r.push(n),
				e && r.push([`api/${e}`, t]),
				t_.env.AWS_EXECUTION_ENV &&
					r.push([`exec-env/${t_.env.AWS_EXECUTION_ENV}`])
			let i = (0, nte.loadConfig)({
					environmentVariableSelector: (s) => s[LT],
					configFileSelector: (s) => s[FT],
					default: void 0,
				})(),
				o
			return async () => {
				if (!o) {
					let s = await i
					o = s ? [...r, [`app/${s}`]] : [...r]
				}
				return o
			}
		}, 'defaultUserAgent')
})
var il = E((IIe, zT) => {
	var cm = Object.defineProperty,
		ste = Object.getOwnPropertyDescriptor,
		ate = Object.getOwnPropertyNames,
		cte = Object.prototype.hasOwnProperty,
		jT = (e, t) => cm(e, 'name', { value: t, configurable: !0 }),
		lte = (e, t) => {
			for (var r in t) cm(e, r, { get: t[r], enumerable: !0 })
		},
		dte = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of ate(t))
					!cte.call(e, i) &&
						i !== r &&
						cm(e, i, {
							get: () => t[i],
							enumerable: !(n = ste(t, i)) || n.enumerable,
						})
			return e
		},
		ute = (e) => dte(cm({}, '__esModule', { value: !0 }), e),
		UT = {}
	lte(UT, { Hash: () => pte })
	zT.exports = ute(UT)
	var r_ = Cs(),
		mte = rr(),
		fte = require('buffer'),
		qT = require('crypto'),
		GT = class {
			constructor(t, r) {
				;(this.algorithmIdentifier = t), (this.secret = r), this.reset()
			}
			update(t, r) {
				this.hash.update((0, mte.toUint8Array)(n_(t, r)))
			}
			digest() {
				return Promise.resolve(this.hash.digest())
			}
			reset() {
				this.hash = this.secret
					? (0, qT.createHmac)(this.algorithmIdentifier, n_(this.secret))
					: (0, qT.createHash)(this.algorithmIdentifier)
			}
		}
	jT(GT, 'Hash')
	var pte = GT
	function n_(e, t) {
		return fte.Buffer.isBuffer(e)
			? e
			: typeof e == 'string'
				? (0, r_.fromString)(e, t)
				: ArrayBuffer.isView(e)
					? (0, r_.fromArrayBuffer)(e.buffer, e.byteOffset, e.byteLength)
					: (0, r_.fromArrayBuffer)(e)
	}
	jT(n_, 'castSourceData')
})
var ol = E((TIe, VT) => {
	var lm = Object.defineProperty,
		gte = Object.getOwnPropertyDescriptor,
		vte = Object.getOwnPropertyNames,
		hte = Object.prototype.hasOwnProperty,
		_te = (e, t) => lm(e, 'name', { value: t, configurable: !0 }),
		yte = (e, t) => {
			for (var r in t) lm(e, r, { get: t[r], enumerable: !0 })
		},
		Ste = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of vte(t))
					!hte.call(e, i) &&
						i !== r &&
						lm(e, i, {
							get: () => t[i],
							enumerable: !(n = gte(t, i)) || n.enumerable,
						})
			return e
		},
		Cte = (e) => Ste(lm({}, '__esModule', { value: !0 }), e),
		$T = {}
	yte($T, { calculateBodyLength: () => Ete })
	VT.exports = Cte($T)
	var HT = require('fs'),
		Ete = _te((e) => {
			if (!e) return 0
			if (typeof e == 'string') return Buffer.byteLength(e)
			if (typeof e.byteLength == 'number') return e.byteLength
			if (typeof e.size == 'number') return e.size
			if (typeof e.start == 'number' && typeof e.end == 'number')
				return e.end + 1 - e.start
			if (typeof e.path == 'string' || Buffer.isBuffer(e.path))
				return (0, HT.lstatSync)(e.path).size
			if (typeof e.fd == 'number') return (0, HT.fstatSync)(e.fd).size
			throw new Error(`Body Length computation failed for ${e}`)
		}, 'calculateBodyLength')
})
var aB = E((dm) => {
	'use strict'
	Object.defineProperty(dm, '__esModule', { value: !0 })
	dm.ruleSet = void 0
	var nB = 'required',
		Lr = 'fn',
		Fr = 'argv',
		Hs = 'ref',
		KT = !0,
		WT = 'isSet',
		sl = 'booleanEquals',
		Gs = 'error',
		zs = 'endpoint',
		Xn = 'tree',
		i_ = 'PartitionResult',
		o_ = 'getAttr',
		XT = { [nB]: !1, type: 'String' },
		YT = { [nB]: !0, default: !1, type: 'Boolean' },
		JT = { [Hs]: 'Endpoint' },
		iB = { [Lr]: sl, [Fr]: [{ [Hs]: 'UseFIPS' }, !0] },
		oB = { [Lr]: sl, [Fr]: [{ [Hs]: 'UseDualStack' }, !0] },
		Dr = {},
		QT = { [Lr]: o_, [Fr]: [{ [Hs]: i_ }, 'supportsFIPS'] },
		sB = { [Hs]: i_ },
		ZT = {
			[Lr]: sl,
			[Fr]: [!0, { [Lr]: o_, [Fr]: [sB, 'supportsDualStack'] }],
		},
		eB = [iB],
		tB = [oB],
		rB = [{ [Hs]: 'Region' }],
		bte = {
			version: '1.0',
			parameters: { Region: XT, UseDualStack: YT, UseFIPS: YT, Endpoint: XT },
			rules: [
				{
					conditions: [{ [Lr]: WT, [Fr]: [JT] }],
					rules: [
						{
							conditions: eB,
							error:
								'Invalid Configuration: FIPS and custom endpoint are not supported',
							type: Gs,
						},
						{
							conditions: tB,
							error:
								'Invalid Configuration: Dualstack and custom endpoint are not supported',
							type: Gs,
						},
						{ endpoint: { url: JT, properties: Dr, headers: Dr }, type: zs },
					],
					type: Xn,
				},
				{
					conditions: [{ [Lr]: WT, [Fr]: rB }],
					rules: [
						{
							conditions: [{ [Lr]: 'aws.partition', [Fr]: rB, assign: i_ }],
							rules: [
								{
									conditions: [iB, oB],
									rules: [
										{
											conditions: [{ [Lr]: sl, [Fr]: [KT, QT] }, ZT],
											rules: [
												{
													endpoint: {
														url: 'https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}',
														properties: Dr,
														headers: Dr,
													},
													type: zs,
												},
											],
											type: Xn,
										},
										{
											error:
												'FIPS and DualStack are enabled, but this partition does not support one or both',
											type: Gs,
										},
									],
									type: Xn,
								},
								{
									conditions: eB,
									rules: [
										{
											conditions: [{ [Lr]: sl, [Fr]: [QT, KT] }],
											rules: [
												{
													conditions: [
														{
															[Lr]: 'stringEquals',
															[Fr]: [
																{ [Lr]: o_, [Fr]: [sB, 'name'] },
																'aws-us-gov',
															],
														},
													],
													endpoint: {
														url: 'https://portal.sso.{Region}.amazonaws.com',
														properties: Dr,
														headers: Dr,
													},
													type: zs,
												},
												{
													endpoint: {
														url: 'https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}',
														properties: Dr,
														headers: Dr,
													},
													type: zs,
												},
											],
											type: Xn,
										},
										{
											error:
												'FIPS is enabled but this partition does not support FIPS',
											type: Gs,
										},
									],
									type: Xn,
								},
								{
									conditions: tB,
									rules: [
										{
											conditions: [ZT],
											rules: [
												{
													endpoint: {
														url: 'https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}',
														properties: Dr,
														headers: Dr,
													},
													type: zs,
												},
											],
											type: Xn,
										},
										{
											error:
												'DualStack is enabled but this partition does not support DualStack',
											type: Gs,
										},
									],
									type: Xn,
								},
								{
									endpoint: {
										url: 'https://portal.sso.{Region}.{PartitionResult#dnsSuffix}',
										properties: Dr,
										headers: Dr,
									},
									type: zs,
								},
							],
							type: Xn,
						},
					],
					type: Xn,
				},
				{ error: 'Invalid Configuration: Missing Region', type: Gs },
			],
		}
	dm.ruleSet = bte
})
var lB = E((um) => {
	'use strict'
	Object.defineProperty(um, '__esModule', { value: !0 })
	um.defaultEndpointResolver = void 0
	var wte = Bs(),
		cB = Is(),
		xte = aB(),
		Pte = (e, t = {}) =>
			(0, cB.resolveEndpoint)(xte.ruleSet, {
				endpointParams: e,
				logger: t.logger,
			})
	um.defaultEndpointResolver = Pte
	cB.customEndpointFunctions.aws = wte.awsEndpointFunctions
})
var mB = E((mm) => {
	'use strict'
	Object.defineProperty(mm, '__esModule', { value: !0 })
	mm.getRuntimeConfig = void 0
	var Ate = (zt(), ve(Gt)),
		Ote = (Ut(), ve(ir)),
		Rte = ze(),
		kte = po(),
		dB = gi(),
		uB = rr(),
		Ite = e_(),
		Tte = lB(),
		Bte = (e) => ({
			apiVersion: '2019-06-10',
			base64Decoder: e?.base64Decoder ?? dB.fromBase64,
			base64Encoder: e?.base64Encoder ?? dB.toBase64,
			disableHostPrefix: e?.disableHostPrefix ?? !1,
			endpointProvider: e?.endpointProvider ?? Tte.defaultEndpointResolver,
			extensions: e?.extensions ?? [],
			httpAuthSchemeProvider:
				e?.httpAuthSchemeProvider ?? Ite.defaultSSOHttpAuthSchemeProvider,
			httpAuthSchemes: e?.httpAuthSchemes ?? [
				{
					schemeId: 'aws.auth#sigv4',
					identityProvider: (t) => t.getIdentityProvider('aws.auth#sigv4'),
					signer: new Ate.AwsSdkSigV4Signer(),
				},
				{
					schemeId: 'smithy.api#noAuth',
					identityProvider: (t) =>
						t.getIdentityProvider('smithy.api#noAuth') || (async () => ({})),
					signer: new Ote.NoAuthSigner(),
				},
			],
			logger: e?.logger ?? new Rte.NoOpLogger(),
			serviceId: e?.serviceId ?? 'SSO',
			urlParser: e?.urlParser ?? kte.parseUrl,
			utf8Decoder: e?.utf8Decoder ?? uB.fromUtf8,
			utf8Encoder: e?.utf8Encoder ?? uB.toUtf8,
		})
	mm.getRuntimeConfig = Bte
})
var cl = E((LIe, _B) => {
	var Nte = Object.create,
		al = Object.defineProperty,
		Dte = Object.getOwnPropertyDescriptor,
		Lte = Object.getOwnPropertyNames,
		Fte = Object.getPrototypeOf,
		Mte = Object.prototype.hasOwnProperty,
		s_ = (e, t) => al(e, 'name', { value: t, configurable: !0 }),
		qte = (e, t) => {
			for (var r in t) al(e, r, { get: t[r], enumerable: !0 })
		},
		vB = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Lte(t))
					!Mte.call(e, i) &&
						i !== r &&
						al(e, i, {
							get: () => t[i],
							enumerable: !(n = Dte(t, i)) || n.enumerable,
						})
			return e
		},
		jte = (e, t, r) => (
			(r = e != null ? Nte(Fte(e)) : {}),
			vB(
				t || !e || !e.__esModule
					? al(r, 'default', { value: e, enumerable: !0 })
					: r,
				e,
			)
		),
		Ute = (e) => vB(al({}, '__esModule', { value: !0 }), e),
		hB = {}
	qte(hB, { resolveDefaultsModeConfig: () => Jte })
	_B.exports = Ute(hB)
	var Gte = wn(),
		fB = Hn(),
		zte = nr(),
		Hte = 'AWS_EXECUTION_ENV',
		pB = 'AWS_REGION',
		gB = 'AWS_DEFAULT_REGION',
		$te = 'AWS_EC2_METADATA_DISABLED',
		Vte = ['in-region', 'cross-region', 'mobile', 'standard', 'legacy'],
		Kte = '/latest/meta-data/placement/region',
		Wte = 'AWS_DEFAULTS_MODE',
		Xte = 'defaults_mode',
		Yte = {
			environmentVariableSelector: (e) => e[Wte],
			configFileSelector: (e) => e[Xte],
			default: 'legacy',
		},
		Jte = s_(
			({
				region: e = (0, fB.loadConfig)(Gte.NODE_REGION_CONFIG_OPTIONS),
				defaultsMode: t = (0, fB.loadConfig)(Yte),
			} = {}) =>
				(0, zte.memoize)(async () => {
					let r = typeof t == 'function' ? await t() : t
					switch (r?.toLowerCase()) {
						case 'auto':
							return Qte(e)
						case 'in-region':
						case 'cross-region':
						case 'mobile':
						case 'standard':
						case 'legacy':
							return Promise.resolve(r?.toLocaleLowerCase())
						case void 0:
							return Promise.resolve('legacy')
						default:
							throw new Error(
								`Invalid parameter for "defaultsMode", expect ${Vte.join(', ')}, got ${r}`,
							)
					}
				}),
			'resolveDefaultsModeConfig',
		),
		Qte = s_(async (e) => {
			if (e) {
				let t = typeof e == 'function' ? await e() : e,
					r = await Zte()
				return r ? (t === r ? 'in-region' : 'cross-region') : 'standard'
			}
			return 'standard'
		}, 'resolveNodeDefaultsModeAuto'),
		Zte = s_(async () => {
			if (process.env[Hte] && (process.env[pB] || process.env[gB]))
				return process.env[pB] ?? process.env[gB]
			if (!process.env[$te])
				try {
					let { getInstanceMetadataEndpoint: e, httpRequest: t } =
							await Promise.resolve().then(() => jte(rl())),
						r = await e()
					return (await t({ ...r, path: Kte })).toString()
				} catch {}
		}, 'inferPhysicalRegion')
})
var CB = E((pm) => {
	'use strict'
	Object.defineProperty(pm, '__esModule', { value: !0 })
	pm.getRuntimeConfig = void 0
	var ere = (Rn(), ve(On)),
		tre = ere.__importDefault(IT()),
		rre = (zt(), ve(Gt)),
		nre = nl(),
		fm = wn(),
		ire = il(),
		yB = bn(),
		ll = Hn(),
		SB = co(),
		ore = ol(),
		sre = Rs(),
		are = mB(),
		cre = ze(),
		lre = cl(),
		dre = ze(),
		ure = (e) => {
			;(0, dre.emitWarningIfUnsupportedVersion)(process.version)
			let t = (0, lre.resolveDefaultsModeConfig)(e),
				r = () => t().then(cre.loadConfigsForDefaultMode),
				n = (0, are.getRuntimeConfig)(e)
			return (
				(0, rre.emitWarningIfUnsupportedVersion)(process.version),
				{
					...n,
					...e,
					runtime: 'node',
					defaultsMode: t,
					bodyLengthChecker: e?.bodyLengthChecker ?? ore.calculateBodyLength,
					defaultUserAgentProvider:
						e?.defaultUserAgentProvider ??
						(0, nre.defaultUserAgent)({
							serviceId: n.serviceId,
							clientVersion: tre.default.version,
						}),
					maxAttempts:
						e?.maxAttempts ??
						(0, ll.loadConfig)(yB.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
					region:
						e?.region ??
						(0, ll.loadConfig)(
							fm.NODE_REGION_CONFIG_OPTIONS,
							fm.NODE_REGION_CONFIG_FILE_OPTIONS,
						),
					requestHandler: SB.NodeHttpHandler.create(e?.requestHandler ?? r),
					retryMode:
						e?.retryMode ??
						(0, ll.loadConfig)({
							...yB.NODE_RETRY_MODE_CONFIG_OPTIONS,
							default: async () =>
								(await r()).retryMode || sre.DEFAULT_RETRY_MODE,
						}),
					sha256: e?.sha256 ?? ire.Hash.bind(null, 'sha256'),
					streamCollector: e?.streamCollector ?? SB.streamCollector,
					useDualstackEndpoint:
						e?.useDualstackEndpoint ??
						(0, ll.loadConfig)(fm.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
					useFipsEndpoint:
						e?.useFipsEndpoint ??
						(0, ll.loadConfig)(fm.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
				}
			)
		}
	pm.getRuntimeConfig = ure
})
var dl = E((MIe, AB) => {
	'use strict'
	var gm = Object.defineProperty,
		mre = Object.getOwnPropertyDescriptor,
		fre = Object.getOwnPropertyNames,
		pre = Object.prototype.hasOwnProperty,
		$s = (e, t) => gm(e, 'name', { value: t, configurable: !0 }),
		gre = (e, t) => {
			for (var r in t) gm(e, r, { get: t[r], enumerable: !0 })
		},
		vre = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of fre(t))
					!pre.call(e, i) &&
						i !== r &&
						gm(e, i, {
							get: () => t[i],
							enumerable: !(n = mre(t, i)) || n.enumerable,
						})
			return e
		},
		hre = (e) => vre(gm({}, '__esModule', { value: !0 }), e),
		bB = {}
	gre(bB, {
		NODE_REGION_CONFIG_FILE_OPTIONS: () => Cre,
		NODE_REGION_CONFIG_OPTIONS: () => Sre,
		REGION_ENV_NAME: () => wB,
		REGION_INI_NAME: () => xB,
		getAwsRegionExtensionConfiguration: () => _re,
		resolveAwsRegionExtensionConfiguration: () => yre,
		resolveRegionConfig: () => Ere,
	})
	AB.exports = hre(bB)
	var _re = $s((e) => {
			let t = $s(async () => {
				if (e.region === void 0)
					throw new Error('Region is missing from runtimeConfig')
				let r = e.region
				return typeof r == 'string' ? r : r()
			}, 'runtimeConfigRegion')
			return {
				setRegion(r) {
					t = r
				},
				region() {
					return t
				},
			}
		}, 'getAwsRegionExtensionConfiguration'),
		yre = $s(
			(e) => ({ region: e.region() }),
			'resolveAwsRegionExtensionConfiguration',
		),
		wB = 'AWS_REGION',
		xB = 'region',
		Sre = {
			environmentVariableSelector: (e) => e[wB],
			configFileSelector: (e) => e[xB],
			default: () => {
				throw new Error('Region is missing')
			},
		},
		Cre = { preferredFile: 'credentials' },
		PB = $s(
			(e) =>
				typeof e == 'string' && (e.startsWith('fips-') || e.endsWith('-fips')),
			'isFipsRegion',
		),
		EB = $s(
			(e) =>
				PB(e)
					? ['fips-aws-global', 'aws-fips'].includes(e)
						? 'us-east-1'
						: e.replace(/fips-(dkr-|prod-)?|-fips/, '')
					: e,
			'getRealRegion',
		),
		Ere = $s((e) => {
			let { region: t, useFipsEndpoint: r } = e
			if (!t) throw new Error('Region is missing')
			return {
				...e,
				region: async () => {
					if (typeof t == 'string') return EB(t)
					let n = await t()
					return EB(n)
				},
				useFipsEndpoint: async () => {
					let n = typeof t == 'string' ? t : await t()
					return PB(n)
						? !0
						: typeof r != 'function'
							? Promise.resolve(!!r)
							: r()
				},
			}
		}, 'resolveRegionConfig')
})
var hN = E(($Ie, vN) => {
	'use strict'
	var hm = Object.defineProperty,
		bre = Object.getOwnPropertyDescriptor,
		wre = Object.getOwnPropertyNames,
		xre = Object.prototype.hasOwnProperty,
		xe = (e, t) => hm(e, 'name', { value: t, configurable: !0 }),
		Pre = (e, t) => {
			for (var r in t) hm(e, r, { get: t[r], enumerable: !0 })
		},
		Are = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of wre(t))
					!xre.call(e, i) &&
						i !== r &&
						hm(e, i, {
							get: () => t[i],
							enumerable: !(n = bre(t, i)) || n.enumerable,
						})
			return e
		},
		Ore = (e) => Are(hm({}, '__esModule', { value: !0 }), e),
		NB = {}
	Pre(NB, {
		GetRoleCredentialsCommand: () => lN,
		GetRoleCredentialsRequestFilterSensitiveLog: () => YB,
		GetRoleCredentialsResponseFilterSensitiveLog: () => QB,
		InvalidRequestException: () => jB,
		ListAccountRolesCommand: () => a_,
		ListAccountRolesRequestFilterSensitiveLog: () => ZB,
		ListAccountsCommand: () => c_,
		ListAccountsRequestFilterSensitiveLog: () => eN,
		LogoutCommand: () => fN,
		LogoutRequestFilterSensitiveLog: () => tN,
		ResourceNotFoundException: () => zB,
		RoleCredentialsFilterSensitiveLog: () => JB,
		SSO: () => gN,
		SSOClient: () => ym,
		SSOServiceException: () => Vs,
		TooManyRequestsException: () => VB,
		UnauthorizedException: () => XB,
		__Client: () => ne.Client,
		paginateListAccountRoles: () => ene,
		paginateListAccounts: () => tne,
	})
	vN.exports = Ore(NB)
	var OB = bc(),
		Rre = wc(),
		kre = xc(),
		RB = Kc(),
		Ire = wn(),
		Yn = (Ut(), ve(ir)),
		Tre = Wc(),
		ml = $n(),
		kB = bn(),
		IB = e_(),
		Bre = xe(
			(e) => ({
				...e,
				useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
				useFipsEndpoint: e.useFipsEndpoint ?? !1,
				defaultSigningName: 'awsssoportal',
			}),
			'resolveClientEndpointParameters',
		),
		_m = {
			UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
			Endpoint: { type: 'builtInParams', name: 'endpoint' },
			Region: { type: 'builtInParams', name: 'region' },
			UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
		},
		Nre = CB(),
		TB = dl(),
		BB = Xe(),
		ne = ze(),
		Dre = xe((e) => {
			let t = e.httpAuthSchemes,
				r = e.httpAuthSchemeProvider,
				n = e.credentials
			return {
				setHttpAuthScheme(i) {
					let o = t.findIndex((s) => s.schemeId === i.schemeId)
					o === -1 ? t.push(i) : t.splice(o, 1, i)
				},
				httpAuthSchemes() {
					return t
				},
				setHttpAuthSchemeProvider(i) {
					r = i
				},
				httpAuthSchemeProvider() {
					return r
				},
				setCredentials(i) {
					n = i
				},
				credentials() {
					return n
				},
			}
		}, 'getHttpAuthExtensionConfiguration'),
		Lre = xe(
			(e) => ({
				httpAuthSchemes: e.httpAuthSchemes(),
				httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
				credentials: e.credentials(),
			}),
			'resolveHttpAuthRuntimeConfig',
		),
		vm = xe((e) => e, 'asPartial'),
		Fre = xe((e, t) => {
			let r = {
				...vm((0, TB.getAwsRegionExtensionConfiguration)(e)),
				...vm((0, ne.getDefaultExtensionConfiguration)(e)),
				...vm((0, BB.getHttpHandlerExtensionConfiguration)(e)),
				...vm(Dre(e)),
			}
			return (
				t.forEach((n) => n.configure(r)),
				{
					...e,
					...(0, TB.resolveAwsRegionExtensionConfiguration)(r),
					...(0, ne.resolveDefaultRuntimeConfig)(r),
					...(0, BB.resolveHttpHandlerRuntimeConfig)(r),
					...Lre(r),
				}
			)
		}, 'resolveRuntimeExtensions'),
		DB = class extends ne.Client {
			constructor(...[t]) {
				let r = (0, Nre.getRuntimeConfig)(t || {}),
					n = Bre(r),
					i = (0, RB.resolveUserAgentConfig)(n),
					o = (0, kB.resolveRetryConfig)(i),
					s = (0, Ire.resolveRegionConfig)(o),
					c = (0, OB.resolveHostHeaderConfig)(s),
					l = (0, ml.resolveEndpointConfig)(c),
					u = (0, IB.resolveHttpAuthSchemeConfig)(l),
					m = Fre(u, t?.extensions || [])
				super(m),
					(this.config = m),
					this.middlewareStack.use((0, RB.getUserAgentPlugin)(this.config)),
					this.middlewareStack.use((0, kB.getRetryPlugin)(this.config)),
					this.middlewareStack.use(
						(0, Tre.getContentLengthPlugin)(this.config),
					),
					this.middlewareStack.use((0, OB.getHostHeaderPlugin)(this.config)),
					this.middlewareStack.use((0, Rre.getLoggerPlugin)(this.config)),
					this.middlewareStack.use(
						(0, kre.getRecursionDetectionPlugin)(this.config),
					),
					this.middlewareStack.use(
						(0, Yn.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
							httpAuthSchemeParametersProvider:
								IB.defaultSSOHttpAuthSchemeParametersProvider,
							identityProviderConfigProvider: async (f) =>
								new Yn.DefaultIdentityProviderConfig({
									'aws.auth#sigv4': f.credentials,
								}),
						}),
					),
					this.middlewareStack.use((0, Yn.getHttpSigningPlugin)(this.config))
			}
			destroy() {
				super.destroy()
			}
		}
	xe(DB, 'SSOClient')
	var ym = DB,
		Sm = go(),
		LB = class FB extends ne.ServiceException {
			constructor(t) {
				super(t), Object.setPrototypeOf(this, FB.prototype)
			}
		}
	xe(LB, 'SSOServiceException')
	var Vs = LB,
		MB = class qB extends Vs {
			constructor(t) {
				super({ name: 'InvalidRequestException', $fault: 'client', ...t }),
					(this.name = 'InvalidRequestException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, qB.prototype)
			}
		}
	xe(MB, 'InvalidRequestException')
	var jB = MB,
		UB = class GB extends Vs {
			constructor(t) {
				super({ name: 'ResourceNotFoundException', $fault: 'client', ...t }),
					(this.name = 'ResourceNotFoundException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, GB.prototype)
			}
		}
	xe(UB, 'ResourceNotFoundException')
	var zB = UB,
		HB = class $B extends Vs {
			constructor(t) {
				super({ name: 'TooManyRequestsException', $fault: 'client', ...t }),
					(this.name = 'TooManyRequestsException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, $B.prototype)
			}
		}
	xe(HB, 'TooManyRequestsException')
	var VB = HB,
		KB = class WB extends Vs {
			constructor(t) {
				super({ name: 'UnauthorizedException', $fault: 'client', ...t }),
					(this.name = 'UnauthorizedException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, WB.prototype)
			}
		}
	xe(KB, 'UnauthorizedException')
	var XB = KB,
		YB = xe(
			(e) => ({
				...e,
				...(e.accessToken && { accessToken: ne.SENSITIVE_STRING }),
			}),
			'GetRoleCredentialsRequestFilterSensitiveLog',
		),
		JB = xe(
			(e) => ({
				...e,
				...(e.secretAccessKey && { secretAccessKey: ne.SENSITIVE_STRING }),
				...(e.sessionToken && { sessionToken: ne.SENSITIVE_STRING }),
			}),
			'RoleCredentialsFilterSensitiveLog',
		),
		QB = xe(
			(e) => ({
				...e,
				...(e.roleCredentials && { roleCredentials: JB(e.roleCredentials) }),
			}),
			'GetRoleCredentialsResponseFilterSensitiveLog',
		),
		ZB = xe(
			(e) => ({
				...e,
				...(e.accessToken && { accessToken: ne.SENSITIVE_STRING }),
			}),
			'ListAccountRolesRequestFilterSensitiveLog',
		),
		eN = xe(
			(e) => ({
				...e,
				...(e.accessToken && { accessToken: ne.SENSITIVE_STRING }),
			}),
			'ListAccountsRequestFilterSensitiveLog',
		),
		tN = xe(
			(e) => ({
				...e,
				...(e.accessToken && { accessToken: ne.SENSITIVE_STRING }),
			}),
			'LogoutRequestFilterSensitiveLog',
		),
		ul = (zt(), ve(Gt)),
		Mre = xe(async (e, t) => {
			let r = (0, Yn.requestBuilder)(e, t),
				n = (0, ne.map)({}, Em, { [wm]: e[bm] })
			r.bp('/federation/credentials')
			let i = (0, ne.map)({
				[Qre]: [, (0, ne.expectNonNull)(e[Jre], 'roleName')],
				[nN]: [, (0, ne.expectNonNull)(e[rN], 'accountId')],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetRoleCredentialsCommand'),
		qre = xe(async (e, t) => {
			let r = (0, Yn.requestBuilder)(e, t),
				n = (0, ne.map)({}, Em, { [wm]: e[bm] })
			r.bp('/assignment/roles')
			let i = (0, ne.map)({
				[aN]: [, e[sN]],
				[oN]: [() => e.maxResults !== void 0, () => e[iN].toString()],
				[nN]: [, (0, ne.expectNonNull)(e[rN], 'accountId')],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListAccountRolesCommand'),
		jre = xe(async (e, t) => {
			let r = (0, Yn.requestBuilder)(e, t),
				n = (0, ne.map)({}, Em, { [wm]: e[bm] })
			r.bp('/assignment/accounts')
			let i = (0, ne.map)({
				[aN]: [, e[sN]],
				[oN]: [() => e.maxResults !== void 0, () => e[iN].toString()],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListAccountsCommand'),
		Ure = xe(async (e, t) => {
			let r = (0, Yn.requestBuilder)(e, t),
				n = (0, ne.map)({}, Em, { [wm]: e[bm] })
			return (
				r.bp('/logout'),
				r
					.m('POST')
					.h(n)
					.b(void 0),
				r.build()
			)
		}, 'se_LogoutCommand'),
		Gre = xe(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return Cm(e, t)
			let r = (0, ne.map)({ $metadata: Ai(e) }),
				n = (0, ne.expectNonNull)(
					(0, ne.expectObject)(await (0, ul.parseJsonBody)(e.body, t)),
					'body',
				),
				i = (0, ne.take)(n, { roleCredentials: ne._json })
			return Object.assign(r, i), r
		}, 'de_GetRoleCredentialsCommand'),
		zre = xe(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return Cm(e, t)
			let r = (0, ne.map)({ $metadata: Ai(e) }),
				n = (0, ne.expectNonNull)(
					(0, ne.expectObject)(await (0, ul.parseJsonBody)(e.body, t)),
					'body',
				),
				i = (0, ne.take)(n, { nextToken: ne.expectString, roleList: ne._json })
			return Object.assign(r, i), r
		}, 'de_ListAccountRolesCommand'),
		Hre = xe(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return Cm(e, t)
			let r = (0, ne.map)({ $metadata: Ai(e) }),
				n = (0, ne.expectNonNull)(
					(0, ne.expectObject)(await (0, ul.parseJsonBody)(e.body, t)),
					'body',
				),
				i = (0, ne.take)(n, {
					accountList: ne._json,
					nextToken: ne.expectString,
				})
			return Object.assign(r, i), r
		}, 'de_ListAccountsCommand'),
		$re = xe(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return Cm(e, t)
			let r = (0, ne.map)({ $metadata: Ai(e) })
			return await (0, ne.collectBody)(e.body, t), r
		}, 'de_LogoutCommand'),
		Cm = xe(async (e, t) => {
			let r = { ...e, body: await (0, ul.parseJsonErrorBody)(e.body, t) },
				n = (0, ul.loadRestJsonErrorCode)(e, r.body)
			switch (n) {
				case 'InvalidRequestException':
				case 'com.amazonaws.sso#InvalidRequestException':
					throw await Kre(r, t)
				case 'ResourceNotFoundException':
				case 'com.amazonaws.sso#ResourceNotFoundException':
					throw await Wre(r, t)
				case 'TooManyRequestsException':
				case 'com.amazonaws.sso#TooManyRequestsException':
					throw await Xre(r, t)
				case 'UnauthorizedException':
				case 'com.amazonaws.sso#UnauthorizedException':
					throw await Yre(r, t)
				default:
					let i = r.body
					return Vre({ output: e, parsedBody: i, errorCode: n })
			}
		}, 'de_CommandError'),
		Vre = (0, ne.withBaseException)(Vs),
		Kre = xe(async (e, t) => {
			let r = (0, ne.map)({}),
				n = e.body,
				i = (0, ne.take)(n, { message: ne.expectString })
			Object.assign(r, i)
			let o = new jB({ $metadata: Ai(e), ...r })
			return (0, ne.decorateServiceException)(o, e.body)
		}, 'de_InvalidRequestExceptionRes'),
		Wre = xe(async (e, t) => {
			let r = (0, ne.map)({}),
				n = e.body,
				i = (0, ne.take)(n, { message: ne.expectString })
			Object.assign(r, i)
			let o = new zB({ $metadata: Ai(e), ...r })
			return (0, ne.decorateServiceException)(o, e.body)
		}, 'de_ResourceNotFoundExceptionRes'),
		Xre = xe(async (e, t) => {
			let r = (0, ne.map)({}),
				n = e.body,
				i = (0, ne.take)(n, { message: ne.expectString })
			Object.assign(r, i)
			let o = new VB({ $metadata: Ai(e), ...r })
			return (0, ne.decorateServiceException)(o, e.body)
		}, 'de_TooManyRequestsExceptionRes'),
		Yre = xe(async (e, t) => {
			let r = (0, ne.map)({}),
				n = e.body,
				i = (0, ne.take)(n, { message: ne.expectString })
			Object.assign(r, i)
			let o = new XB({ $metadata: Ai(e), ...r })
			return (0, ne.decorateServiceException)(o, e.body)
		}, 'de_UnauthorizedExceptionRes'),
		Ai = xe(
			(e) => ({
				httpStatusCode: e.statusCode,
				requestId:
					e.headers['x-amzn-requestid'] ??
					e.headers['x-amzn-request-id'] ??
					e.headers['x-amz-request-id'],
				extendedRequestId: e.headers['x-amz-id-2'],
				cfId: e.headers['x-amz-cf-id'],
			}),
			'deserializeMetadata',
		),
		Em = xe(
			(e) =>
				e != null &&
				e !== '' &&
				(!Object.getOwnPropertyNames(e).includes('length') || e.length != 0) &&
				(!Object.getOwnPropertyNames(e).includes('size') || e.size != 0),
			'isSerializableHeaderValue',
		),
		rN = 'accountId',
		bm = 'accessToken',
		nN = 'account_id',
		iN = 'maxResults',
		oN = 'max_result',
		sN = 'nextToken',
		aN = 'next_token',
		Jre = 'roleName',
		Qre = 'role_name',
		wm = 'x-amz-sso_bearer_token',
		cN = class extends ne.Command.classBuilder()
			.ep({ ..._m })
			.m(function (t, r, n, i) {
				return [
					(0, Sm.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, ml.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('SWBPortalService', 'GetRoleCredentials', {})
			.n('SSOClient', 'GetRoleCredentialsCommand')
			.f(YB, QB)
			.ser(Mre)
			.de(Gre)
			.build() {}
	xe(cN, 'GetRoleCredentialsCommand')
	var lN = cN,
		dN = class extends ne.Command.classBuilder()
			.ep({ ..._m })
			.m(function (t, r, n, i) {
				return [
					(0, Sm.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, ml.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('SWBPortalService', 'ListAccountRoles', {})
			.n('SSOClient', 'ListAccountRolesCommand')
			.f(ZB, void 0)
			.ser(qre)
			.de(zre)
			.build() {}
	xe(dN, 'ListAccountRolesCommand')
	var a_ = dN,
		uN = class extends ne.Command.classBuilder()
			.ep({ ..._m })
			.m(function (t, r, n, i) {
				return [
					(0, Sm.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, ml.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('SWBPortalService', 'ListAccounts', {})
			.n('SSOClient', 'ListAccountsCommand')
			.f(eN, void 0)
			.ser(jre)
			.de(Hre)
			.build() {}
	xe(uN, 'ListAccountsCommand')
	var c_ = uN,
		mN = class extends ne.Command.classBuilder()
			.ep({ ..._m })
			.m(function (t, r, n, i) {
				return [
					(0, Sm.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, ml.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('SWBPortalService', 'Logout', {})
			.n('SSOClient', 'LogoutCommand')
			.f(tN, void 0)
			.ser(Ure)
			.de($re)
			.build() {}
	xe(mN, 'LogoutCommand')
	var fN = mN,
		Zre = {
			GetRoleCredentialsCommand: lN,
			ListAccountRolesCommand: a_,
			ListAccountsCommand: c_,
			LogoutCommand: fN,
		},
		pN = class extends ym {}
	xe(pN, 'SSO')
	var gN = pN
	;(0, ne.createAggregatedClient)(Zre, gN)
	var ene = (0, Yn.createPaginator)(
			ym,
			a_,
			'nextToken',
			'nextToken',
			'maxResults',
		),
		tne = (0, Yn.createPaginator)(
			ym,
			c_,
			'nextToken',
			'nextToken',
			'maxResults',
		)
})
var d_ = E((Oi) => {
	'use strict'
	Object.defineProperty(Oi, '__esModule', { value: !0 })
	Oi.resolveHttpAuthSchemeConfig =
		Oi.defaultSSOOIDCHttpAuthSchemeProvider =
		Oi.defaultSSOOIDCHttpAuthSchemeParametersProvider =
			void 0
	var rne = (zt(), ve(Gt)),
		_N = Tr(),
		nne = async (e, t, r) => ({
			operation: (0, _N.getSmithyContext)(t).operation,
			region:
				(await (0, _N.normalizeProvider)(e.region)()) ||
				(() => {
					throw new Error(
						'expected `region` to be configured for `aws.auth#sigv4`',
					)
				})(),
		})
	Oi.defaultSSOOIDCHttpAuthSchemeParametersProvider = nne
	function ine(e) {
		return {
			schemeId: 'aws.auth#sigv4',
			signingProperties: { name: 'sso-oauth', region: e.region },
			propertiesExtractor: (t, r) => ({
				signingProperties: { config: t, context: r },
			}),
		}
	}
	function l_(e) {
		return { schemeId: 'smithy.api#noAuth' }
	}
	var one = (e) => {
		let t = []
		switch (e.operation) {
			case 'CreateToken': {
				t.push(l_(e))
				break
			}
			case 'RegisterClient': {
				t.push(l_(e))
				break
			}
			case 'StartDeviceAuthorization': {
				t.push(l_(e))
				break
			}
			default:
				t.push(ine(e))
		}
		return t
	}
	Oi.defaultSSOOIDCHttpAuthSchemeProvider = one
	var sne = (e) => ({ ...(0, rne.resolveAwsSdkSigV4Config)(e) })
	Oi.resolveHttpAuthSchemeConfig = sne
})
var yN = E((KIe, ane) => {
	ane.exports = {
		name: '@aws-sdk/client-sso-oidc',
		description:
			'AWS SDK for JavaScript Sso Oidc Client for Node.js, Browser and React Native',
		version: '3.645.0',
		scripts: {
			build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
			'build:cjs': 'node ../../scripts/compilation/inline client-sso-oidc',
			'build:es': 'tsc -p tsconfig.es.json',
			'build:include:deps':
				'lerna run --scope $npm_package_name --include-dependencies build',
			'build:types': 'tsc -p tsconfig.types.json',
			'build:types:downlevel': 'downlevel-dts dist-types dist-types/ts3.4',
			clean: 'rimraf ./dist-* && rimraf *.tsbuildinfo',
			'extract:docs': 'api-extractor run --local',
			'generate:client':
				'node ../../scripts/generate-clients/single-service --solo sso-oidc',
		},
		main: './dist-cjs/index.js',
		types: './dist-types/index.d.ts',
		module: './dist-es/index.js',
		sideEffects: !1,
		dependencies: {
			'@aws-crypto/sha256-browser': '5.2.0',
			'@aws-crypto/sha256-js': '5.2.0',
			'@aws-sdk/core': '3.635.0',
			'@aws-sdk/credential-provider-node': '3.645.0',
			'@aws-sdk/middleware-host-header': '3.620.0',
			'@aws-sdk/middleware-logger': '3.609.0',
			'@aws-sdk/middleware-recursion-detection': '3.620.0',
			'@aws-sdk/middleware-user-agent': '3.645.0',
			'@aws-sdk/region-config-resolver': '3.614.0',
			'@aws-sdk/types': '3.609.0',
			'@aws-sdk/util-endpoints': '3.645.0',
			'@aws-sdk/util-user-agent-browser': '3.609.0',
			'@aws-sdk/util-user-agent-node': '3.614.0',
			'@smithy/config-resolver': '^3.0.5',
			'@smithy/core': '^2.4.0',
			'@smithy/fetch-http-handler': '^3.2.4',
			'@smithy/hash-node': '^3.0.3',
			'@smithy/invalid-dependency': '^3.0.3',
			'@smithy/middleware-content-length': '^3.0.5',
			'@smithy/middleware-endpoint': '^3.1.0',
			'@smithy/middleware-retry': '^3.0.15',
			'@smithy/middleware-serde': '^3.0.3',
			'@smithy/middleware-stack': '^3.0.3',
			'@smithy/node-config-provider': '^3.1.4',
			'@smithy/node-http-handler': '^3.1.4',
			'@smithy/protocol-http': '^4.1.0',
			'@smithy/smithy-client': '^3.2.0',
			'@smithy/types': '^3.3.0',
			'@smithy/url-parser': '^3.0.3',
			'@smithy/util-base64': '^3.0.0',
			'@smithy/util-body-length-browser': '^3.0.0',
			'@smithy/util-body-length-node': '^3.0.0',
			'@smithy/util-defaults-mode-browser': '^3.0.15',
			'@smithy/util-defaults-mode-node': '^3.0.15',
			'@smithy/util-endpoints': '^2.0.5',
			'@smithy/util-middleware': '^3.0.3',
			'@smithy/util-retry': '^3.0.3',
			'@smithy/util-utf8': '^3.0.0',
			tslib: '^2.6.2',
		},
		devDependencies: {
			'@tsconfig/node16': '16.1.3',
			'@types/node': '^16.18.96',
			concurrently: '7.0.0',
			'downlevel-dts': '0.10.1',
			rimraf: '3.0.2',
			typescript: '~4.9.5',
		},
		engines: { node: '>=16.0.0' },
		typesVersions: { '<4.0': { 'dist-types/*': ['dist-types/ts3.4/*'] } },
		files: ['dist-*/**'],
		author: {
			name: 'AWS SDK for JavaScript Team',
			url: 'https://aws.amazon.com/javascript/',
		},
		license: 'Apache-2.0',
		peerDependencies: { '@aws-sdk/client-sts': '^3.645.0' },
		browser: { './dist-es/runtimeConfig': './dist-es/runtimeConfig.browser' },
		'react-native': {
			'./dist-es/runtimeConfig': './dist-es/runtimeConfig.native',
		},
		homepage:
			'https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso-oidc',
		repository: {
			type: 'git',
			url: 'https://github.com/aws/aws-sdk-js-v3.git',
			directory: 'clients/client-sso-oidc',
		},
	}
})
var NN = E((xm) => {
	'use strict'
	Object.defineProperty(xm, '__esModule', { value: !0 })
	xm.ruleSet = void 0
	var kN = 'required',
		qr = 'fn',
		jr = 'argv',
		Xs = 'ref',
		SN = !0,
		CN = 'isSet',
		fl = 'booleanEquals',
		Ks = 'error',
		Ws = 'endpoint',
		Jn = 'tree',
		u_ = 'PartitionResult',
		m_ = 'getAttr',
		EN = { [kN]: !1, type: 'String' },
		bN = { [kN]: !0, default: !1, type: 'Boolean' },
		wN = { [Xs]: 'Endpoint' },
		IN = { [qr]: fl, [jr]: [{ [Xs]: 'UseFIPS' }, !0] },
		TN = { [qr]: fl, [jr]: [{ [Xs]: 'UseDualStack' }, !0] },
		Mr = {},
		xN = { [qr]: m_, [jr]: [{ [Xs]: u_ }, 'supportsFIPS'] },
		BN = { [Xs]: u_ },
		PN = {
			[qr]: fl,
			[jr]: [!0, { [qr]: m_, [jr]: [BN, 'supportsDualStack'] }],
		},
		AN = [IN],
		ON = [TN],
		RN = [{ [Xs]: 'Region' }],
		cne = {
			version: '1.0',
			parameters: { Region: EN, UseDualStack: bN, UseFIPS: bN, Endpoint: EN },
			rules: [
				{
					conditions: [{ [qr]: CN, [jr]: [wN] }],
					rules: [
						{
							conditions: AN,
							error:
								'Invalid Configuration: FIPS and custom endpoint are not supported',
							type: Ks,
						},
						{
							conditions: ON,
							error:
								'Invalid Configuration: Dualstack and custom endpoint are not supported',
							type: Ks,
						},
						{ endpoint: { url: wN, properties: Mr, headers: Mr }, type: Ws },
					],
					type: Jn,
				},
				{
					conditions: [{ [qr]: CN, [jr]: RN }],
					rules: [
						{
							conditions: [{ [qr]: 'aws.partition', [jr]: RN, assign: u_ }],
							rules: [
								{
									conditions: [IN, TN],
									rules: [
										{
											conditions: [{ [qr]: fl, [jr]: [SN, xN] }, PN],
											rules: [
												{
													endpoint: {
														url: 'https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}',
														properties: Mr,
														headers: Mr,
													},
													type: Ws,
												},
											],
											type: Jn,
										},
										{
											error:
												'FIPS and DualStack are enabled, but this partition does not support one or both',
											type: Ks,
										},
									],
									type: Jn,
								},
								{
									conditions: AN,
									rules: [
										{
											conditions: [{ [qr]: fl, [jr]: [xN, SN] }],
											rules: [
												{
													conditions: [
														{
															[qr]: 'stringEquals',
															[jr]: [
																{ [qr]: m_, [jr]: [BN, 'name'] },
																'aws-us-gov',
															],
														},
													],
													endpoint: {
														url: 'https://oidc.{Region}.amazonaws.com',
														properties: Mr,
														headers: Mr,
													},
													type: Ws,
												},
												{
													endpoint: {
														url: 'https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}',
														properties: Mr,
														headers: Mr,
													},
													type: Ws,
												},
											],
											type: Jn,
										},
										{
											error:
												'FIPS is enabled but this partition does not support FIPS',
											type: Ks,
										},
									],
									type: Jn,
								},
								{
									conditions: ON,
									rules: [
										{
											conditions: [PN],
											rules: [
												{
													endpoint: {
														url: 'https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}',
														properties: Mr,
														headers: Mr,
													},
													type: Ws,
												},
											],
											type: Jn,
										},
										{
											error:
												'DualStack is enabled but this partition does not support DualStack',
											type: Ks,
										},
									],
									type: Jn,
								},
								{
									endpoint: {
										url: 'https://oidc.{Region}.{PartitionResult#dnsSuffix}',
										properties: Mr,
										headers: Mr,
									},
									type: Ws,
								},
							],
							type: Jn,
						},
					],
					type: Jn,
				},
				{ error: 'Invalid Configuration: Missing Region', type: Ks },
			],
		}
	xm.ruleSet = cne
})
var LN = E((Pm) => {
	'use strict'
	Object.defineProperty(Pm, '__esModule', { value: !0 })
	Pm.defaultEndpointResolver = void 0
	var lne = Bs(),
		DN = Is(),
		dne = NN(),
		une = (e, t = {}) =>
			(0, DN.resolveEndpoint)(dne.ruleSet, {
				endpointParams: e,
				logger: t.logger,
			})
	Pm.defaultEndpointResolver = une
	DN.customEndpointFunctions.aws = lne.awsEndpointFunctions
})
var qN = E((Am) => {
	'use strict'
	Object.defineProperty(Am, '__esModule', { value: !0 })
	Am.getRuntimeConfig = void 0
	var mne = (zt(), ve(Gt)),
		fne = (Ut(), ve(ir)),
		pne = ze(),
		gne = po(),
		FN = gi(),
		MN = rr(),
		vne = d_(),
		hne = LN(),
		_ne = (e) => ({
			apiVersion: '2019-06-10',
			base64Decoder: e?.base64Decoder ?? FN.fromBase64,
			base64Encoder: e?.base64Encoder ?? FN.toBase64,
			disableHostPrefix: e?.disableHostPrefix ?? !1,
			endpointProvider: e?.endpointProvider ?? hne.defaultEndpointResolver,
			extensions: e?.extensions ?? [],
			httpAuthSchemeProvider:
				e?.httpAuthSchemeProvider ?? vne.defaultSSOOIDCHttpAuthSchemeProvider,
			httpAuthSchemes: e?.httpAuthSchemes ?? [
				{
					schemeId: 'aws.auth#sigv4',
					identityProvider: (t) => t.getIdentityProvider('aws.auth#sigv4'),
					signer: new mne.AwsSdkSigV4Signer(),
				},
				{
					schemeId: 'smithy.api#noAuth',
					identityProvider: (t) =>
						t.getIdentityProvider('smithy.api#noAuth') || (async () => ({})),
					signer: new fne.NoAuthSigner(),
				},
			],
			logger: e?.logger ?? new pne.NoOpLogger(),
			serviceId: e?.serviceId ?? 'SSO OIDC',
			urlParser: e?.urlParser ?? gne.parseUrl,
			utf8Decoder: e?.utf8Decoder ?? MN.fromUtf8,
			utf8Encoder: e?.utf8Encoder ?? MN.toUtf8,
		})
	Am.getRuntimeConfig = _ne
})
var GN = E((Rm) => {
	'use strict'
	Object.defineProperty(Rm, '__esModule', { value: !0 })
	Rm.getRuntimeConfig = void 0
	var yne = (Rn(), ve(On)),
		Sne = yne.__importDefault(yN()),
		Cne = (zt(), ve(Gt)),
		Ene = km(),
		bne = nl(),
		Om = wn(),
		wne = il(),
		jN = bn(),
		pl = Hn(),
		UN = co(),
		xne = ol(),
		Pne = Rs(),
		Ane = qN(),
		One = ze(),
		Rne = cl(),
		kne = ze(),
		Ine = (e) => {
			;(0, kne.emitWarningIfUnsupportedVersion)(process.version)
			let t = (0, Rne.resolveDefaultsModeConfig)(e),
				r = () => t().then(One.loadConfigsForDefaultMode),
				n = (0, Ane.getRuntimeConfig)(e)
			return (
				(0, Cne.emitWarningIfUnsupportedVersion)(process.version),
				{
					...n,
					...e,
					runtime: 'node',
					defaultsMode: t,
					bodyLengthChecker: e?.bodyLengthChecker ?? xne.calculateBodyLength,
					credentialDefaultProvider:
						e?.credentialDefaultProvider ?? Ene.defaultProvider,
					defaultUserAgentProvider:
						e?.defaultUserAgentProvider ??
						(0, bne.defaultUserAgent)({
							serviceId: n.serviceId,
							clientVersion: Sne.default.version,
						}),
					maxAttempts:
						e?.maxAttempts ??
						(0, pl.loadConfig)(jN.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
					region:
						e?.region ??
						(0, pl.loadConfig)(
							Om.NODE_REGION_CONFIG_OPTIONS,
							Om.NODE_REGION_CONFIG_FILE_OPTIONS,
						),
					requestHandler: UN.NodeHttpHandler.create(e?.requestHandler ?? r),
					retryMode:
						e?.retryMode ??
						(0, pl.loadConfig)({
							...jN.NODE_RETRY_MODE_CONFIG_OPTIONS,
							default: async () =>
								(await r()).retryMode || Pne.DEFAULT_RETRY_MODE,
						}),
					sha256: e?.sha256 ?? wne.Hash.bind(null, 'sha256'),
					streamCollector: e?.streamCollector ?? UN.streamCollector,
					useDualstackEndpoint:
						e?.useDualstackEndpoint ??
						(0, pl.loadConfig)(Om.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
					useFipsEndpoint:
						e?.useFipsEndpoint ??
						(0, pl.loadConfig)(Om.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
				}
			)
		}
	Rm.getRuntimeConfig = Ine
})
var f_ = E((iTe, iL) => {
	'use strict'
	var Tm = Object.defineProperty,
		Tne = Object.getOwnPropertyDescriptor,
		Bne = Object.getOwnPropertyNames,
		Nne = Object.prototype.hasOwnProperty,
		se = (e, t) => Tm(e, 'name', { value: t, configurable: !0 }),
		Dne = (e, t) => {
			for (var r in t) Tm(e, r, { get: t[r], enumerable: !0 })
		},
		Lne = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Bne(t))
					!Nne.call(e, i) &&
						i !== r &&
						Tm(e, i, {
							get: () => t[i],
							enumerable: !(n = Tne(t, i)) || n.enumerable,
						})
			return e
		},
		Fne = (e) => Lne(Tm({}, '__esModule', { value: !0 }), e),
		XN = {}
	Dne(XN, {
		AccessDeniedException: () => rD,
		AuthorizationPendingException: () => oD,
		CreateTokenCommand: () => XD,
		CreateTokenRequestFilterSensitiveLog: () => GD,
		CreateTokenResponseFilterSensitiveLog: () => zD,
		CreateTokenWithIAMCommand: () => JD,
		CreateTokenWithIAMRequestFilterSensitiveLog: () => HD,
		CreateTokenWithIAMResponseFilterSensitiveLog: () => $D,
		ExpiredTokenException: () => cD,
		InternalServerException: () => uD,
		InvalidClientException: () => pD,
		InvalidClientMetadataException: () => MD,
		InvalidGrantException: () => hD,
		InvalidRedirectUriException: () => UD,
		InvalidRequestException: () => SD,
		InvalidRequestRegionException: () => DD,
		InvalidScopeException: () => bD,
		RegisterClientCommand: () => ZD,
		RegisterClientResponseFilterSensitiveLog: () => VD,
		SSOOIDC: () => nL,
		SSOOIDCClient: () => JN,
		SSOOIDCServiceException: () => Xt,
		SlowDownException: () => PD,
		StartDeviceAuthorizationCommand: () => tL,
		StartDeviceAuthorizationRequestFilterSensitiveLog: () => KD,
		UnauthorizedClientException: () => RD,
		UnsupportedGrantTypeException: () => TD,
		__Client: () => O.Client,
	})
	iL.exports = Fne(XN)
	var zN = bc(),
		Mne = wc(),
		qne = xc(),
		HN = Kc(),
		jne = wn(),
		Co = (Ut(), ve(ir)),
		Une = Wc(),
		gl = $n(),
		$N = bn(),
		VN = d_(),
		Gne = se(
			(e) => ({
				...e,
				useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
				useFipsEndpoint: e.useFipsEndpoint ?? !1,
				defaultSigningName: 'sso-oauth',
			}),
			'resolveClientEndpointParameters',
		),
		Bm = {
			UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
			Endpoint: { type: 'builtInParams', name: 'endpoint' },
			Region: { type: 'builtInParams', name: 'region' },
			UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
		},
		zne = GN(),
		KN = dl(),
		WN = Xe(),
		O = ze(),
		Hne = se((e) => {
			let t = e.httpAuthSchemes,
				r = e.httpAuthSchemeProvider,
				n = e.credentials
			return {
				setHttpAuthScheme(i) {
					let o = t.findIndex((s) => s.schemeId === i.schemeId)
					o === -1 ? t.push(i) : t.splice(o, 1, i)
				},
				httpAuthSchemes() {
					return t
				},
				setHttpAuthSchemeProvider(i) {
					r = i
				},
				httpAuthSchemeProvider() {
					return r
				},
				setCredentials(i) {
					n = i
				},
				credentials() {
					return n
				},
			}
		}, 'getHttpAuthExtensionConfiguration'),
		$ne = se(
			(e) => ({
				httpAuthSchemes: e.httpAuthSchemes(),
				httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
				credentials: e.credentials(),
			}),
			'resolveHttpAuthRuntimeConfig',
		),
		Im = se((e) => e, 'asPartial'),
		Vne = se((e, t) => {
			let r = {
				...Im((0, KN.getAwsRegionExtensionConfiguration)(e)),
				...Im((0, O.getDefaultExtensionConfiguration)(e)),
				...Im((0, WN.getHttpHandlerExtensionConfiguration)(e)),
				...Im(Hne(e)),
			}
			return (
				t.forEach((n) => n.configure(r)),
				{
					...e,
					...(0, KN.resolveAwsRegionExtensionConfiguration)(r),
					...(0, O.resolveDefaultRuntimeConfig)(r),
					...(0, WN.resolveHttpHandlerRuntimeConfig)(r),
					...$ne(r),
				}
			)
		}, 'resolveRuntimeExtensions'),
		YN = class extends O.Client {
			constructor(...[t]) {
				let r = (0, zne.getRuntimeConfig)(t || {}),
					n = Gne(r),
					i = (0, HN.resolveUserAgentConfig)(n),
					o = (0, $N.resolveRetryConfig)(i),
					s = (0, jne.resolveRegionConfig)(o),
					c = (0, zN.resolveHostHeaderConfig)(s),
					l = (0, gl.resolveEndpointConfig)(c),
					u = (0, VN.resolveHttpAuthSchemeConfig)(l),
					m = Vne(u, t?.extensions || [])
				super(m),
					(this.config = m),
					this.middlewareStack.use((0, HN.getUserAgentPlugin)(this.config)),
					this.middlewareStack.use((0, $N.getRetryPlugin)(this.config)),
					this.middlewareStack.use(
						(0, Une.getContentLengthPlugin)(this.config),
					),
					this.middlewareStack.use((0, zN.getHostHeaderPlugin)(this.config)),
					this.middlewareStack.use((0, Mne.getLoggerPlugin)(this.config)),
					this.middlewareStack.use(
						(0, qne.getRecursionDetectionPlugin)(this.config),
					),
					this.middlewareStack.use(
						(0, Co.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
							httpAuthSchemeParametersProvider:
								VN.defaultSSOOIDCHttpAuthSchemeParametersProvider,
							identityProviderConfigProvider: async (f) =>
								new Co.DefaultIdentityProviderConfig({
									'aws.auth#sigv4': f.credentials,
								}),
						}),
					),
					this.middlewareStack.use((0, Co.getHttpSigningPlugin)(this.config))
			}
			destroy() {
				super.destroy()
			}
		}
	se(YN, 'SSOOIDCClient')
	var JN = YN,
		Nm = go(),
		QN = class ZN extends O.ServiceException {
			constructor(t) {
				super(t), Object.setPrototypeOf(this, ZN.prototype)
			}
		}
	se(QN, 'SSOOIDCServiceException')
	var Xt = QN,
		eD = class tD extends Xt {
			constructor(t) {
				super({ name: 'AccessDeniedException', $fault: 'client', ...t }),
					(this.name = 'AccessDeniedException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, tD.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(eD, 'AccessDeniedException')
	var rD = eD,
		nD = class iD extends Xt {
			constructor(t) {
				super({
					name: 'AuthorizationPendingException',
					$fault: 'client',
					...t,
				}),
					(this.name = 'AuthorizationPendingException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, iD.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(nD, 'AuthorizationPendingException')
	var oD = nD,
		sD = class aD extends Xt {
			constructor(t) {
				super({ name: 'ExpiredTokenException', $fault: 'client', ...t }),
					(this.name = 'ExpiredTokenException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, aD.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(sD, 'ExpiredTokenException')
	var cD = sD,
		lD = class dD extends Xt {
			constructor(t) {
				super({ name: 'InternalServerException', $fault: 'server', ...t }),
					(this.name = 'InternalServerException'),
					(this.$fault = 'server'),
					Object.setPrototypeOf(this, dD.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(lD, 'InternalServerException')
	var uD = lD,
		mD = class fD extends Xt {
			constructor(t) {
				super({ name: 'InvalidClientException', $fault: 'client', ...t }),
					(this.name = 'InvalidClientException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, fD.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(mD, 'InvalidClientException')
	var pD = mD,
		gD = class vD extends Xt {
			constructor(t) {
				super({ name: 'InvalidGrantException', $fault: 'client', ...t }),
					(this.name = 'InvalidGrantException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, vD.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(gD, 'InvalidGrantException')
	var hD = gD,
		_D = class yD extends Xt {
			constructor(t) {
				super({ name: 'InvalidRequestException', $fault: 'client', ...t }),
					(this.name = 'InvalidRequestException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, yD.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(_D, 'InvalidRequestException')
	var SD = _D,
		CD = class ED extends Xt {
			constructor(t) {
				super({ name: 'InvalidScopeException', $fault: 'client', ...t }),
					(this.name = 'InvalidScopeException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, ED.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(CD, 'InvalidScopeException')
	var bD = CD,
		wD = class xD extends Xt {
			constructor(t) {
				super({ name: 'SlowDownException', $fault: 'client', ...t }),
					(this.name = 'SlowDownException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, xD.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(wD, 'SlowDownException')
	var PD = wD,
		AD = class OD extends Xt {
			constructor(t) {
				super({ name: 'UnauthorizedClientException', $fault: 'client', ...t }),
					(this.name = 'UnauthorizedClientException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, OD.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(AD, 'UnauthorizedClientException')
	var RD = AD,
		kD = class ID extends Xt {
			constructor(t) {
				super({
					name: 'UnsupportedGrantTypeException',
					$fault: 'client',
					...t,
				}),
					(this.name = 'UnsupportedGrantTypeException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, ID.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(kD, 'UnsupportedGrantTypeException')
	var TD = kD,
		BD = class ND extends Xt {
			constructor(t) {
				super({
					name: 'InvalidRequestRegionException',
					$fault: 'client',
					...t,
				}),
					(this.name = 'InvalidRequestRegionException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, ND.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description),
					(this.endpoint = t.endpoint),
					(this.region = t.region)
			}
		}
	se(BD, 'InvalidRequestRegionException')
	var DD = BD,
		LD = class FD extends Xt {
			constructor(t) {
				super({
					name: 'InvalidClientMetadataException',
					$fault: 'client',
					...t,
				}),
					(this.name = 'InvalidClientMetadataException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, FD.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(LD, 'InvalidClientMetadataException')
	var MD = LD,
		qD = class jD extends Xt {
			constructor(t) {
				super({ name: 'InvalidRedirectUriException', $fault: 'client', ...t }),
					(this.name = 'InvalidRedirectUriException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, jD.prototype),
					(this.error = t.error),
					(this.error_description = t.error_description)
			}
		}
	se(qD, 'InvalidRedirectUriException')
	var UD = qD,
		GD = se(
			(e) => ({
				...e,
				...(e.clientSecret && { clientSecret: O.SENSITIVE_STRING }),
				...(e.refreshToken && { refreshToken: O.SENSITIVE_STRING }),
				...(e.codeVerifier && { codeVerifier: O.SENSITIVE_STRING }),
			}),
			'CreateTokenRequestFilterSensitiveLog',
		),
		zD = se(
			(e) => ({
				...e,
				...(e.accessToken && { accessToken: O.SENSITIVE_STRING }),
				...(e.refreshToken && { refreshToken: O.SENSITIVE_STRING }),
				...(e.idToken && { idToken: O.SENSITIVE_STRING }),
			}),
			'CreateTokenResponseFilterSensitiveLog',
		),
		HD = se(
			(e) => ({
				...e,
				...(e.refreshToken && { refreshToken: O.SENSITIVE_STRING }),
				...(e.assertion && { assertion: O.SENSITIVE_STRING }),
				...(e.subjectToken && { subjectToken: O.SENSITIVE_STRING }),
				...(e.codeVerifier && { codeVerifier: O.SENSITIVE_STRING }),
			}),
			'CreateTokenWithIAMRequestFilterSensitiveLog',
		),
		$D = se(
			(e) => ({
				...e,
				...(e.accessToken && { accessToken: O.SENSITIVE_STRING }),
				...(e.refreshToken && { refreshToken: O.SENSITIVE_STRING }),
				...(e.idToken && { idToken: O.SENSITIVE_STRING }),
			}),
			'CreateTokenWithIAMResponseFilterSensitiveLog',
		),
		VD = se(
			(e) => ({
				...e,
				...(e.clientSecret && { clientSecret: O.SENSITIVE_STRING }),
			}),
			'RegisterClientResponseFilterSensitiveLog',
		),
		KD = se(
			(e) => ({
				...e,
				...(e.clientSecret && { clientSecret: O.SENSITIVE_STRING }),
			}),
			'StartDeviceAuthorizationRequestFilterSensitiveLog',
		),
		Ys = (zt(), ve(Gt)),
		Kne = se(async (e, t) => {
			let r = (0, Co.requestBuilder)(e, t),
				n = { 'content-type': 'application/json' }
			r.bp('/token')
			let i
			return (
				(i = JSON.stringify(
					(0, O.take)(e, {
						clientId: [],
						clientSecret: [],
						code: [],
						codeVerifier: [],
						deviceCode: [],
						grantType: [],
						redirectUri: [],
						refreshToken: [],
						scope: (o) => (0, O._json)(o),
					}),
				)),
				r.m('POST').h(n).b(i),
				r.build()
			)
		}, 'se_CreateTokenCommand'),
		Wne = se(async (e, t) => {
			let r = (0, Co.requestBuilder)(e, t),
				n = { 'content-type': 'application/json' }
			r.bp('/token')
			let i = (0, O.map)({ [vie]: [, 't'] }),
				o
			return (
				(o = JSON.stringify(
					(0, O.take)(e, {
						assertion: [],
						clientId: [],
						code: [],
						codeVerifier: [],
						grantType: [],
						redirectUri: [],
						refreshToken: [],
						requestedTokenType: [],
						scope: (s) => (0, O._json)(s),
						subjectToken: [],
						subjectTokenType: [],
					}),
				)),
				r.m('POST').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_CreateTokenWithIAMCommand'),
		Xne = se(async (e, t) => {
			let r = (0, Co.requestBuilder)(e, t),
				n = { 'content-type': 'application/json' }
			r.bp('/client/register')
			let i
			return (
				(i = JSON.stringify(
					(0, O.take)(e, {
						clientName: [],
						clientType: [],
						entitledApplicationArn: [],
						grantTypes: (o) => (0, O._json)(o),
						issuerUrl: [],
						redirectUris: (o) => (0, O._json)(o),
						scopes: (o) => (0, O._json)(o),
					}),
				)),
				r.m('POST').h(n).b(i),
				r.build()
			)
		}, 'se_RegisterClientCommand'),
		Yne = se(async (e, t) => {
			let r = (0, Co.requestBuilder)(e, t),
				n = { 'content-type': 'application/json' }
			r.bp('/device_authorization')
			let i
			return (
				(i = JSON.stringify(
					(0, O.take)(e, { clientId: [], clientSecret: [], startUrl: [] }),
				)),
				r.m('POST').h(n).b(i),
				r.build()
			)
		}, 'se_StartDeviceAuthorizationCommand'),
		Jne = se(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return Dm(e, t)
			let r = (0, O.map)({ $metadata: Lt(e) }),
				n = (0, O.expectNonNull)(
					(0, O.expectObject)(await (0, Ys.parseJsonBody)(e.body, t)),
					'body',
				),
				i = (0, O.take)(n, {
					accessToken: O.expectString,
					expiresIn: O.expectInt32,
					idToken: O.expectString,
					refreshToken: O.expectString,
					tokenType: O.expectString,
				})
			return Object.assign(r, i), r
		}, 'de_CreateTokenCommand'),
		Qne = se(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return Dm(e, t)
			let r = (0, O.map)({ $metadata: Lt(e) }),
				n = (0, O.expectNonNull)(
					(0, O.expectObject)(await (0, Ys.parseJsonBody)(e.body, t)),
					'body',
				),
				i = (0, O.take)(n, {
					accessToken: O.expectString,
					expiresIn: O.expectInt32,
					idToken: O.expectString,
					issuedTokenType: O.expectString,
					refreshToken: O.expectString,
					scope: O._json,
					tokenType: O.expectString,
				})
			return Object.assign(r, i), r
		}, 'de_CreateTokenWithIAMCommand'),
		Zne = se(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return Dm(e, t)
			let r = (0, O.map)({ $metadata: Lt(e) }),
				n = (0, O.expectNonNull)(
					(0, O.expectObject)(await (0, Ys.parseJsonBody)(e.body, t)),
					'body',
				),
				i = (0, O.take)(n, {
					authorizationEndpoint: O.expectString,
					clientId: O.expectString,
					clientIdIssuedAt: O.expectLong,
					clientSecret: O.expectString,
					clientSecretExpiresAt: O.expectLong,
					tokenEndpoint: O.expectString,
				})
			return Object.assign(r, i), r
		}, 'de_RegisterClientCommand'),
		eie = se(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return Dm(e, t)
			let r = (0, O.map)({ $metadata: Lt(e) }),
				n = (0, O.expectNonNull)(
					(0, O.expectObject)(await (0, Ys.parseJsonBody)(e.body, t)),
					'body',
				),
				i = (0, O.take)(n, {
					deviceCode: O.expectString,
					expiresIn: O.expectInt32,
					interval: O.expectInt32,
					userCode: O.expectString,
					verificationUri: O.expectString,
					verificationUriComplete: O.expectString,
				})
			return Object.assign(r, i), r
		}, 'de_StartDeviceAuthorizationCommand'),
		Dm = se(async (e, t) => {
			let r = { ...e, body: await (0, Ys.parseJsonErrorBody)(e.body, t) },
				n = (0, Ys.loadRestJsonErrorCode)(e, r.body)
			switch (n) {
				case 'AccessDeniedException':
				case 'com.amazonaws.ssooidc#AccessDeniedException':
					throw await rie(r, t)
				case 'AuthorizationPendingException':
				case 'com.amazonaws.ssooidc#AuthorizationPendingException':
					throw await nie(r, t)
				case 'ExpiredTokenException':
				case 'com.amazonaws.ssooidc#ExpiredTokenException':
					throw await iie(r, t)
				case 'InternalServerException':
				case 'com.amazonaws.ssooidc#InternalServerException':
					throw await oie(r, t)
				case 'InvalidClientException':
				case 'com.amazonaws.ssooidc#InvalidClientException':
					throw await sie(r, t)
				case 'InvalidGrantException':
				case 'com.amazonaws.ssooidc#InvalidGrantException':
					throw await cie(r, t)
				case 'InvalidRequestException':
				case 'com.amazonaws.ssooidc#InvalidRequestException':
					throw await die(r, t)
				case 'InvalidScopeException':
				case 'com.amazonaws.ssooidc#InvalidScopeException':
					throw await mie(r, t)
				case 'SlowDownException':
				case 'com.amazonaws.ssooidc#SlowDownException':
					throw await fie(r, t)
				case 'UnauthorizedClientException':
				case 'com.amazonaws.ssooidc#UnauthorizedClientException':
					throw await pie(r, t)
				case 'UnsupportedGrantTypeException':
				case 'com.amazonaws.ssooidc#UnsupportedGrantTypeException':
					throw await gie(r, t)
				case 'InvalidRequestRegionException':
				case 'com.amazonaws.ssooidc#InvalidRequestRegionException':
					throw await uie(r, t)
				case 'InvalidClientMetadataException':
				case 'com.amazonaws.ssooidc#InvalidClientMetadataException':
					throw await aie(r, t)
				case 'InvalidRedirectUriException':
				case 'com.amazonaws.ssooidc#InvalidRedirectUriException':
					throw await lie(r, t)
				default:
					let i = r.body
					return tie({ output: e, parsedBody: i, errorCode: n })
			}
		}, 'de_CommandError'),
		tie = (0, O.withBaseException)(Xt),
		rie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new rD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_AccessDeniedExceptionRes'),
		nie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new oD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_AuthorizationPendingExceptionRes'),
		iie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new cD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_ExpiredTokenExceptionRes'),
		oie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new uD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_InternalServerExceptionRes'),
		sie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new pD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_InvalidClientExceptionRes'),
		aie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new MD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_InvalidClientMetadataExceptionRes'),
		cie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new hD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_InvalidGrantExceptionRes'),
		lie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new UD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_InvalidRedirectUriExceptionRes'),
		die = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new SD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_InvalidRequestExceptionRes'),
		uie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					endpoint: O.expectString,
					error: O.expectString,
					error_description: O.expectString,
					region: O.expectString,
				})
			Object.assign(r, i)
			let o = new DD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_InvalidRequestRegionExceptionRes'),
		mie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new bD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_InvalidScopeExceptionRes'),
		fie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new PD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_SlowDownExceptionRes'),
		pie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new RD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_UnauthorizedClientExceptionRes'),
		gie = se(async (e, t) => {
			let r = (0, O.map)({}),
				n = e.body,
				i = (0, O.take)(n, {
					error: O.expectString,
					error_description: O.expectString,
				})
			Object.assign(r, i)
			let o = new TD({ $metadata: Lt(e), ...r })
			return (0, O.decorateServiceException)(o, e.body)
		}, 'de_UnsupportedGrantTypeExceptionRes'),
		Lt = se(
			(e) => ({
				httpStatusCode: e.statusCode,
				requestId:
					e.headers['x-amzn-requestid'] ??
					e.headers['x-amzn-request-id'] ??
					e.headers['x-amz-request-id'],
				extendedRequestId: e.headers['x-amz-id-2'],
				cfId: e.headers['x-amz-cf-id'],
			}),
			'deserializeMetadata',
		),
		vie = 'aws_iam',
		WD = class extends O.Command.classBuilder()
			.ep({ ...Bm })
			.m(function (t, r, n, i) {
				return [
					(0, Nm.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, gl.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSSOOIDCService', 'CreateToken', {})
			.n('SSOOIDCClient', 'CreateTokenCommand')
			.f(GD, zD)
			.ser(Kne)
			.de(Jne)
			.build() {}
	se(WD, 'CreateTokenCommand')
	var XD = WD,
		YD = class extends O.Command.classBuilder()
			.ep({ ...Bm })
			.m(function (t, r, n, i) {
				return [
					(0, Nm.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, gl.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSSOOIDCService', 'CreateTokenWithIAM', {})
			.n('SSOOIDCClient', 'CreateTokenWithIAMCommand')
			.f(HD, $D)
			.ser(Wne)
			.de(Qne)
			.build() {}
	se(YD, 'CreateTokenWithIAMCommand')
	var JD = YD,
		QD = class extends O.Command.classBuilder()
			.ep({ ...Bm })
			.m(function (t, r, n, i) {
				return [
					(0, Nm.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, gl.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSSOOIDCService', 'RegisterClient', {})
			.n('SSOOIDCClient', 'RegisterClientCommand')
			.f(void 0, VD)
			.ser(Xne)
			.de(Zne)
			.build() {}
	se(QD, 'RegisterClientCommand')
	var ZD = QD,
		eL = class extends O.Command.classBuilder()
			.ep({ ...Bm })
			.m(function (t, r, n, i) {
				return [
					(0, Nm.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, gl.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSSOOIDCService', 'StartDeviceAuthorization', {})
			.n('SSOOIDCClient', 'StartDeviceAuthorizationCommand')
			.f(KD, void 0)
			.ser(Yne)
			.de(eie)
			.build() {}
	se(eL, 'StartDeviceAuthorizationCommand')
	var tL = eL,
		hie = {
			CreateTokenCommand: XD,
			CreateTokenWithIAMCommand: JD,
			RegisterClientCommand: ZD,
			StartDeviceAuthorizationCommand: tL,
		},
		rL = class extends JN {}
	se(rL, 'SSOOIDC')
	var nL = rL
	;(0, O.createAggregatedClient)(hie, nL)
})
var mL = E((oTe, uL) => {
	'use strict'
	var _ie = Object.create,
		hl = Object.defineProperty,
		yie = Object.getOwnPropertyDescriptor,
		Sie = Object.getOwnPropertyNames,
		Cie = Object.getPrototypeOf,
		Eie = Object.prototype.hasOwnProperty,
		Ri = (e, t) => hl(e, 'name', { value: t, configurable: !0 }),
		bie = (e, t) => {
			for (var r in t) hl(e, r, { get: t[r], enumerable: !0 })
		},
		aL = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Sie(t))
					!Eie.call(e, i) &&
						i !== r &&
						hl(e, i, {
							get: () => t[i],
							enumerable: !(n = yie(t, i)) || n.enumerable,
						})
			return e
		},
		cL = (e, t, r) => (
			(r = e != null ? _ie(Cie(e)) : {}),
			aL(
				t || !e || !e.__esModule
					? hl(r, 'default', { value: e, enumerable: !0 })
					: r,
				e,
			)
		),
		wie = (e) => aL(hl({}, '__esModule', { value: !0 }), e),
		lL = {}
	bie(lL, { fromSso: () => dL, fromStatic: () => Iie, nodeProvider: () => Tie })
	uL.exports = wie(lL)
	var xie = 5 * 60 * 1e3,
		g_ =
			"To refresh this SSO session run 'aws sso login' with the corresponding profile.",
		p_ = {},
		Pie = Ri(async (e) => {
			let { SSOOIDCClient: t } = await Promise.resolve().then(() => cL(f_()))
			if (p_[e]) return p_[e]
			let r = new t({ region: e })
			return (p_[e] = r), r
		}, 'getSsoOidcClient'),
		Aie = Ri(async (e, t) => {
			let { CreateTokenCommand: r } = await Promise.resolve().then(() =>
				cL(f_()),
			)
			return (await Pie(t)).send(
				new r({
					clientId: e.clientId,
					clientSecret: e.clientSecret,
					refreshToken: e.refreshToken,
					grantType: 'refresh_token',
				}),
			)
		}, 'getNewSsoOidcToken'),
		cn = nr(),
		oL = Ri((e) => {
			if (e.expiration && e.expiration.getTime() < Date.now())
				throw new cn.TokenProviderError(`Token is expired. ${g_}`, !1)
		}, 'validateTokenExpiry'),
		Eo = Ri((e, t, r = !1) => {
			if (typeof t > 'u')
				throw new cn.TokenProviderError(
					`Value not present for '${e}' in SSO Token${r ? '. Cannot refresh' : ''}. ${g_}`,
					!1,
				)
		}, 'validateTokenKey'),
		vl = hi(),
		Oie = require('fs'),
		{ writeFile: Rie } = Oie.promises,
		kie = Ri((e, t) => {
			let r = (0, vl.getSSOTokenFilepath)(e),
				n = JSON.stringify(t, null, 2)
			return Rie(r, n)
		}, 'writeSSOTokenToFile'),
		sL = new Date(0),
		dL = Ri(
			(e = {}) =>
				async () => {
					var t
					;(t = e.logger) == null ||
						t.debug('@aws-sdk/token-providers - fromSso')
					let r = await (0, vl.parseKnownFiles)(e),
						n = (0, vl.getProfileName)(e),
						i = r[n]
					if (i) {
						if (!i.sso_session)
							throw new cn.TokenProviderError(
								`Profile '${n}' is missing required property 'sso_session'.`,
							)
					} else
						throw new cn.TokenProviderError(
							`Profile '${n}' could not be found in shared credentials file.`,
							!1,
						)
					let o = i.sso_session,
						c = (await (0, vl.loadSsoSessionData)(e))[o]
					if (!c)
						throw new cn.TokenProviderError(
							`Sso session '${o}' could not be found in shared credentials file.`,
							!1,
						)
					for (let v of ['sso_start_url', 'sso_region'])
						if (!c[v])
							throw new cn.TokenProviderError(
								`Sso session '${o}' is missing required property '${v}'.`,
								!1,
							)
					let l = c.sso_start_url,
						u = c.sso_region,
						m
					try {
						m = await (0, vl.getSSOTokenFromFile)(o)
					} catch {
						throw new cn.TokenProviderError(
							`The SSO session token associated with profile=${n} was not found or is invalid. ${g_}`,
							!1,
						)
					}
					Eo('accessToken', m.accessToken), Eo('expiresAt', m.expiresAt)
					let { accessToken: f, expiresAt: p } = m,
						g = { token: f, expiration: new Date(p) }
					if (g.expiration.getTime() - Date.now() > xie) return g
					if (Date.now() - sL.getTime() < 30 * 1e3) return oL(g), g
					Eo('clientId', m.clientId, !0),
						Eo('clientSecret', m.clientSecret, !0),
						Eo('refreshToken', m.refreshToken, !0)
					try {
						sL.setTime(Date.now())
						let v = await Aie(m, u)
						Eo('accessToken', v.accessToken), Eo('expiresIn', v.expiresIn)
						let _ = new Date(Date.now() + v.expiresIn * 1e3)
						try {
							await kie(o, {
								...m,
								accessToken: v.accessToken,
								expiresAt: _.toISOString(),
								refreshToken: v.refreshToken,
							})
						} catch {}
						return { token: v.accessToken, expiration: _ }
					} catch {
						return oL(g), g
					}
				},
			'fromSso',
		),
		Iie = Ri(
			({ token: e, logger: t }) =>
				async () => {
					if (
						(t?.debug('@aws-sdk/token-providers - fromStatic'), !e || !e.token)
					)
						throw new cn.TokenProviderError(
							'Please pass a valid token to fromStatic',
							!1,
						)
					return e
				},
			'fromStatic',
		),
		Tie = Ri(
			(e = {}) =>
				(0, cn.memoize)(
					(0, cn.chain)(dL(e), async () => {
						throw new cn.TokenProviderError(
							'Could not load token from any providers',
							!1,
						)
					}),
					(t) =>
						t.expiration !== void 0 &&
						t.expiration.getTime() - Date.now() < 3e5,
					(t) => t.expiration !== void 0,
				),
			'nodeProvider',
		)
})
var h_ = E((sTe, SL) => {
	'use strict'
	var Fm = Object.defineProperty,
		Bie = Object.getOwnPropertyDescriptor,
		pL = Object.getOwnPropertyNames,
		Nie = Object.prototype.hasOwnProperty,
		Mm = (e, t) => Fm(e, 'name', { value: t, configurable: !0 }),
		Die = (e, t) =>
			function () {
				return e && (t = (0, e[pL(e)[0]])((e = 0))), t
			},
		gL = (e, t) => {
			for (var r in t) Fm(e, r, { get: t[r], enumerable: !0 })
		},
		Lie = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of pL(t))
					!Nie.call(e, i) &&
						i !== r &&
						Fm(e, i, {
							get: () => t[i],
							enumerable: !(n = Bie(t, i)) || n.enumerable,
						})
			return e
		},
		Fie = (e) => Lie(Fm({}, '__esModule', { value: !0 }), e),
		vL = {}
	gL(vL, {
		GetRoleCredentialsCommand: () => v_.GetRoleCredentialsCommand,
		SSOClient: () => v_.SSOClient,
	})
	var v_,
		Mie = Die({
			'src/loadSso.ts'() {
				'use strict'
				v_ = hN()
			},
		}),
		hL = {}
	gL(hL, {
		fromSSO: () => jie,
		isSsoProfile: () => _L,
		validateSsoProfile: () => yL,
	})
	SL.exports = Fie(hL)
	var _L = Mm(
			(e) =>
				e &&
				(typeof e.sso_start_url == 'string' ||
					typeof e.sso_account_id == 'string' ||
					typeof e.sso_session == 'string' ||
					typeof e.sso_region == 'string' ||
					typeof e.sso_role_name == 'string'),
			'isSsoProfile',
		),
		qie = mL(),
		ln = nr(),
		Lm = hi(),
		_l = !1,
		fL = Mm(
			async ({
				ssoStartUrl: e,
				ssoSession: t,
				ssoAccountId: r,
				ssoRegion: n,
				ssoRoleName: i,
				ssoClient: o,
				clientConfig: s,
				profile: c,
				logger: l,
			}) => {
				let u,
					m =
						'To refresh this SSO session run aws sso login with the corresponding profile.'
				if (t)
					try {
						let b = await (0, qie.fromSso)({ profile: c })()
						u = {
							accessToken: b.token,
							expiresAt: new Date(b.expiration).toISOString(),
						}
					} catch (b) {
						throw new ln.CredentialsProviderError(b.message, {
							tryNextLink: _l,
							logger: l,
						})
					}
				else
					try {
						u = await (0, Lm.getSSOTokenFromFile)(e)
					} catch {
						throw new ln.CredentialsProviderError(
							`The SSO session associated with this profile is invalid. ${m}`,
							{ tryNextLink: _l, logger: l },
						)
					}
				if (new Date(u.expiresAt).getTime() - Date.now() <= 0)
					throw new ln.CredentialsProviderError(
						`The SSO session associated with this profile has expired. ${m}`,
						{ tryNextLink: _l, logger: l },
					)
				let { accessToken: f } = u,
					{ SSOClient: p, GetRoleCredentialsCommand: g } =
						await Promise.resolve().then(() => (Mie(), vL)),
					v =
						o || new p(Object.assign({}, s ?? {}, { region: s?.region ?? n })),
					_
				try {
					_ = await v.send(new g({ accountId: r, roleName: i, accessToken: f }))
				} catch (b) {
					throw new ln.CredentialsProviderError(b, {
						tryNextLink: _l,
						logger: l,
					})
				}
				let {
					roleCredentials: {
						accessKeyId: y,
						secretAccessKey: P,
						sessionToken: x,
						expiration: W,
						credentialScope: X,
						accountId: w,
					} = {},
				} = _
				if (!y || !P || !x || !W)
					throw new ln.CredentialsProviderError(
						'SSO returns an invalid temporary credential.',
						{ tryNextLink: _l, logger: l },
					)
				return {
					accessKeyId: y,
					secretAccessKey: P,
					sessionToken: x,
					expiration: new Date(W),
					...(X && { credentialScope: X }),
					...(w && { accountId: w }),
				}
			},
			'resolveSSOCredentials',
		),
		yL = Mm((e, t) => {
			let {
				sso_start_url: r,
				sso_account_id: n,
				sso_region: i,
				sso_role_name: o,
			} = e
			if (!r || !n || !i || !o)
				throw new ln.CredentialsProviderError(
					`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(e).join(', ')}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`,
					{ tryNextLink: !1, logger: t },
				)
			return e
		}, 'validateSsoProfile'),
		jie = Mm(
			(e = {}) =>
				async () => {
					var t
					;(t = e.logger) == null ||
						t.debug('@aws-sdk/credential-provider-sso - fromSSO')
					let {
							ssoStartUrl: r,
							ssoAccountId: n,
							ssoRegion: i,
							ssoRoleName: o,
							ssoSession: s,
						} = e,
						{ ssoClient: c } = e,
						l = (0, Lm.getProfileName)(e)
					if (!r && !n && !i && !o && !s) {
						let m = (await (0, Lm.parseKnownFiles)(e))[l]
						if (!m)
							throw new ln.CredentialsProviderError(
								`Profile ${l} was not found.`,
								{ logger: e.logger },
							)
						if (!_L(m))
							throw new ln.CredentialsProviderError(
								`Profile ${l} is not configured with SSO credentials.`,
								{ logger: e.logger },
							)
						if (m?.sso_session) {
							let P = (await (0, Lm.loadSsoSessionData)(e))[m.sso_session],
								x = ` configurations in profile ${l} and sso-session ${m.sso_session}`
							if (i && i !== P.sso_region)
								throw new ln.CredentialsProviderError(
									'Conflicting SSO region' + x,
									{ tryNextLink: !1, logger: e.logger },
								)
							if (r && r !== P.sso_start_url)
								throw new ln.CredentialsProviderError(
									'Conflicting SSO start_url' + x,
									{ tryNextLink: !1, logger: e.logger },
								)
							;(m.sso_region = P.sso_region),
								(m.sso_start_url = P.sso_start_url)
						}
						let {
							sso_start_url: f,
							sso_account_id: p,
							sso_region: g,
							sso_role_name: v,
							sso_session: _,
						} = yL(m, e.logger)
						return fL({
							ssoStartUrl: f,
							ssoSession: _,
							ssoAccountId: p,
							ssoRegion: g,
							ssoRoleName: v,
							ssoClient: c,
							clientConfig: e.clientConfig,
							profile: l,
						})
					} else {
						if (!r || !n || !i || !o)
							throw new ln.CredentialsProviderError(
								'Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"',
								{ tryNextLink: !1, logger: e.logger },
							)
						return fL({
							ssoStartUrl: r,
							ssoSession: s,
							ssoAccountId: n,
							ssoRegion: i,
							ssoRoleName: o,
							ssoClient: c,
							clientConfig: e.clientConfig,
							profile: l,
						})
					}
				},
			'fromSSO',
		)
})
var __ = E((dn) => {
	'use strict'
	Object.defineProperty(dn, '__esModule', { value: !0 })
	dn.resolveHttpAuthSchemeConfig =
		dn.resolveStsAuthConfig =
		dn.defaultSTSHttpAuthSchemeProvider =
		dn.defaultSTSHttpAuthSchemeParametersProvider =
			void 0
	var Uie = (zt(), ve(Gt)),
		CL = Tr(),
		Gie = yl(),
		zie = async (e, t, r) => ({
			operation: (0, CL.getSmithyContext)(t).operation,
			region:
				(await (0, CL.normalizeProvider)(e.region)()) ||
				(() => {
					throw new Error(
						'expected `region` to be configured for `aws.auth#sigv4`',
					)
				})(),
		})
	dn.defaultSTSHttpAuthSchemeParametersProvider = zie
	function Hie(e) {
		return {
			schemeId: 'aws.auth#sigv4',
			signingProperties: { name: 'sts', region: e.region },
			propertiesExtractor: (t, r) => ({
				signingProperties: { config: t, context: r },
			}),
		}
	}
	function EL(e) {
		return { schemeId: 'smithy.api#noAuth' }
	}
	var $ie = (e) => {
		let t = []
		switch (e.operation) {
			case 'AssumeRoleWithSAML': {
				t.push(EL(e))
				break
			}
			case 'AssumeRoleWithWebIdentity': {
				t.push(EL(e))
				break
			}
			default:
				t.push(Hie(e))
		}
		return t
	}
	dn.defaultSTSHttpAuthSchemeProvider = $ie
	var Vie = (e) => ({ ...e, stsClientCtor: Gie.STSClient })
	dn.resolveStsAuthConfig = Vie
	var Kie = (e) => {
		let t = (0, dn.resolveStsAuthConfig)(e)
		return { ...(0, Uie.resolveAwsSdkSigV4Config)(t) }
	}
	dn.resolveHttpAuthSchemeConfig = Kie
})
var un = E((Js) => {
	'use strict'
	Object.defineProperty(Js, '__esModule', { value: !0 })
	Js.commonParams = Js.resolveClientEndpointParameters = void 0
	var Wie = (e) => ({
		...e,
		useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
		useFipsEndpoint: e.useFipsEndpoint ?? !1,
		useGlobalEndpoint: e.useGlobalEndpoint ?? !1,
		defaultSigningName: 'sts',
	})
	Js.resolveClientEndpointParameters = Wie
	Js.commonParams = {
		UseGlobalEndpoint: { type: 'builtInParams', name: 'useGlobalEndpoint' },
		UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
		Endpoint: { type: 'builtInParams', name: 'endpoint' },
		Region: { type: 'builtInParams', name: 'region' },
		UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
	}
})
var bL = E((lTe, Xie) => {
	Xie.exports = {
		name: '@aws-sdk/client-sts',
		description:
			'AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native',
		version: '3.645.0',
		scripts: {
			build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
			'build:cjs': 'node ../../scripts/compilation/inline client-sts',
			'build:es': 'tsc -p tsconfig.es.json',
			'build:include:deps':
				'lerna run --scope $npm_package_name --include-dependencies build',
			'build:types':
				'rimraf ./dist-types tsconfig.types.tsbuildinfo && tsc -p tsconfig.types.json',
			'build:types:downlevel': 'downlevel-dts dist-types dist-types/ts3.4',
			clean: 'rimraf ./dist-* && rimraf *.tsbuildinfo',
			'extract:docs': 'api-extractor run --local',
			'generate:client':
				'node ../../scripts/generate-clients/single-service --solo sts',
			test: 'yarn test:unit',
			'test:unit': 'jest',
		},
		main: './dist-cjs/index.js',
		types: './dist-types/index.d.ts',
		module: './dist-es/index.js',
		sideEffects: !1,
		dependencies: {
			'@aws-crypto/sha256-browser': '5.2.0',
			'@aws-crypto/sha256-js': '5.2.0',
			'@aws-sdk/client-sso-oidc': '3.645.0',
			'@aws-sdk/core': '3.635.0',
			'@aws-sdk/credential-provider-node': '3.645.0',
			'@aws-sdk/middleware-host-header': '3.620.0',
			'@aws-sdk/middleware-logger': '3.609.0',
			'@aws-sdk/middleware-recursion-detection': '3.620.0',
			'@aws-sdk/middleware-user-agent': '3.645.0',
			'@aws-sdk/region-config-resolver': '3.614.0',
			'@aws-sdk/types': '3.609.0',
			'@aws-sdk/util-endpoints': '3.645.0',
			'@aws-sdk/util-user-agent-browser': '3.609.0',
			'@aws-sdk/util-user-agent-node': '3.614.0',
			'@smithy/config-resolver': '^3.0.5',
			'@smithy/core': '^2.4.0',
			'@smithy/fetch-http-handler': '^3.2.4',
			'@smithy/hash-node': '^3.0.3',
			'@smithy/invalid-dependency': '^3.0.3',
			'@smithy/middleware-content-length': '^3.0.5',
			'@smithy/middleware-endpoint': '^3.1.0',
			'@smithy/middleware-retry': '^3.0.15',
			'@smithy/middleware-serde': '^3.0.3',
			'@smithy/middleware-stack': '^3.0.3',
			'@smithy/node-config-provider': '^3.1.4',
			'@smithy/node-http-handler': '^3.1.4',
			'@smithy/protocol-http': '^4.1.0',
			'@smithy/smithy-client': '^3.2.0',
			'@smithy/types': '^3.3.0',
			'@smithy/url-parser': '^3.0.3',
			'@smithy/util-base64': '^3.0.0',
			'@smithy/util-body-length-browser': '^3.0.0',
			'@smithy/util-body-length-node': '^3.0.0',
			'@smithy/util-defaults-mode-browser': '^3.0.15',
			'@smithy/util-defaults-mode-node': '^3.0.15',
			'@smithy/util-endpoints': '^2.0.5',
			'@smithy/util-middleware': '^3.0.3',
			'@smithy/util-retry': '^3.0.3',
			'@smithy/util-utf8': '^3.0.0',
			tslib: '^2.6.2',
		},
		devDependencies: {
			'@tsconfig/node16': '16.1.3',
			'@types/node': '^16.18.96',
			concurrently: '7.0.0',
			'downlevel-dts': '0.10.1',
			rimraf: '3.0.2',
			typescript: '~4.9.5',
		},
		engines: { node: '>=16.0.0' },
		typesVersions: { '<4.0': { 'dist-types/*': ['dist-types/ts3.4/*'] } },
		files: ['dist-*/**'],
		author: {
			name: 'AWS SDK for JavaScript Team',
			url: 'https://aws.amazon.com/javascript/',
		},
		license: 'Apache-2.0',
		browser: { './dist-es/runtimeConfig': './dist-es/runtimeConfig.browser' },
		'react-native': {
			'./dist-es/runtimeConfig': './dist-es/runtimeConfig.native',
		},
		homepage:
			'https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts',
		repository: {
			type: 'git',
			url: 'https://github.com/aws/aws-sdk-js-v3.git',
			directory: 'clients/client-sts',
		},
	}
})
var $L = E((qm) => {
	'use strict'
	Object.defineProperty(qm, '__esModule', { value: !0 })
	qm.ruleSet = void 0
	var DL = 'required',
		he = 'type',
		Te = 'fn',
		Be = 'argv',
		Ii = 'ref',
		wL = !1,
		y_ = !0,
		ki = 'booleanEquals',
		Ht = 'stringEquals',
		LL = 'sigv4',
		FL = 'sts',
		ML = 'us-east-1',
		rt = 'endpoint',
		xL = 'https://sts.{Region}.{PartitionResult#dnsSuffix}',
		In = 'tree',
		Qs = 'error',
		C_ = 'getAttr',
		PL = { [DL]: !1, [he]: 'String' },
		S_ = { [DL]: !0, default: !1, [he]: 'Boolean' },
		qL = { [Ii]: 'Endpoint' },
		AL = { [Te]: 'isSet', [Be]: [{ [Ii]: 'Region' }] },
		$t = { [Ii]: 'Region' },
		OL = { [Te]: 'aws.partition', [Be]: [$t], assign: 'PartitionResult' },
		jL = { [Ii]: 'UseFIPS' },
		UL = { [Ii]: 'UseDualStack' },
		Yt = {
			url: 'https://sts.amazonaws.com',
			properties: {
				authSchemes: [{ name: LL, signingName: FL, signingRegion: ML }],
			},
			headers: {},
		},
		Ar = {},
		RL = {
			conditions: [{ [Te]: Ht, [Be]: [$t, 'aws-global'] }],
			[rt]: Yt,
			[he]: rt,
		},
		GL = { [Te]: ki, [Be]: [jL, !0] },
		zL = { [Te]: ki, [Be]: [UL, !0] },
		kL = { [Te]: C_, [Be]: [{ [Ii]: 'PartitionResult' }, 'supportsFIPS'] },
		HL = { [Ii]: 'PartitionResult' },
		IL = {
			[Te]: ki,
			[Be]: [!0, { [Te]: C_, [Be]: [HL, 'supportsDualStack'] }],
		},
		TL = [{ [Te]: 'isSet', [Be]: [qL] }],
		BL = [GL],
		NL = [zL],
		Yie = {
			version: '1.0',
			parameters: {
				Region: PL,
				UseDualStack: S_,
				UseFIPS: S_,
				Endpoint: PL,
				UseGlobalEndpoint: S_,
			},
			rules: [
				{
					conditions: [
						{ [Te]: ki, [Be]: [{ [Ii]: 'UseGlobalEndpoint' }, y_] },
						{ [Te]: 'not', [Be]: TL },
						AL,
						OL,
						{ [Te]: ki, [Be]: [jL, wL] },
						{ [Te]: ki, [Be]: [UL, wL] },
					],
					rules: [
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'ap-northeast-1'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'ap-south-1'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'ap-southeast-1'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'ap-southeast-2'] }],
							endpoint: Yt,
							[he]: rt,
						},
						RL,
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'ca-central-1'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'eu-central-1'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'eu-north-1'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'eu-west-1'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'eu-west-2'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'eu-west-3'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'sa-east-1'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, ML] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'us-east-2'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'us-west-1'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							conditions: [{ [Te]: Ht, [Be]: [$t, 'us-west-2'] }],
							endpoint: Yt,
							[he]: rt,
						},
						{
							endpoint: {
								url: xL,
								properties: {
									authSchemes: [
										{ name: LL, signingName: FL, signingRegion: '{Region}' },
									],
								},
								headers: Ar,
							},
							[he]: rt,
						},
					],
					[he]: In,
				},
				{
					conditions: TL,
					rules: [
						{
							conditions: BL,
							error:
								'Invalid Configuration: FIPS and custom endpoint are not supported',
							[he]: Qs,
						},
						{
							conditions: NL,
							error:
								'Invalid Configuration: Dualstack and custom endpoint are not supported',
							[he]: Qs,
						},
						{ endpoint: { url: qL, properties: Ar, headers: Ar }, [he]: rt },
					],
					[he]: In,
				},
				{
					conditions: [AL],
					rules: [
						{
							conditions: [OL],
							rules: [
								{
									conditions: [GL, zL],
									rules: [
										{
											conditions: [{ [Te]: ki, [Be]: [y_, kL] }, IL],
											rules: [
												{
													endpoint: {
														url: 'https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}',
														properties: Ar,
														headers: Ar,
													},
													[he]: rt,
												},
											],
											[he]: In,
										},
										{
											error:
												'FIPS and DualStack are enabled, but this partition does not support one or both',
											[he]: Qs,
										},
									],
									[he]: In,
								},
								{
									conditions: BL,
									rules: [
										{
											conditions: [{ [Te]: ki, [Be]: [kL, y_] }],
											rules: [
												{
													conditions: [
														{
															[Te]: Ht,
															[Be]: [
																{ [Te]: C_, [Be]: [HL, 'name'] },
																'aws-us-gov',
															],
														},
													],
													endpoint: {
														url: 'https://sts.{Region}.amazonaws.com',
														properties: Ar,
														headers: Ar,
													},
													[he]: rt,
												},
												{
													endpoint: {
														url: 'https://sts-fips.{Region}.{PartitionResult#dnsSuffix}',
														properties: Ar,
														headers: Ar,
													},
													[he]: rt,
												},
											],
											[he]: In,
										},
										{
											error:
												'FIPS is enabled but this partition does not support FIPS',
											[he]: Qs,
										},
									],
									[he]: In,
								},
								{
									conditions: NL,
									rules: [
										{
											conditions: [IL],
											rules: [
												{
													endpoint: {
														url: 'https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}',
														properties: Ar,
														headers: Ar,
													},
													[he]: rt,
												},
											],
											[he]: In,
										},
										{
											error:
												'DualStack is enabled but this partition does not support DualStack',
											[he]: Qs,
										},
									],
									[he]: In,
								},
								RL,
								{
									endpoint: { url: xL, properties: Ar, headers: Ar },
									[he]: rt,
								},
							],
							[he]: In,
						},
					],
					[he]: In,
				},
				{ error: 'Invalid Configuration: Missing Region', [he]: Qs },
			],
		}
	qm.ruleSet = Yie
})
var KL = E((jm) => {
	'use strict'
	Object.defineProperty(jm, '__esModule', { value: !0 })
	jm.defaultEndpointResolver = void 0
	var Jie = Bs(),
		VL = Is(),
		Qie = $L(),
		Zie = (e, t = {}) =>
			(0, VL.resolveEndpoint)(Qie.ruleSet, {
				endpointParams: e,
				logger: t.logger,
			})
	jm.defaultEndpointResolver = Zie
	VL.customEndpointFunctions.aws = Jie.awsEndpointFunctions
})
var YL = E((Um) => {
	'use strict'
	Object.defineProperty(Um, '__esModule', { value: !0 })
	Um.getRuntimeConfig = void 0
	var eoe = (zt(), ve(Gt)),
		toe = (Ut(), ve(ir)),
		roe = ze(),
		noe = po(),
		WL = gi(),
		XL = rr(),
		ioe = __(),
		ooe = KL(),
		soe = (e) => ({
			apiVersion: '2011-06-15',
			base64Decoder: e?.base64Decoder ?? WL.fromBase64,
			base64Encoder: e?.base64Encoder ?? WL.toBase64,
			disableHostPrefix: e?.disableHostPrefix ?? !1,
			endpointProvider: e?.endpointProvider ?? ooe.defaultEndpointResolver,
			extensions: e?.extensions ?? [],
			httpAuthSchemeProvider:
				e?.httpAuthSchemeProvider ?? ioe.defaultSTSHttpAuthSchemeProvider,
			httpAuthSchemes: e?.httpAuthSchemes ?? [
				{
					schemeId: 'aws.auth#sigv4',
					identityProvider: (t) => t.getIdentityProvider('aws.auth#sigv4'),
					signer: new eoe.AwsSdkSigV4Signer(),
				},
				{
					schemeId: 'smithy.api#noAuth',
					identityProvider: (t) =>
						t.getIdentityProvider('smithy.api#noAuth') || (async () => ({})),
					signer: new toe.NoAuthSigner(),
				},
			],
			logger: e?.logger ?? new roe.NoOpLogger(),
			serviceId: e?.serviceId ?? 'STS',
			urlParser: e?.urlParser ?? noe.parseUrl,
			utf8Decoder: e?.utf8Decoder ?? XL.fromUtf8,
			utf8Encoder: e?.utf8Encoder ?? XL.toUtf8,
		})
	Um.getRuntimeConfig = soe
})
var t3 = E((zm) => {
	'use strict'
	Object.defineProperty(zm, '__esModule', { value: !0 })
	zm.getRuntimeConfig = void 0
	var aoe = (Rn(), ve(On)),
		coe = aoe.__importDefault(bL()),
		JL = (zt(), ve(Gt)),
		QL = km(),
		loe = nl(),
		Gm = wn(),
		doe = (Ut(), ve(ir)),
		uoe = il(),
		ZL = bn(),
		Sl = Hn(),
		e3 = co(),
		moe = ol(),
		foe = Rs(),
		poe = YL(),
		goe = ze(),
		voe = cl(),
		hoe = ze(),
		_oe = (e) => {
			;(0, hoe.emitWarningIfUnsupportedVersion)(process.version)
			let t = (0, voe.resolveDefaultsModeConfig)(e),
				r = () => t().then(goe.loadConfigsForDefaultMode),
				n = (0, poe.getRuntimeConfig)(e)
			return (
				(0, JL.emitWarningIfUnsupportedVersion)(process.version),
				{
					...n,
					...e,
					runtime: 'node',
					defaultsMode: t,
					bodyLengthChecker: e?.bodyLengthChecker ?? moe.calculateBodyLength,
					credentialDefaultProvider:
						e?.credentialDefaultProvider ?? QL.defaultProvider,
					defaultUserAgentProvider:
						e?.defaultUserAgentProvider ??
						(0, loe.defaultUserAgent)({
							serviceId: n.serviceId,
							clientVersion: coe.default.version,
						}),
					httpAuthSchemes: e?.httpAuthSchemes ?? [
						{
							schemeId: 'aws.auth#sigv4',
							identityProvider: (i) =>
								i.getIdentityProvider('aws.auth#sigv4') ||
								(async (o) =>
									await (0, QL.defaultProvider)(o?.__config || {})()),
							signer: new JL.AwsSdkSigV4Signer(),
						},
						{
							schemeId: 'smithy.api#noAuth',
							identityProvider: (i) =>
								i.getIdentityProvider('smithy.api#noAuth') ||
								(async () => ({})),
							signer: new doe.NoAuthSigner(),
						},
					],
					maxAttempts:
						e?.maxAttempts ??
						(0, Sl.loadConfig)(ZL.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
					region:
						e?.region ??
						(0, Sl.loadConfig)(
							Gm.NODE_REGION_CONFIG_OPTIONS,
							Gm.NODE_REGION_CONFIG_FILE_OPTIONS,
						),
					requestHandler: e3.NodeHttpHandler.create(e?.requestHandler ?? r),
					retryMode:
						e?.retryMode ??
						(0, Sl.loadConfig)({
							...ZL.NODE_RETRY_MODE_CONFIG_OPTIONS,
							default: async () =>
								(await r()).retryMode || foe.DEFAULT_RETRY_MODE,
						}),
					sha256: e?.sha256 ?? uoe.Hash.bind(null, 'sha256'),
					streamCollector: e?.streamCollector ?? e3.streamCollector,
					useDualstackEndpoint:
						e?.useDualstackEndpoint ??
						(0, Sl.loadConfig)(Gm.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
					useFipsEndpoint:
						e?.useFipsEndpoint ??
						(0, Sl.loadConfig)(Gm.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
				}
			)
		}
	zm.getRuntimeConfig = _oe
})
var r3 = E((Zs) => {
	'use strict'
	Object.defineProperty(Zs, '__esModule', { value: !0 })
	Zs.resolveHttpAuthRuntimeConfig = Zs.getHttpAuthExtensionConfiguration =
		void 0
	var yoe = (e) => {
		let t = e.httpAuthSchemes,
			r = e.httpAuthSchemeProvider,
			n = e.credentials
		return {
			setHttpAuthScheme(i) {
				let o = t.findIndex((s) => s.schemeId === i.schemeId)
				o === -1 ? t.push(i) : t.splice(o, 1, i)
			},
			httpAuthSchemes() {
				return t
			},
			setHttpAuthSchemeProvider(i) {
				r = i
			},
			httpAuthSchemeProvider() {
				return r
			},
			setCredentials(i) {
				n = i
			},
			credentials() {
				return n
			},
		}
	}
	Zs.getHttpAuthExtensionConfiguration = yoe
	var Soe = (e) => ({
		httpAuthSchemes: e.httpAuthSchemes(),
		httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
		credentials: e.credentials(),
	})
	Zs.resolveHttpAuthRuntimeConfig = Soe
})
var a3 = E(($m) => {
	'use strict'
	Object.defineProperty($m, '__esModule', { value: !0 })
	$m.resolveRuntimeExtensions = void 0
	var n3 = dl(),
		i3 = Xe(),
		o3 = ze(),
		s3 = r3(),
		Hm = (e) => e,
		Coe = (e, t) => {
			let r = {
				...Hm((0, n3.getAwsRegionExtensionConfiguration)(e)),
				...Hm((0, o3.getDefaultExtensionConfiguration)(e)),
				...Hm((0, i3.getHttpHandlerExtensionConfiguration)(e)),
				...Hm((0, s3.getHttpAuthExtensionConfiguration)(e)),
			}
			return (
				t.forEach((n) => n.configure(r)),
				{
					...e,
					...(0, n3.resolveAwsRegionExtensionConfiguration)(r),
					...(0, o3.resolveDefaultRuntimeConfig)(r),
					...(0, i3.resolveHttpHandlerRuntimeConfig)(r),
					...(0, s3.resolveHttpAuthRuntimeConfig)(r),
				}
			)
		}
	$m.resolveRuntimeExtensions = Coe
})
var yl = E((ea) => {
	'use strict'
	Object.defineProperty(ea, '__esModule', { value: !0 })
	ea.STSClient = ea.__Client = void 0
	var c3 = bc(),
		Eoe = wc(),
		boe = xc(),
		l3 = Kc(),
		woe = wn(),
		E_ = (Ut(), ve(ir)),
		xoe = Wc(),
		Poe = $n(),
		d3 = bn(),
		m3 = ze()
	Object.defineProperty(ea, '__Client', {
		enumerable: !0,
		get: function () {
			return m3.Client
		},
	})
	var u3 = __(),
		Aoe = un(),
		Ooe = t3(),
		Roe = a3(),
		b_ = class extends m3.Client {
			constructor(...[t]) {
				let r = (0, Ooe.getRuntimeConfig)(t || {}),
					n = (0, Aoe.resolveClientEndpointParameters)(r),
					i = (0, l3.resolveUserAgentConfig)(n),
					o = (0, d3.resolveRetryConfig)(i),
					s = (0, woe.resolveRegionConfig)(o),
					c = (0, c3.resolveHostHeaderConfig)(s),
					l = (0, Poe.resolveEndpointConfig)(c),
					u = (0, u3.resolveHttpAuthSchemeConfig)(l),
					m = (0, Roe.resolveRuntimeExtensions)(u, t?.extensions || [])
				super(m),
					(this.config = m),
					this.middlewareStack.use((0, l3.getUserAgentPlugin)(this.config)),
					this.middlewareStack.use((0, d3.getRetryPlugin)(this.config)),
					this.middlewareStack.use(
						(0, xoe.getContentLengthPlugin)(this.config),
					),
					this.middlewareStack.use((0, c3.getHostHeaderPlugin)(this.config)),
					this.middlewareStack.use((0, Eoe.getLoggerPlugin)(this.config)),
					this.middlewareStack.use(
						(0, boe.getRecursionDetectionPlugin)(this.config),
					),
					this.middlewareStack.use(
						(0, E_.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
							httpAuthSchemeParametersProvider:
								u3.defaultSTSHttpAuthSchemeParametersProvider,
							identityProviderConfigProvider: async (f) =>
								new E_.DefaultIdentityProviderConfig({
									'aws.auth#sigv4': f.credentials,
								}),
						}),
					),
					this.middlewareStack.use((0, E_.getHttpSigningPlugin)(this.config))
			}
			destroy() {
				super.destroy()
			}
		}
	ea.STSClient = b_
})
var iy = E((PTe, ny) => {
	'use strict'
	var Vm = Object.defineProperty,
		koe = Object.getOwnPropertyDescriptor,
		Ioe = Object.getOwnPropertyNames,
		Toe = Object.prototype.hasOwnProperty,
		F = (e, t) => Vm(e, 'name', { value: t, configurable: !0 }),
		Boe = (e, t) => {
			for (var r in t) Vm(e, r, { get: t[r], enumerable: !0 })
		},
		Q_ = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Ioe(t))
					!Toe.call(e, i) &&
						i !== r &&
						Vm(e, i, {
							get: () => t[i],
							enumerable: !(n = koe(t, i)) || n.enumerable,
						})
			return e
		},
		Noe = (e, t, r) => (Q_(e, t, 'default'), r && Q_(r, t, 'default')),
		Doe = (e) => Q_(Vm({}, '__esModule', { value: !0 }), e),
		Z_ = {}
	Boe(Z_, {
		AssumeRoleCommand: () => ty,
		AssumeRoleResponseFilterSensitiveLog: () => j3,
		AssumeRoleWithSAMLCommand: () => Y3,
		AssumeRoleWithSAMLRequestFilterSensitiveLog: () => U3,
		AssumeRoleWithSAMLResponseFilterSensitiveLog: () => G3,
		AssumeRoleWithWebIdentityCommand: () => ry,
		AssumeRoleWithWebIdentityRequestFilterSensitiveLog: () => z3,
		AssumeRoleWithWebIdentityResponseFilterSensitiveLog: () => H3,
		ClientInputEndpointParameters: () => nae.ClientInputEndpointParameters,
		CredentialsFilterSensitiveLog: () => ca,
		DecodeAuthorizationMessageCommand: () => Z3,
		ExpiredTokenException: () => _3,
		GetAccessKeyInfoCommand: () => tF,
		GetCallerIdentityCommand: () => nF,
		GetFederationTokenCommand: () => oF,
		GetFederationTokenResponseFilterSensitiveLog: () => $3,
		GetSessionTokenCommand: () => aF,
		GetSessionTokenResponseFilterSensitiveLog: () => V3,
		IDPCommunicationErrorException: () => L3,
		IDPRejectedClaimException: () => k3,
		InvalidAuthorizationMessageException: () => q3,
		InvalidIdentityTokenException: () => B3,
		MalformedPolicyDocumentException: () => C3,
		PackedPolicyTooLargeException: () => w3,
		RegionDisabledException: () => A3,
		STS: () => lF,
		STSServiceException: () => Tn,
		decorateDefaultCredentialProvider: () => sae,
		getDefaultRoleAssumer: () => gF,
		getDefaultRoleAssumerWithWebIdentity: () => vF,
	})
	ny.exports = Doe(Z_)
	Noe(Z_, yl(), ny.exports)
	var Ti = $n(),
		Bi = go(),
		Loe = un(),
		ie = ze(),
		p3 = class g3 extends ie.ServiceException {
			constructor(t) {
				super(t), Object.setPrototypeOf(this, g3.prototype)
			}
		}
	F(p3, 'STSServiceException')
	var Tn = p3,
		v3 = class h3 extends Tn {
			constructor(t) {
				super({ name: 'ExpiredTokenException', $fault: 'client', ...t }),
					(this.name = 'ExpiredTokenException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, h3.prototype)
			}
		}
	F(v3, 'ExpiredTokenException')
	var _3 = v3,
		y3 = class S3 extends Tn {
			constructor(t) {
				super({
					name: 'MalformedPolicyDocumentException',
					$fault: 'client',
					...t,
				}),
					(this.name = 'MalformedPolicyDocumentException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, S3.prototype)
			}
		}
	F(y3, 'MalformedPolicyDocumentException')
	var C3 = y3,
		E3 = class b3 extends Tn {
			constructor(t) {
				super({
					name: 'PackedPolicyTooLargeException',
					$fault: 'client',
					...t,
				}),
					(this.name = 'PackedPolicyTooLargeException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, b3.prototype)
			}
		}
	F(E3, 'PackedPolicyTooLargeException')
	var w3 = E3,
		x3 = class P3 extends Tn {
			constructor(t) {
				super({ name: 'RegionDisabledException', $fault: 'client', ...t }),
					(this.name = 'RegionDisabledException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, P3.prototype)
			}
		}
	F(x3, 'RegionDisabledException')
	var A3 = x3,
		O3 = class R3 extends Tn {
			constructor(t) {
				super({ name: 'IDPRejectedClaimException', $fault: 'client', ...t }),
					(this.name = 'IDPRejectedClaimException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, R3.prototype)
			}
		}
	F(O3, 'IDPRejectedClaimException')
	var k3 = O3,
		I3 = class T3 extends Tn {
			constructor(t) {
				super({
					name: 'InvalidIdentityTokenException',
					$fault: 'client',
					...t,
				}),
					(this.name = 'InvalidIdentityTokenException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, T3.prototype)
			}
		}
	F(I3, 'InvalidIdentityTokenException')
	var B3 = I3,
		N3 = class D3 extends Tn {
			constructor(t) {
				super({
					name: 'IDPCommunicationErrorException',
					$fault: 'client',
					...t,
				}),
					(this.name = 'IDPCommunicationErrorException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, D3.prototype)
			}
		}
	F(N3, 'IDPCommunicationErrorException')
	var L3 = N3,
		F3 = class M3 extends Tn {
			constructor(t) {
				super({
					name: 'InvalidAuthorizationMessageException',
					$fault: 'client',
					...t,
				}),
					(this.name = 'InvalidAuthorizationMessageException'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, M3.prototype)
			}
		}
	F(F3, 'InvalidAuthorizationMessageException')
	var q3 = F3,
		ca = F(
			(e) => ({
				...e,
				...(e.SecretAccessKey && { SecretAccessKey: ie.SENSITIVE_STRING }),
			}),
			'CredentialsFilterSensitiveLog',
		),
		j3 = F(
			(e) => ({
				...e,
				...(e.Credentials && { Credentials: ca(e.Credentials) }),
			}),
			'AssumeRoleResponseFilterSensitiveLog',
		),
		U3 = F(
			(e) => ({
				...e,
				...(e.SAMLAssertion && { SAMLAssertion: ie.SENSITIVE_STRING }),
			}),
			'AssumeRoleWithSAMLRequestFilterSensitiveLog',
		),
		G3 = F(
			(e) => ({
				...e,
				...(e.Credentials && { Credentials: ca(e.Credentials) }),
			}),
			'AssumeRoleWithSAMLResponseFilterSensitiveLog',
		),
		z3 = F(
			(e) => ({
				...e,
				...(e.WebIdentityToken && { WebIdentityToken: ie.SENSITIVE_STRING }),
			}),
			'AssumeRoleWithWebIdentityRequestFilterSensitiveLog',
		),
		H3 = F(
			(e) => ({
				...e,
				...(e.Credentials && { Credentials: ca(e.Credentials) }),
			}),
			'AssumeRoleWithWebIdentityResponseFilterSensitiveLog',
		),
		$3 = F(
			(e) => ({
				...e,
				...(e.Credentials && { Credentials: ca(e.Credentials) }),
			}),
			'GetFederationTokenResponseFilterSensitiveLog',
		),
		V3 = F(
			(e) => ({
				...e,
				...(e.Credentials && { Credentials: ca(e.Credentials) }),
			}),
			'GetSessionTokenResponseFilterSensitiveLog',
		),
		ti = (zt(), ve(Gt)),
		Foe = Xe(),
		Moe = F(async (e, t) => {
			let r = Li,
				n
			return (
				(n = ji({ ...cse(e, t), [Mi]: qse, [qi]: Fi })),
				Di(t, r, '/', void 0, n)
			)
		}, 'se_AssumeRoleCommand'),
		qoe = F(async (e, t) => {
			let r = Li,
				n
			return (
				(n = ji({ ...lse(e, t), [Mi]: jse, [qi]: Fi })),
				Di(t, r, '/', void 0, n)
			)
		}, 'se_AssumeRoleWithSAMLCommand'),
		joe = F(async (e, t) => {
			let r = Li,
				n
			return (
				(n = ji({ ...dse(e, t), [Mi]: Use, [qi]: Fi })),
				Di(t, r, '/', void 0, n)
			)
		}, 'se_AssumeRoleWithWebIdentityCommand'),
		Uoe = F(async (e, t) => {
			let r = Li,
				n
			return (
				(n = ji({ ...use(e, t), [Mi]: Gse, [qi]: Fi })),
				Di(t, r, '/', void 0, n)
			)
		}, 'se_DecodeAuthorizationMessageCommand'),
		Goe = F(async (e, t) => {
			let r = Li,
				n
			return (
				(n = ji({ ...mse(e, t), [Mi]: zse, [qi]: Fi })),
				Di(t, r, '/', void 0, n)
			)
		}, 'se_GetAccessKeyInfoCommand'),
		zoe = F(async (e, t) => {
			let r = Li,
				n
			return (
				(n = ji({ ...fse(e, t), [Mi]: Hse, [qi]: Fi })),
				Di(t, r, '/', void 0, n)
			)
		}, 'se_GetCallerIdentityCommand'),
		Hoe = F(async (e, t) => {
			let r = Li,
				n
			return (
				(n = ji({ ...pse(e, t), [Mi]: $se, [qi]: Fi })),
				Di(t, r, '/', void 0, n)
			)
		}, 'se_GetFederationTokenCommand'),
		$oe = F(async (e, t) => {
			let r = Li,
				n
			return (
				(n = ji({ ...gse(e, t), [Mi]: Vse, [qi]: Fi })),
				Di(t, r, '/', void 0, n)
			)
		}, 'se_GetSessionTokenCommand'),
		Voe = F(async (e, t) => {
			if (e.statusCode >= 300) return Ni(e, t)
			let r = await (0, ti.parseXmlBody)(e.body, t),
				n = {}
			return (n = Cse(r.AssumeRoleResult, t)), { $metadata: Jt(e), ...n }
		}, 'de_AssumeRoleCommand'),
		Koe = F(async (e, t) => {
			if (e.statusCode >= 300) return Ni(e, t)
			let r = await (0, ti.parseXmlBody)(e.body, t),
				n = {}
			return (
				(n = Ese(r.AssumeRoleWithSAMLResult, t)), { $metadata: Jt(e), ...n }
			)
		}, 'de_AssumeRoleWithSAMLCommand'),
		Woe = F(async (e, t) => {
			if (e.statusCode >= 300) return Ni(e, t)
			let r = await (0, ti.parseXmlBody)(e.body, t),
				n = {}
			return (
				(n = bse(r.AssumeRoleWithWebIdentityResult, t)),
				{ $metadata: Jt(e), ...n }
			)
		}, 'de_AssumeRoleWithWebIdentityCommand'),
		Xoe = F(async (e, t) => {
			if (e.statusCode >= 300) return Ni(e, t)
			let r = await (0, ti.parseXmlBody)(e.body, t),
				n = {}
			return (
				(n = wse(r.DecodeAuthorizationMessageResult, t)),
				{ $metadata: Jt(e), ...n }
			)
		}, 'de_DecodeAuthorizationMessageCommand'),
		Yoe = F(async (e, t) => {
			if (e.statusCode >= 300) return Ni(e, t)
			let r = await (0, ti.parseXmlBody)(e.body, t),
				n = {}
			return (n = Ase(r.GetAccessKeyInfoResult, t)), { $metadata: Jt(e), ...n }
		}, 'de_GetAccessKeyInfoCommand'),
		Joe = F(async (e, t) => {
			if (e.statusCode >= 300) return Ni(e, t)
			let r = await (0, ti.parseXmlBody)(e.body, t),
				n = {}
			return (n = Ose(r.GetCallerIdentityResult, t)), { $metadata: Jt(e), ...n }
		}, 'de_GetCallerIdentityCommand'),
		Qoe = F(async (e, t) => {
			if (e.statusCode >= 300) return Ni(e, t)
			let r = await (0, ti.parseXmlBody)(e.body, t),
				n = {}
			return (
				(n = Rse(r.GetFederationTokenResult, t)), { $metadata: Jt(e), ...n }
			)
		}, 'de_GetFederationTokenCommand'),
		Zoe = F(async (e, t) => {
			if (e.statusCode >= 300) return Ni(e, t)
			let r = await (0, ti.parseXmlBody)(e.body, t),
				n = {}
			return (n = kse(r.GetSessionTokenResult, t)), { $metadata: Jt(e), ...n }
		}, 'de_GetSessionTokenCommand'),
		Ni = F(async (e, t) => {
			let r = { ...e, body: await (0, ti.parseXmlErrorBody)(e.body, t) },
				n = Kse(e, r.body)
			switch (n) {
				case 'ExpiredTokenException':
				case 'com.amazonaws.sts#ExpiredTokenException':
					throw await ese(r, t)
				case 'MalformedPolicyDocument':
				case 'com.amazonaws.sts#MalformedPolicyDocumentException':
					throw await ose(r, t)
				case 'PackedPolicyTooLarge':
				case 'com.amazonaws.sts#PackedPolicyTooLargeException':
					throw await sse(r, t)
				case 'RegionDisabledException':
				case 'com.amazonaws.sts#RegionDisabledException':
					throw await ase(r, t)
				case 'IDPRejectedClaim':
				case 'com.amazonaws.sts#IDPRejectedClaimException':
					throw await rse(r, t)
				case 'InvalidIdentityToken':
				case 'com.amazonaws.sts#InvalidIdentityTokenException':
					throw await ise(r, t)
				case 'IDPCommunicationError':
				case 'com.amazonaws.sts#IDPCommunicationErrorException':
					throw await tse(r, t)
				case 'InvalidAuthorizationMessageException':
				case 'com.amazonaws.sts#InvalidAuthorizationMessageException':
					throw await nse(r, t)
				default:
					let i = r.body
					return Mse({ output: e, parsedBody: i.Error, errorCode: n })
			}
		}, 'de_CommandError'),
		ese = F(async (e, t) => {
			let r = e.body,
				n = xse(r.Error, t),
				i = new _3({ $metadata: Jt(e), ...n })
			return (0, ie.decorateServiceException)(i, r)
		}, 'de_ExpiredTokenExceptionRes'),
		tse = F(async (e, t) => {
			let r = e.body,
				n = Ise(r.Error, t),
				i = new L3({ $metadata: Jt(e), ...n })
			return (0, ie.decorateServiceException)(i, r)
		}, 'de_IDPCommunicationErrorExceptionRes'),
		rse = F(async (e, t) => {
			let r = e.body,
				n = Tse(r.Error, t),
				i = new k3({ $metadata: Jt(e), ...n })
			return (0, ie.decorateServiceException)(i, r)
		}, 'de_IDPRejectedClaimExceptionRes'),
		nse = F(async (e, t) => {
			let r = e.body,
				n = Bse(r.Error, t),
				i = new q3({ $metadata: Jt(e), ...n })
			return (0, ie.decorateServiceException)(i, r)
		}, 'de_InvalidAuthorizationMessageExceptionRes'),
		ise = F(async (e, t) => {
			let r = e.body,
				n = Nse(r.Error, t),
				i = new B3({ $metadata: Jt(e), ...n })
			return (0, ie.decorateServiceException)(i, r)
		}, 'de_InvalidIdentityTokenExceptionRes'),
		ose = F(async (e, t) => {
			let r = e.body,
				n = Dse(r.Error, t),
				i = new C3({ $metadata: Jt(e), ...n })
			return (0, ie.decorateServiceException)(i, r)
		}, 'de_MalformedPolicyDocumentExceptionRes'),
		sse = F(async (e, t) => {
			let r = e.body,
				n = Lse(r.Error, t),
				i = new w3({ $metadata: Jt(e), ...n })
			return (0, ie.decorateServiceException)(i, r)
		}, 'de_PackedPolicyTooLargeExceptionRes'),
		ase = F(async (e, t) => {
			let r = e.body,
				n = Fse(r.Error, t),
				i = new A3({ $metadata: Jt(e), ...n })
			return (0, ie.decorateServiceException)(i, r)
		}, 'de_RegionDisabledExceptionRes'),
		cse = F((e, t) => {
			var r, n, i, o
			let s = {}
			if (
				(e[ei] != null && (s[ei] = e[ei]),
				e[ia] != null && (s[ia] = e[ia]),
				e[Gr] != null)
			) {
				let c = Km(e[Gr], t)
				;((r = e[Gr]) == null ? void 0 : r.length) === 0 && (s.PolicyArns = []),
					Object.entries(c).forEach(([l, u]) => {
						let m = `PolicyArns.${l}`
						s[m] = u
					})
			}
			if (
				(e[Ur] != null && (s[Ur] = e[Ur]),
				e[lr] != null && (s[lr] = e[lr]),
				e[sa] != null)
			) {
				let c = K3(e[sa], t)
				;((n = e[sa]) == null ? void 0 : n.length) === 0 && (s.Tags = []),
					Object.entries(c).forEach(([l, u]) => {
						let m = `Tags.${l}`
						s[m] = u
					})
			}
			if (e[K_] != null) {
				let c = Sse(e[K_], t)
				;((i = e[K_]) == null ? void 0 : i.length) === 0 &&
					(s.TransitiveTagKeys = []),
					Object.entries(c).forEach(([l, u]) => {
						let m = `TransitiveTagKeys.${l}`
						s[m] = u
					})
			}
			if (
				(e[O_] != null && (s[O_] = e[O_]),
				e[oa] != null && (s[oa] = e[oa]),
				e[aa] != null && (s[aa] = e[aa]),
				e[Hr] != null && (s[Hr] = e[Hr]),
				e[M_] != null)
			) {
				let c = _se(e[M_], t)
				;((o = e[M_]) == null ? void 0 : o.length) === 0 &&
					(s.ProvidedContexts = []),
					Object.entries(c).forEach(([l, u]) => {
						let m = `ProvidedContexts.${l}`
						s[m] = u
					})
			}
			return s
		}, 'se_AssumeRoleRequest'),
		lse = F((e, t) => {
			var r
			let n = {}
			if (
				(e[ei] != null && (n[ei] = e[ei]),
				e[L_] != null && (n[L_] = e[L_]),
				e[z_] != null && (n[z_] = e[z_]),
				e[Gr] != null)
			) {
				let i = Km(e[Gr], t)
				;((r = e[Gr]) == null ? void 0 : r.length) === 0 && (n.PolicyArns = []),
					Object.entries(i).forEach(([o, s]) => {
						let c = `PolicyArns.${o}`
						n[c] = s
					})
			}
			return (
				e[Ur] != null && (n[Ur] = e[Ur]), e[lr] != null && (n[lr] = e[lr]), n
			)
		}, 'se_AssumeRoleWithSAMLRequest'),
		dse = F((e, t) => {
			var r
			let n = {}
			if (
				(e[ei] != null && (n[ei] = e[ei]),
				e[ia] != null && (n[ia] = e[ia]),
				e[Y_] != null && (n[Y_] = e[Y_]),
				e[q_] != null && (n[q_] = e[q_]),
				e[Gr] != null)
			) {
				let i = Km(e[Gr], t)
				;((r = e[Gr]) == null ? void 0 : r.length) === 0 && (n.PolicyArns = []),
					Object.entries(i).forEach(([o, s]) => {
						let c = `PolicyArns.${o}`
						n[c] = s
					})
			}
			return (
				e[Ur] != null && (n[Ur] = e[Ur]), e[lr] != null && (n[lr] = e[lr]), n
			)
		}, 'se_AssumeRoleWithWebIdentityRequest'),
		use = F((e, t) => {
			let r = {}
			return e[R_] != null && (r[R_] = e[R_]), r
		}, 'se_DecodeAuthorizationMessageRequest'),
		mse = F((e, t) => {
			let r = {}
			return e[ta] != null && (r[ta] = e[ta]), r
		}, 'se_GetAccessKeyInfoRequest'),
		fse = F((e, t) => ({}), 'se_GetCallerIdentityRequest'),
		pse = F((e, t) => {
			var r, n
			let i = {}
			if (
				(e[N_] != null && (i[N_] = e[N_]),
				e[Ur] != null && (i[Ur] = e[Ur]),
				e[Gr] != null)
			) {
				let o = Km(e[Gr], t)
				;((r = e[Gr]) == null ? void 0 : r.length) === 0 && (i.PolicyArns = []),
					Object.entries(o).forEach(([s, c]) => {
						let l = `PolicyArns.${s}`
						i[l] = c
					})
			}
			if ((e[lr] != null && (i[lr] = e[lr]), e[sa] != null)) {
				let o = K3(e[sa], t)
				;((n = e[sa]) == null ? void 0 : n.length) === 0 && (i.Tags = []),
					Object.entries(o).forEach(([s, c]) => {
						let l = `Tags.${s}`
						i[l] = c
					})
			}
			return i
		}, 'se_GetFederationTokenRequest'),
		gse = F((e, t) => {
			let r = {}
			return (
				e[lr] != null && (r[lr] = e[lr]),
				e[oa] != null && (r[oa] = e[oa]),
				e[aa] != null && (r[aa] = e[aa]),
				r
			)
		}, 'se_GetSessionTokenRequest'),
		Km = F((e, t) => {
			let r = {},
				n = 1
			for (let i of e) {
				if (i === null) continue
				let o = vse(i, t)
				Object.entries(o).forEach(([s, c]) => {
					r[`member.${n}.${s}`] = c
				}),
					n++
			}
			return r
		}, 'se_policyDescriptorListType'),
		vse = F((e, t) => {
			let r = {}
			return e[J_] != null && (r[J_] = e[J_]), r
		}, 'se_PolicyDescriptorType'),
		hse = F((e, t) => {
			let r = {}
			return (
				e[F_] != null && (r[F_] = e[F_]), e[x_] != null && (r[x_] = e[x_]), r
			)
		}, 'se_ProvidedContext'),
		_se = F((e, t) => {
			let r = {},
				n = 1
			for (let i of e) {
				if (i === null) continue
				let o = hse(i, t)
				Object.entries(o).forEach(([s, c]) => {
					r[`member.${n}.${s}`] = c
				}),
					n++
			}
			return r
		}, 'se_ProvidedContextsListType'),
		yse = F((e, t) => {
			let r = {}
			return (
				e[B_] != null && (r[B_] = e[B_]), e[X_] != null && (r[X_] = e[X_]), r
			)
		}, 'se_Tag'),
		Sse = F((e, t) => {
			let r = {},
				n = 1
			for (let i of e) i !== null && ((r[`member.${n}`] = i), n++)
			return r
		}, 'se_tagKeyListType'),
		K3 = F((e, t) => {
			let r = {},
				n = 1
			for (let i of e) {
				if (i === null) continue
				let o = yse(i, t)
				Object.entries(o).forEach(([s, c]) => {
					r[`member.${n}.${s}`] = c
				}),
					n++
			}
			return r
		}, 'se_tagListType'),
		ey = F((e, t) => {
			let r = {}
			return (
				e[w_] != null && (r[w_] = (0, ie.expectString)(e[w_])),
				e[Zn] != null && (r[Zn] = (0, ie.expectString)(e[Zn])),
				r
			)
		}, 'de_AssumedRoleUser'),
		Cse = F((e, t) => {
			let r = {}
			return (
				e[cr] != null && (r[cr] = Cl(e[cr], t)),
				e[Qn] != null && (r[Qn] = ey(e[Qn], t)),
				e[zr] != null && (r[zr] = (0, ie.strictParseInt32)(e[zr])),
				e[Hr] != null && (r[Hr] = (0, ie.expectString)(e[Hr])),
				r
			)
		}, 'de_AssumeRoleResponse'),
		Ese = F((e, t) => {
			let r = {}
			return (
				e[cr] != null && (r[cr] = Cl(e[cr], t)),
				e[Qn] != null && (r[Qn] = ey(e[Qn], t)),
				e[zr] != null && (r[zr] = (0, ie.strictParseInt32)(e[zr])),
				e[U_] != null && (r[U_] = (0, ie.expectString)(e[U_])),
				e[$_] != null && (r[$_] = (0, ie.expectString)(e[$_])),
				e[T_] != null && (r[T_] = (0, ie.expectString)(e[T_])),
				e[na] != null && (r[na] = (0, ie.expectString)(e[na])),
				e[D_] != null && (r[D_] = (0, ie.expectString)(e[D_])),
				e[Hr] != null && (r[Hr] = (0, ie.expectString)(e[Hr])),
				r
			)
		}, 'de_AssumeRoleWithSAMLResponse'),
		bse = F((e, t) => {
			let r = {}
			return (
				e[cr] != null && (r[cr] = Cl(e[cr], t)),
				e[H_] != null && (r[H_] = (0, ie.expectString)(e[H_])),
				e[Qn] != null && (r[Qn] = ey(e[Qn], t)),
				e[zr] != null && (r[zr] = (0, ie.strictParseInt32)(e[zr])),
				e[j_] != null && (r[j_] = (0, ie.expectString)(e[j_])),
				e[na] != null && (r[na] = (0, ie.expectString)(e[na])),
				e[Hr] != null && (r[Hr] = (0, ie.expectString)(e[Hr])),
				r
			)
		}, 'de_AssumeRoleWithWebIdentityResponse'),
		Cl = F((e, t) => {
			let r = {}
			return (
				e[ta] != null && (r[ta] = (0, ie.expectString)(e[ta])),
				e[G_] != null && (r[G_] = (0, ie.expectString)(e[G_])),
				e[V_] != null && (r[V_] = (0, ie.expectString)(e[V_])),
				e[A_] != null &&
					(r[A_] = (0, ie.expectNonNull)(
						(0, ie.parseRfc3339DateTimeWithOffset)(e[A_]),
					)),
				r
			)
		}, 'de_Credentials'),
		wse = F((e, t) => {
			let r = {}
			return e[P_] != null && (r[P_] = (0, ie.expectString)(e[P_])), r
		}, 'de_DecodeAuthorizationMessageResponse'),
		xse = F((e, t) => {
			let r = {}
			return e[nt] != null && (r[nt] = (0, ie.expectString)(e[nt])), r
		}, 'de_ExpiredTokenException'),
		Pse = F((e, t) => {
			let r = {}
			return (
				e[I_] != null && (r[I_] = (0, ie.expectString)(e[I_])),
				e[Zn] != null && (r[Zn] = (0, ie.expectString)(e[Zn])),
				r
			)
		}, 'de_FederatedUser'),
		Ase = F((e, t) => {
			let r = {}
			return e[ra] != null && (r[ra] = (0, ie.expectString)(e[ra])), r
		}, 'de_GetAccessKeyInfoResponse'),
		Ose = F((e, t) => {
			let r = {}
			return (
				e[W_] != null && (r[W_] = (0, ie.expectString)(e[W_])),
				e[ra] != null && (r[ra] = (0, ie.expectString)(e[ra])),
				e[Zn] != null && (r[Zn] = (0, ie.expectString)(e[Zn])),
				r
			)
		}, 'de_GetCallerIdentityResponse'),
		Rse = F((e, t) => {
			let r = {}
			return (
				e[cr] != null && (r[cr] = Cl(e[cr], t)),
				e[k_] != null && (r[k_] = Pse(e[k_], t)),
				e[zr] != null && (r[zr] = (0, ie.strictParseInt32)(e[zr])),
				r
			)
		}, 'de_GetFederationTokenResponse'),
		kse = F((e, t) => {
			let r = {}
			return e[cr] != null && (r[cr] = Cl(e[cr], t)), r
		}, 'de_GetSessionTokenResponse'),
		Ise = F((e, t) => {
			let r = {}
			return e[nt] != null && (r[nt] = (0, ie.expectString)(e[nt])), r
		}, 'de_IDPCommunicationErrorException'),
		Tse = F((e, t) => {
			let r = {}
			return e[nt] != null && (r[nt] = (0, ie.expectString)(e[nt])), r
		}, 'de_IDPRejectedClaimException'),
		Bse = F((e, t) => {
			let r = {}
			return e[nt] != null && (r[nt] = (0, ie.expectString)(e[nt])), r
		}, 'de_InvalidAuthorizationMessageException'),
		Nse = F((e, t) => {
			let r = {}
			return e[nt] != null && (r[nt] = (0, ie.expectString)(e[nt])), r
		}, 'de_InvalidIdentityTokenException'),
		Dse = F((e, t) => {
			let r = {}
			return e[nt] != null && (r[nt] = (0, ie.expectString)(e[nt])), r
		}, 'de_MalformedPolicyDocumentException'),
		Lse = F((e, t) => {
			let r = {}
			return e[nt] != null && (r[nt] = (0, ie.expectString)(e[nt])), r
		}, 'de_PackedPolicyTooLargeException'),
		Fse = F((e, t) => {
			let r = {}
			return e[nt] != null && (r[nt] = (0, ie.expectString)(e[nt])), r
		}, 'de_RegionDisabledException'),
		Jt = F(
			(e) => ({
				httpStatusCode: e.statusCode,
				requestId:
					e.headers['x-amzn-requestid'] ??
					e.headers['x-amzn-request-id'] ??
					e.headers['x-amz-request-id'],
				extendedRequestId: e.headers['x-amz-id-2'],
				cfId: e.headers['x-amz-cf-id'],
			}),
			'deserializeMetadata',
		),
		Mse = (0, ie.withBaseException)(Tn),
		Di = F(async (e, t, r, n, i) => {
			let {
					hostname: o,
					protocol: s = 'https',
					port: c,
					path: l,
				} = await e.endpoint(),
				u = {
					protocol: s,
					hostname: o,
					port: c,
					method: 'POST',
					path: l.endsWith('/') ? l.slice(0, -1) + r : l + r,
					headers: t,
				}
			return (
				n !== void 0 && (u.hostname = n),
				i !== void 0 && (u.body = i),
				new Foe.HttpRequest(u)
			)
		}, 'buildHttpRpcRequest'),
		Li = { 'content-type': 'application/x-www-form-urlencoded' },
		Fi = '2011-06-15',
		Mi = 'Action',
		ta = 'AccessKeyId',
		qse = 'AssumeRole',
		w_ = 'AssumedRoleId',
		Qn = 'AssumedRoleUser',
		jse = 'AssumeRoleWithSAML',
		Use = 'AssumeRoleWithWebIdentity',
		ra = 'Account',
		Zn = 'Arn',
		na = 'Audience',
		cr = 'Credentials',
		x_ = 'ContextAssertion',
		Gse = 'DecodeAuthorizationMessage',
		P_ = 'DecodedMessage',
		lr = 'DurationSeconds',
		A_ = 'Expiration',
		O_ = 'ExternalId',
		R_ = 'EncodedMessage',
		k_ = 'FederatedUser',
		I_ = 'FederatedUserId',
		zse = 'GetAccessKeyInfo',
		Hse = 'GetCallerIdentity',
		$se = 'GetFederationToken',
		Vse = 'GetSessionToken',
		T_ = 'Issuer',
		B_ = 'Key',
		N_ = 'Name',
		D_ = 'NameQualifier',
		Ur = 'Policy',
		Gr = 'PolicyArns',
		L_ = 'PrincipalArn',
		F_ = 'ProviderArn',
		M_ = 'ProvidedContexts',
		q_ = 'ProviderId',
		zr = 'PackedPolicySize',
		j_ = 'Provider',
		ei = 'RoleArn',
		ia = 'RoleSessionName',
		U_ = 'Subject',
		G_ = 'SecretAccessKey',
		z_ = 'SAMLAssertion',
		H_ = 'SubjectFromWebIdentityToken',
		Hr = 'SourceIdentity',
		oa = 'SerialNumber',
		$_ = 'SubjectType',
		V_ = 'SessionToken',
		sa = 'Tags',
		aa = 'TokenCode',
		K_ = 'TransitiveTagKeys',
		W_ = 'UserId',
		qi = 'Version',
		X_ = 'Value',
		Y_ = 'WebIdentityToken',
		J_ = 'arn',
		nt = 'message',
		ji = F(
			(e) =>
				Object.entries(e)
					.map(
						([t, r]) =>
							(0, ie.extendedEncodeURIComponent)(t) +
							'=' +
							(0, ie.extendedEncodeURIComponent)(r),
					)
					.join('&'),
			'buildFormUrlencodedString',
		),
		Kse = F((e, t) => {
			var r
			if (((r = t.Error) == null ? void 0 : r.Code) !== void 0)
				return t.Error.Code
			if (e.statusCode == 404) return 'NotFound'
		}, 'loadQueryErrorCode'),
		W3 = class extends ie.Command.classBuilder()
			.ep({ ...Loe.commonParams })
			.m(function (t, r, n, i) {
				return [
					(0, Bi.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, Ti.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSecurityTokenServiceV20110615', 'AssumeRole', {})
			.n('STSClient', 'AssumeRoleCommand')
			.f(void 0, j3)
			.ser(Moe)
			.de(Voe)
			.build() {}
	F(W3, 'AssumeRoleCommand')
	var ty = W3,
		Wse = un(),
		X3 = class extends ie.Command.classBuilder()
			.ep({ ...Wse.commonParams })
			.m(function (t, r, n, i) {
				return [
					(0, Bi.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, Ti.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSecurityTokenServiceV20110615', 'AssumeRoleWithSAML', {})
			.n('STSClient', 'AssumeRoleWithSAMLCommand')
			.f(U3, G3)
			.ser(qoe)
			.de(Koe)
			.build() {}
	F(X3, 'AssumeRoleWithSAMLCommand')
	var Y3 = X3,
		Xse = un(),
		J3 = class extends ie.Command.classBuilder()
			.ep({ ...Xse.commonParams })
			.m(function (t, r, n, i) {
				return [
					(0, Bi.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, Ti.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSecurityTokenServiceV20110615', 'AssumeRoleWithWebIdentity', {})
			.n('STSClient', 'AssumeRoleWithWebIdentityCommand')
			.f(z3, H3)
			.ser(joe)
			.de(Woe)
			.build() {}
	F(J3, 'AssumeRoleWithWebIdentityCommand')
	var ry = J3,
		Yse = un(),
		Q3 = class extends ie.Command.classBuilder()
			.ep({ ...Yse.commonParams })
			.m(function (t, r, n, i) {
				return [
					(0, Bi.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, Ti.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSecurityTokenServiceV20110615', 'DecodeAuthorizationMessage', {})
			.n('STSClient', 'DecodeAuthorizationMessageCommand')
			.f(void 0, void 0)
			.ser(Uoe)
			.de(Xoe)
			.build() {}
	F(Q3, 'DecodeAuthorizationMessageCommand')
	var Z3 = Q3,
		Jse = un(),
		eF = class extends ie.Command.classBuilder()
			.ep({ ...Jse.commonParams })
			.m(function (t, r, n, i) {
				return [
					(0, Bi.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, Ti.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSecurityTokenServiceV20110615', 'GetAccessKeyInfo', {})
			.n('STSClient', 'GetAccessKeyInfoCommand')
			.f(void 0, void 0)
			.ser(Goe)
			.de(Yoe)
			.build() {}
	F(eF, 'GetAccessKeyInfoCommand')
	var tF = eF,
		Qse = un(),
		rF = class extends ie.Command.classBuilder()
			.ep({ ...Qse.commonParams })
			.m(function (t, r, n, i) {
				return [
					(0, Bi.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, Ti.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSecurityTokenServiceV20110615', 'GetCallerIdentity', {})
			.n('STSClient', 'GetCallerIdentityCommand')
			.f(void 0, void 0)
			.ser(zoe)
			.de(Joe)
			.build() {}
	F(rF, 'GetCallerIdentityCommand')
	var nF = rF,
		Zse = un(),
		iF = class extends ie.Command.classBuilder()
			.ep({ ...Zse.commonParams })
			.m(function (t, r, n, i) {
				return [
					(0, Bi.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, Ti.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSecurityTokenServiceV20110615', 'GetFederationToken', {})
			.n('STSClient', 'GetFederationTokenCommand')
			.f(void 0, $3)
			.ser(Hoe)
			.de(Qoe)
			.build() {}
	F(iF, 'GetFederationTokenCommand')
	var oF = iF,
		eae = un(),
		sF = class extends ie.Command.classBuilder()
			.ep({ ...eae.commonParams })
			.m(function (t, r, n, i) {
				return [
					(0, Bi.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, Ti.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AWSSecurityTokenServiceV20110615', 'GetSessionToken', {})
			.n('STSClient', 'GetSessionTokenCommand')
			.f(void 0, V3)
			.ser($oe)
			.de(Zoe)
			.build() {}
	F(sF, 'GetSessionTokenCommand')
	var aF = sF,
		tae = yl(),
		rae = {
			AssumeRoleCommand: ty,
			AssumeRoleWithSAMLCommand: Y3,
			AssumeRoleWithWebIdentityCommand: ry,
			DecodeAuthorizationMessageCommand: Z3,
			GetAccessKeyInfoCommand: tF,
			GetCallerIdentityCommand: nF,
			GetFederationTokenCommand: oF,
			GetSessionTokenCommand: aF,
		},
		cF = class extends tae.STSClient {}
	F(cF, 'STS')
	var lF = cF
	;(0, ie.createAggregatedClient)(rae, lF)
	var nae = un(),
		f3 = 'us-east-1',
		dF = F((e) => {
			if (typeof e?.Arn == 'string') {
				let t = e.Arn.split(':')
				if (t.length > 4 && t[4] !== '') return t[4]
			}
		}, 'getAccountIdFromAssumedRoleUser'),
		uF = F(async (e, t, r) => {
			var n
			let i = typeof e == 'function' ? await e() : e,
				o = typeof t == 'function' ? await t() : t
			return (
				(n = r?.debug) == null ||
					n.call(
						r,
						'@aws-sdk/client-sts::resolveRegion',
						'accepting first of:',
						`${i} (provider)`,
						`${o} (parent client)`,
						`${f3} (STS default)`,
					),
				i ?? o ?? f3
			)
		}, 'resolveRegion'),
		iae = F((e, t) => {
			let r, n
			return async (i, o) => {
				var s, c, l
				if (((n = i), !r)) {
					let {
							logger: p = (s = e?.parentClientConfig) == null
								? void 0
								: s.logger,
							region: g,
							requestHandler: v = (c = e?.parentClientConfig) == null
								? void 0
								: c.requestHandler,
							credentialProviderLogger: _,
						} = e,
						y = await uF(
							g,
							(l = e?.parentClientConfig) == null ? void 0 : l.region,
							_,
						),
						P = !mF(v)
					r = new t({
						credentialDefaultProvider: () => async () => n,
						region: y,
						requestHandler: P ? v : void 0,
						logger: p,
					})
				}
				let { Credentials: u, AssumedRoleUser: m } = await r.send(new ty(o))
				if (!u || !u.AccessKeyId || !u.SecretAccessKey)
					throw new Error(
						`Invalid response from STS.assumeRole call with role ${o.RoleArn}`,
					)
				let f = dF(m)
				return {
					accessKeyId: u.AccessKeyId,
					secretAccessKey: u.SecretAccessKey,
					sessionToken: u.SessionToken,
					expiration: u.Expiration,
					...(u.CredentialScope && { credentialScope: u.CredentialScope }),
					...(f && { accountId: f }),
				}
			}
		}, 'getDefaultRoleAssumer'),
		oae = F((e, t) => {
			let r
			return async (n) => {
				var i, o, s
				if (!r) {
					let {
							logger: m = (i = e?.parentClientConfig) == null
								? void 0
								: i.logger,
							region: f,
							requestHandler: p = (o = e?.parentClientConfig) == null
								? void 0
								: o.requestHandler,
							credentialProviderLogger: g,
						} = e,
						v = await uF(
							f,
							(s = e?.parentClientConfig) == null ? void 0 : s.region,
							g,
						),
						_ = !mF(p)
					r = new t({ region: v, requestHandler: _ ? p : void 0, logger: m })
				}
				let { Credentials: c, AssumedRoleUser: l } = await r.send(new ry(n))
				if (!c || !c.AccessKeyId || !c.SecretAccessKey)
					throw new Error(
						`Invalid response from STS.assumeRoleWithWebIdentity call with role ${n.RoleArn}`,
					)
				let u = dF(l)
				return {
					accessKeyId: c.AccessKeyId,
					secretAccessKey: c.SecretAccessKey,
					sessionToken: c.SessionToken,
					expiration: c.Expiration,
					...(c.CredentialScope && { credentialScope: c.CredentialScope }),
					...(u && { accountId: u }),
				}
			}
		}, 'getDefaultRoleAssumerWithWebIdentity'),
		mF = F((e) => {
			var t
			return ((t = e?.metadata) == null ? void 0 : t.handlerProtocol) === 'h2'
		}, 'isH2'),
		fF = yl(),
		pF = F((e, t) => {
			var r
			return t
				? ((r = class extends e {
						constructor(n) {
							super(n)
							for (let i of t) this.middlewareStack.use(i)
						}
					}),
					F(r, 'CustomizableSTSClient'),
					r)
				: e
		}, 'getCustomizableStsClientCtor'),
		gF = F((e = {}, t) => iae(e, pF(fF.STSClient, t)), 'getDefaultRoleAssumer'),
		vF = F(
			(e = {}, t) => oae(e, pF(fF.STSClient, t)),
			'getDefaultRoleAssumerWithWebIdentity',
		),
		sae = F(
			(e) => (t) =>
				e({ roleAssumer: gF(t), roleAssumerWithWebIdentity: vF(t), ...t }),
			'decorateDefaultCredentialProvider',
		)
})
var ay = E((OTe, yF) => {
	'use strict'
	var Wm = Object.defineProperty,
		aae = Object.getOwnPropertyDescriptor,
		cae = Object.getOwnPropertyNames,
		lae = Object.prototype.hasOwnProperty,
		sy = (e, t) => Wm(e, 'name', { value: t, configurable: !0 }),
		dae = (e, t) => {
			for (var r in t) Wm(e, r, { get: t[r], enumerable: !0 })
		},
		uae = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of cae(t))
					!lae.call(e, i) &&
						i !== r &&
						Wm(e, i, {
							get: () => t[i],
							enumerable: !(n = aae(t, i)) || n.enumerable,
						})
			return e
		},
		mae = (e) => uae(Wm({}, '__esModule', { value: !0 }), e),
		_F = {}
	dae(_F, { fromProcess: () => hae })
	yF.exports = mae(_F)
	var hF = hi(),
		oy = nr(),
		fae = require('child_process'),
		pae = require('util'),
		gae = sy((e, t, r) => {
			var n
			if (t.Version !== 1)
				throw Error(`Profile ${e} credential_process did not return Version 1.`)
			if (t.AccessKeyId === void 0 || t.SecretAccessKey === void 0)
				throw Error(
					`Profile ${e} credential_process returned invalid credentials.`,
				)
			if (t.Expiration) {
				let o = new Date()
				if (new Date(t.Expiration) < o)
					throw Error(
						`Profile ${e} credential_process returned expired credentials.`,
					)
			}
			let i = t.AccountId
			return (
				!i &&
					(n = r?.[e]) != null &&
					n.aws_account_id &&
					(i = r[e].aws_account_id),
				{
					accessKeyId: t.AccessKeyId,
					secretAccessKey: t.SecretAccessKey,
					...(t.SessionToken && { sessionToken: t.SessionToken }),
					...(t.Expiration && { expiration: new Date(t.Expiration) }),
					...(t.CredentialScope && { credentialScope: t.CredentialScope }),
					...(i && { accountId: i }),
				}
			)
		}, 'getValidatedProcessCredentials'),
		vae = sy(async (e, t, r) => {
			let n = t[e]
			if (t[e]) {
				let i = n.credential_process
				if (i !== void 0) {
					let o = (0, pae.promisify)(fae.exec)
					try {
						let { stdout: s } = await o(i),
							c
						try {
							c = JSON.parse(s.trim())
						} catch {
							throw Error(
								`Profile ${e} credential_process returned invalid JSON.`,
							)
						}
						return gae(e, c, t)
					} catch (s) {
						throw new oy.CredentialsProviderError(s.message, { logger: r })
					}
				} else
					throw new oy.CredentialsProviderError(
						`Profile ${e} did not contain credential_process.`,
						{ logger: r },
					)
			} else
				throw new oy.CredentialsProviderError(
					`Profile ${e} could not be found in shared credentials file.`,
					{ logger: r },
				)
		}, 'resolveProcessCredentials'),
		hae = sy(
			(e = {}) =>
				async () => {
					var t
					;(t = e.logger) == null ||
						t.debug('@aws-sdk/credential-provider-process - fromProcess')
					let r = await (0, hF.parseKnownFiles)(e)
					return vae((0, hF.getProfileName)(e), r, e.logger)
				},
			'fromProcess',
		)
})
var cy = E((Bn) => {
	'use strict'
	var _ae =
			(Bn && Bn.__createBinding) ||
			(Object.create
				? function (e, t, r, n) {
						n === void 0 && (n = r)
						var i = Object.getOwnPropertyDescriptor(t, r)
						;(!i ||
							('get' in i ? !t.__esModule : i.writable || i.configurable)) &&
							(i = {
								enumerable: !0,
								get: function () {
									return t[r]
								},
							}),
							Object.defineProperty(e, n, i)
					}
				: function (e, t, r, n) {
						n === void 0 && (n = r), (e[n] = t[r])
					}),
		yae =
			(Bn && Bn.__setModuleDefault) ||
			(Object.create
				? function (e, t) {
						Object.defineProperty(e, 'default', { enumerable: !0, value: t })
					}
				: function (e, t) {
						e.default = t
					}),
		Sae =
			(Bn && Bn.__importStar) ||
			function (e) {
				if (e && e.__esModule) return e
				var t = {}
				if (e != null)
					for (var r in e)
						r !== 'default' &&
							Object.prototype.hasOwnProperty.call(e, r) &&
							_ae(t, e, r)
				return yae(t, e), t
			}
	Object.defineProperty(Bn, '__esModule', { value: !0 })
	Bn.fromWebToken = void 0
	var Cae = (e) => async () => {
		e.logger?.debug('@aws-sdk/credential-provider-web-identity - fromWebToken')
		let {
				roleArn: t,
				roleSessionName: r,
				webIdentityToken: n,
				providerId: i,
				policyArns: o,
				policy: s,
				durationSeconds: c,
			} = e,
			{ roleAssumerWithWebIdentity: l } = e
		if (!l) {
			let { getDefaultRoleAssumerWithWebIdentity: u } =
				await Promise.resolve().then(() => Sae(iy()))
			l = u(
				{
					...e.clientConfig,
					credentialProviderLogger: e.logger,
					parentClientConfig: e.parentClientConfig,
				},
				e.clientPlugins,
			)
		}
		return l({
			RoleArn: t,
			RoleSessionName: r ?? `aws-sdk-js-session-${Date.now()}`,
			WebIdentityToken: n,
			ProviderId: i,
			PolicyArns: o,
			Policy: s,
			DurationSeconds: c,
		})
	}
	Bn.fromWebToken = Cae
})
var SF = E((Xm) => {
	'use strict'
	Object.defineProperty(Xm, '__esModule', { value: !0 })
	Xm.fromTokenFile = void 0
	var Eae = nr(),
		bae = require('fs'),
		wae = cy(),
		xae = 'AWS_WEB_IDENTITY_TOKEN_FILE',
		Pae = 'AWS_ROLE_ARN',
		Aae = 'AWS_ROLE_SESSION_NAME',
		Oae =
			(e = {}) =>
			async () => {
				e.logger?.debug(
					'@aws-sdk/credential-provider-web-identity - fromTokenFile',
				)
				let t = e?.webIdentityTokenFile ?? process.env[xae],
					r = e?.roleArn ?? process.env[Pae],
					n = e?.roleSessionName ?? process.env[Aae]
				if (!t || !r)
					throw new Eae.CredentialsProviderError(
						'Web identity configuration not specified',
						{ logger: e.logger },
					)
				return (0, wae.fromWebToken)({
					...e,
					webIdentityToken: (0, bae.readFileSync)(t, { encoding: 'ascii' }),
					roleArn: r,
					roleSessionName: n,
				})()
			}
	Xm.fromTokenFile = Oae
})
var uy = E((ITe, Ym) => {
	'use strict'
	var CF = Object.defineProperty,
		Rae = Object.getOwnPropertyDescriptor,
		kae = Object.getOwnPropertyNames,
		Iae = Object.prototype.hasOwnProperty,
		ly = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of kae(t))
					!Iae.call(e, i) &&
						i !== r &&
						CF(e, i, {
							get: () => t[i],
							enumerable: !(n = Rae(t, i)) || n.enumerable,
						})
			return e
		},
		EF = (e, t, r) => (ly(e, t, 'default'), r && ly(r, t, 'default')),
		Tae = (e) => ly(CF({}, '__esModule', { value: !0 }), e),
		dy = {}
	Ym.exports = Tae(dy)
	EF(dy, SF(), Ym.exports)
	EF(dy, cy(), Ym.exports)
})
var RF = E((TTe, OF) => {
	'use strict'
	var Bae = Object.create,
		bl = Object.defineProperty,
		Nae = Object.getOwnPropertyDescriptor,
		Dae = Object.getOwnPropertyNames,
		Lae = Object.getPrototypeOf,
		Fae = Object.prototype.hasOwnProperty,
		dr = (e, t) => bl(e, 'name', { value: t, configurable: !0 }),
		Mae = (e, t) => {
			for (var r in t) bl(e, r, { get: t[r], enumerable: !0 })
		},
		xF = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Dae(t))
					!Fae.call(e, i) &&
						i !== r &&
						bl(e, i, {
							get: () => t[i],
							enumerable: !(n = Nae(t, i)) || n.enumerable,
						})
			return e
		},
		Ui = (e, t, r) => (
			(r = e != null ? Bae(Lae(e)) : {}),
			xF(
				t || !e || !e.__esModule
					? bl(r, 'default', { value: e, enumerable: !0 })
					: r,
				e,
			)
		),
		qae = (e) => xF(bl({}, '__esModule', { value: !0 }), e),
		PF = {}
	Mae(PF, { fromIni: () => Jae })
	OF.exports = qae(PF)
	var my = hi(),
		El = nr(),
		jae = dr((e, t, r) => {
			let n = {
				EcsContainer: async (i) => {
					let { fromHttp: o } = await Promise.resolve().then(() => Ui(Zh())),
						{ fromContainerMetadata: s } = await Promise.resolve().then(() =>
							Ui(rl()),
						)
					return (
						r?.debug(
							'@aws-sdk/credential-provider-ini - credential_source is EcsContainer',
						),
						(0, El.chain)(o(i ?? {}), s(i))
					)
				},
				Ec2InstanceMetadata: async (i) => {
					r?.debug(
						'@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata',
					)
					let { fromInstanceMetadata: o } = await Promise.resolve().then(() =>
						Ui(rl()),
					)
					return o(i)
				},
				Environment: async (i) => {
					r?.debug(
						'@aws-sdk/credential-provider-ini - credential_source is Environment',
					)
					let { fromEnv: o } = await Promise.resolve().then(() => Ui(Vh()))
					return o(i)
				},
			}
			if (e in n) return n[e]
			throw new El.CredentialsProviderError(
				`Unsupported credential source in profile ${t}. Got ${e}, expected EcsContainer or Ec2InstanceMetadata or Environment.`,
				{ logger: r },
			)
		}, 'resolveCredentialSource'),
		Uae = dr(
			(e, { profile: t = 'default', logger: r } = {}) =>
				!!e &&
				typeof e == 'object' &&
				typeof e.role_arn == 'string' &&
				['undefined', 'string'].indexOf(typeof e.role_session_name) > -1 &&
				['undefined', 'string'].indexOf(typeof e.external_id) > -1 &&
				['undefined', 'string'].indexOf(typeof e.mfa_serial) > -1 &&
				(Gae(e, { profile: t, logger: r }) ||
					zae(e, { profile: t, logger: r })),
			'isAssumeRoleProfile',
		),
		Gae = dr((e, { profile: t, logger: r }) => {
			var n
			let i =
				typeof e.source_profile == 'string' && typeof e.credential_source > 'u'
			return (
				i &&
					((n = r?.debug) == null ||
						n.call(
							r,
							`    ${t} isAssumeRoleWithSourceProfile source_profile=${e.source_profile}`,
						)),
				i
			)
		}, 'isAssumeRoleWithSourceProfile'),
		zae = dr((e, { profile: t, logger: r }) => {
			var n
			let i =
				typeof e.credential_source == 'string' && typeof e.source_profile > 'u'
			return (
				i &&
					((n = r?.debug) == null ||
						n.call(
							r,
							`    ${t} isCredentialSourceProfile credential_source=${e.credential_source}`,
						)),
				i
			)
		}, 'isCredentialSourceProfile'),
		Hae = dr(async (e, t, r, n = {}) => {
			var i, o
			;(i = r.logger) == null ||
				i.debug(
					'@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)',
				)
			let s = t[e]
			if (!r.roleAssumer) {
				let { getDefaultRoleAssumer: p } = await Promise.resolve().then(() =>
					Ui(iy()),
				)
				r.roleAssumer = p(
					{
						...r.clientConfig,
						credentialProviderLogger: r.logger,
						parentClientConfig: r?.parentClientConfig,
					},
					r.clientPlugins,
				)
			}
			let { source_profile: c } = s
			if (c && c in n)
				throw new El.CredentialsProviderError(
					`Detected a cycle attempting to resolve credentials for profile ${(0, my.getProfileName)(r)}. Profiles visited: ` +
						Object.keys(n).join(', '),
					{ logger: r.logger },
				)
			;(o = r.logger) == null ||
				o.debug(
					`@aws-sdk/credential-provider-ini - finding credential resolver using ${c ? `source_profile=[${c}]` : `profile=[${e}]`}`,
				)
			let l = c
					? AF(
							c,
							{ ...t, [c]: { ...t[c], role_arn: s.role_arn ?? t[c].role_arn } },
							r,
							{ ...n, [c]: !0 },
						)
					: (await jae(s.credential_source, e, r.logger)(r))(),
				u = {
					RoleArn: s.role_arn,
					RoleSessionName: s.role_session_name || `aws-sdk-js-${Date.now()}`,
					ExternalId: s.external_id,
					DurationSeconds: parseInt(s.duration_seconds || '3600', 10),
				},
				{ mfa_serial: m } = s
			if (m) {
				if (!r.mfaCodeProvider)
					throw new El.CredentialsProviderError(
						`Profile ${e} requires multi-factor authentication, but no MFA code callback was provided.`,
						{ logger: r.logger, tryNextLink: !1 },
					)
				;(u.SerialNumber = m), (u.TokenCode = await r.mfaCodeProvider(m))
			}
			let f = await l
			return r.roleAssumer(f, u)
		}, 'resolveAssumeRoleCredentials'),
		$ae = dr(
			(e) =>
				!!e && typeof e == 'object' && typeof e.credential_process == 'string',
			'isProcessProfile',
		),
		Vae = dr(
			async (e, t) =>
				Promise.resolve()
					.then(() => Ui(ay()))
					.then(({ fromProcess: r }) => r({ ...e, profile: t })()),
			'resolveProcessCredentials',
		),
		Kae = dr(async (e, t = {}) => {
			let { fromSSO: r } = await Promise.resolve().then(() => Ui(h_()))
			return r({ profile: e, logger: t.logger })()
		}, 'resolveSsoCredentials'),
		Wae = dr(
			(e) =>
				e &&
				(typeof e.sso_start_url == 'string' ||
					typeof e.sso_account_id == 'string' ||
					typeof e.sso_session == 'string' ||
					typeof e.sso_region == 'string' ||
					typeof e.sso_role_name == 'string'),
			'isSsoProfile',
		),
		bF = dr(
			(e) =>
				!!e &&
				typeof e == 'object' &&
				typeof e.aws_access_key_id == 'string' &&
				typeof e.aws_secret_access_key == 'string' &&
				['undefined', 'string'].indexOf(typeof e.aws_session_token) > -1 &&
				['undefined', 'string'].indexOf(typeof e.aws_account_id) > -1,
			'isStaticCredsProfile',
		),
		wF = dr((e, t) => {
			var r
			return (
				(r = t?.logger) == null ||
					r.debug(
						'@aws-sdk/credential-provider-ini - resolveStaticCredentials',
					),
				Promise.resolve({
					accessKeyId: e.aws_access_key_id,
					secretAccessKey: e.aws_secret_access_key,
					sessionToken: e.aws_session_token,
					...(e.aws_credential_scope && {
						credentialScope: e.aws_credential_scope,
					}),
					...(e.aws_account_id && { accountId: e.aws_account_id }),
				})
			)
		}, 'resolveStaticCredentials'),
		Xae = dr(
			(e) =>
				!!e &&
				typeof e == 'object' &&
				typeof e.web_identity_token_file == 'string' &&
				typeof e.role_arn == 'string' &&
				['undefined', 'string'].indexOf(typeof e.role_session_name) > -1,
			'isWebIdentityProfile',
		),
		Yae = dr(
			async (e, t) =>
				Promise.resolve()
					.then(() => Ui(uy()))
					.then(({ fromTokenFile: r }) =>
						r({
							webIdentityTokenFile: e.web_identity_token_file,
							roleArn: e.role_arn,
							roleSessionName: e.role_session_name,
							roleAssumerWithWebIdentity: t.roleAssumerWithWebIdentity,
							logger: t.logger,
							parentClientConfig: t.parentClientConfig,
						})(),
					),
			'resolveWebIdentityCredentials',
		),
		AF = dr(async (e, t, r, n = {}) => {
			let i = t[e]
			if (Object.keys(n).length > 0 && bF(i)) return wF(i, r)
			if (Uae(i, { profile: e, logger: r.logger })) return Hae(e, t, r, n)
			if (bF(i)) return wF(i, r)
			if (Xae(i)) return Yae(i, r)
			if ($ae(i)) return Vae(r, e)
			if (Wae(i)) return await Kae(e, r)
			throw new El.CredentialsProviderError(
				`Could not resolve credentials using profile: [${e}] in configuration/credentials file(s).`,
				{ logger: r.logger },
			)
		}, 'resolveProfileData'),
		Jae = dr(
			(e = {}) =>
				async () => {
					var t
					;(t = e.logger) == null ||
						t.debug('@aws-sdk/credential-provider-ini - fromIni')
					let r = await (0, my.parseKnownFiles)(e)
					return AF((0, my.getProfileName)(e), r, e)
				},
			'fromIni',
		)
})
var km = E((BTe, DF) => {
	'use strict'
	var Qae = Object.create,
		wl = Object.defineProperty,
		Zae = Object.getOwnPropertyDescriptor,
		ece = Object.getOwnPropertyNames,
		tce = Object.getPrototypeOf,
		rce = Object.prototype.hasOwnProperty,
		Jm = (e, t) => wl(e, 'name', { value: t, configurable: !0 }),
		nce = (e, t) => {
			for (var r in t) wl(e, r, { get: t[r], enumerable: !0 })
		},
		IF = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of ece(t))
					!rce.call(e, i) &&
						i !== r &&
						wl(e, i, {
							get: () => t[i],
							enumerable: !(n = Zae(t, i)) || n.enumerable,
						})
			return e
		},
		la = (e, t, r) => (
			(r = e != null ? Qae(tce(e)) : {}),
			IF(
				t || !e || !e.__esModule
					? wl(r, 'default', { value: e, enumerable: !0 })
					: r,
				e,
			)
		),
		ice = (e) => IF(wl({}, '__esModule', { value: !0 }), e),
		TF = {}
	nce(TF, {
		credentialsTreatedAsExpired: () => NF,
		credentialsWillNeedRefresh: () => BF,
		defaultProvider: () => cce,
	})
	DF.exports = ice(TF)
	var fy = Vh(),
		oce = hi(),
		bo = nr(),
		sce = 'AWS_EC2_METADATA_DISABLED',
		ace = Jm(async (e) => {
			var t, r
			let {
				ENV_CMDS_FULL_URI: n,
				ENV_CMDS_RELATIVE_URI: i,
				fromContainerMetadata: o,
				fromInstanceMetadata: s,
			} = await Promise.resolve().then(() => la(rl()))
			if (process.env[i] || process.env[n]) {
				;(t = e.logger) == null ||
					t.debug(
						'@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata',
					)
				let { fromHttp: c } = await Promise.resolve().then(() => la(Zh()))
				return (0, bo.chain)(c(e), o(e))
			}
			return process.env[sce]
				? async () => {
						throw new bo.CredentialsProviderError(
							'EC2 Instance Metadata Service access disabled',
							{ logger: e.logger },
						)
					}
				: ((r = e.logger) == null ||
						r.debug(
							'@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata',
						),
					s(e))
		}, 'remoteProvider'),
		kF = !1,
		cce = Jm(
			(e = {}) =>
				(0, bo.memoize)(
					(0, bo.chain)(
						async () => {
							var t, r, n, i
							if (e.profile ?? process.env[oce.ENV_PROFILE])
								throw (
									(process.env[fy.ENV_KEY] &&
										process.env[fy.ENV_SECRET] &&
										(kF ||
											(((t = e.logger) != null &&
												t.warn &&
												((n =
													(r = e.logger) == null ? void 0 : r.constructor) ==
												null
													? void 0
													: n.name) !== 'NoOpLogger'
												? e.logger.warn
												: console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`),
											(kF = !0))),
									new bo.CredentialsProviderError(
										'AWS_PROFILE is set, skipping fromEnv provider.',
										{ logger: e.logger, tryNextLink: !0 },
									))
								)
							return (
								(i = e.logger) == null ||
									i.debug(
										'@aws-sdk/credential-provider-node - defaultProvider::fromEnv',
									),
								(0, fy.fromEnv)(e)()
							)
						},
						async () => {
							var t
							;(t = e.logger) == null ||
								t.debug(
									'@aws-sdk/credential-provider-node - defaultProvider::fromSSO',
								)
							let {
								ssoStartUrl: r,
								ssoAccountId: n,
								ssoRegion: i,
								ssoRoleName: o,
								ssoSession: s,
							} = e
							if (!r && !n && !i && !o && !s)
								throw new bo.CredentialsProviderError(
									'Skipping SSO provider in default chain (inputs do not include SSO fields).',
									{ logger: e.logger },
								)
							let { fromSSO: c } = await Promise.resolve().then(() => la(h_()))
							return c(e)()
						},
						async () => {
							var t
							;(t = e.logger) == null ||
								t.debug(
									'@aws-sdk/credential-provider-node - defaultProvider::fromIni',
								)
							let { fromIni: r } = await Promise.resolve().then(() => la(RF()))
							return r(e)()
						},
						async () => {
							var t
							;(t = e.logger) == null ||
								t.debug(
									'@aws-sdk/credential-provider-node - defaultProvider::fromProcess',
								)
							let { fromProcess: r } = await Promise.resolve().then(() =>
								la(ay()),
							)
							return r(e)()
						},
						async () => {
							var t
							;(t = e.logger) == null ||
								t.debug(
									'@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile',
								)
							let { fromTokenFile: r } = await Promise.resolve().then(() =>
								la(uy()),
							)
							return r(e)()
						},
						async () => {
							var t
							return (
								(t = e.logger) == null ||
									t.debug(
										'@aws-sdk/credential-provider-node - defaultProvider::remoteProvider',
									),
								(await ace(e))()
							)
						},
						async () => {
							throw new bo.CredentialsProviderError(
								'Could not load credentials from any providers',
								{ tryNextLink: !1, logger: e.logger },
							)
						},
					),
					NF,
					BF,
				),
			'defaultProvider',
		),
		BF = Jm((e) => e?.expiration !== void 0, 'credentialsWillNeedRefresh'),
		NF = Jm(
			(e) =>
				e?.expiration !== void 0 && e.expiration.getTime() - Date.now() < 3e5,
			'credentialsTreatedAsExpired',
		)
})
var tM = E((NTe, eM) => {
	'use strict'
	var Qm = Object.defineProperty,
		lce = Object.getOwnPropertyDescriptor,
		dce = Object.getOwnPropertyNames,
		uce = Object.prototype.hasOwnProperty,
		De = (e, t) => Qm(e, 'name', { value: t, configurable: !0 }),
		mce = (e, t) => {
			for (var r in t) Qm(e, r, { get: t[r], enumerable: !0 })
		},
		fce = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of dce(t))
					!uce.call(e, i) &&
						i !== r &&
						Qm(e, i, {
							get: () => t[i],
							enumerable: !(n = lce(t, i)) || n.enumerable,
						})
			return e
		},
		pce = (e) => fce(Qm({}, '__esModule', { value: !0 }), e),
		FF = {}
	mce(FF, {
		NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS: () => gce,
		NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME: () => MF,
		NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME: () => qF,
		NODE_USE_ARN_REGION_CONFIG_OPTIONS: () => vce,
		NODE_USE_ARN_REGION_ENV_NAME: () => jF,
		NODE_USE_ARN_REGION_INI_NAME: () => UF,
		bucketEndpointMiddleware: () => JF,
		bucketEndpointMiddlewareOptions: () => QF,
		bucketHostname: () => vy,
		getArnResources: () => XF,
		getBucketEndpointPlugin: () => Lce,
		getSuffixForArnEndpoint: () => $F,
		resolveBucketEndpointConfig: () => ZF,
		validateAccountId: () => WF,
		validateDNSHostLabel: () => da,
		validateNoDualstack: () => ef,
		validateNoFIPS: () => YF,
		validateOutpostService: () => VF,
		validatePartition: () => KF,
		validateRegion: () => Zm,
	})
	eM.exports = pce(FF)
	var Gi = zd(),
		MF = 'AWS_S3_DISABLE_MULTIREGION_ACCESS_POINTS',
		qF = 's3_disable_multiregion_access_points',
		gce = {
			environmentVariableSelector: (e) =>
				(0, Gi.booleanSelector)(e, MF, Gi.SelectorType.ENV),
			configFileSelector: (e) =>
				(0, Gi.booleanSelector)(e, qF, Gi.SelectorType.CONFIG),
			default: !1,
		},
		jF = 'AWS_S3_USE_ARN_REGION',
		UF = 's3_use_arn_region',
		vce = {
			environmentVariableSelector: (e) =>
				(0, Gi.booleanSelector)(e, jF, Gi.SelectorType.ENV),
			configFileSelector: (e) =>
				(0, Gi.booleanSelector)(e, UF, Gi.SelectorType.CONFIG),
			default: !1,
		},
		LF = Ov(),
		hce = Xe(),
		_ce = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/,
		yce = /(\d+\.){3}\d+/,
		Sce = /\.\./,
		GF = /\./,
		Cce = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./,
		zF = /^s3(-external-1)?\.amazonaws\.com$/,
		gy = 'amazonaws.com',
		Ece = De((e) => typeof e.bucketName == 'string', 'isBucketNameOptions'),
		bce = De(
			(e) => _ce.test(e) && !yce.test(e) && !Sce.test(e),
			'isDnsCompatibleBucketName',
		),
		HF = De((e) => {
			let t = e.match(Cce)
			return [t[4], e.replace(new RegExp(`^${t[0]}`), '')]
		}, 'getRegionalSuffix'),
		wce = De((e) => (zF.test(e) ? ['us-east-1', gy] : HF(e)), 'getSuffix'),
		$F = De(
			(e) => (zF.test(e) ? [e.replace(`.${gy}`, ''), gy] : HF(e)),
			'getSuffixForArnEndpoint',
		),
		xce = De((e) => {
			if (e.pathStyleEndpoint)
				throw new Error(
					'Path-style S3 endpoint is not supported when bucket is an ARN',
				)
			if (e.accelerateEndpoint)
				throw new Error(
					'Accelerate endpoint is not supported when bucket is an ARN',
				)
			if (!e.tlsCompatible)
				throw new Error('HTTPS is required when bucket is an ARN')
		}, 'validateArnEndpointOptions'),
		Pce = De((e) => {
			if (e !== 's3' && e !== 's3-outposts' && e !== 's3-object-lambda')
				throw new Error(
					"Expect 's3' or 's3-outposts' or 's3-object-lambda' in ARN service component",
				)
		}, 'validateService'),
		Ace = De((e) => {
			if (e !== 's3')
				throw new Error("Expect 's3' in Accesspoint ARN service component")
		}, 'validateS3Service'),
		VF = De((e) => {
			if (e !== 's3-outposts')
				throw new Error("Expect 's3-posts' in Outpost ARN service component")
		}, 'validateOutpostService'),
		KF = De((e, t) => {
			if (e !== t.clientPartition)
				throw new Error(
					`Partition in ARN is incompatible, got "${e}" but expected "${t.clientPartition}"`,
				)
		}, 'validatePartition'),
		Zm = De((e, t) => {
			if (e === '') throw new Error('ARN region is empty')
			if (t.useFipsEndpoint)
				if (t.allowFipsRegion) {
					if (!py(e, t.clientRegion))
						throw new Error(
							`Client FIPS region ${t.clientRegion} doesn't match region ${e} in ARN`,
						)
				} else throw new Error('FIPS region is not supported')
			if (
				!t.useArnRegion &&
				!py(e, t.clientRegion || '') &&
				!py(e, t.clientSigningRegion || '')
			)
				throw new Error(
					`Region in ARN is incompatible, got ${e} but expected ${t.clientRegion}`,
				)
		}, 'validateRegion'),
		hy = De((e) => {
			if (['s3-external-1', 'aws-global'].includes(e))
				throw new Error(`Client region ${e} is not regional`)
		}, 'validateRegionalClient'),
		py = De((e, t) => e === t, 'isEqualRegions'),
		WF = De((e) => {
			if (!/[0-9]{12}/.exec(e))
				throw new Error(
					"Access point ARN accountID does not match regex '[0-9]{12}'",
				)
		}, 'validateAccountId'),
		da = De((e, t = { tlsCompatible: !0 }) => {
			if (
				e.length >= 64 ||
				!/^[a-z0-9][a-z0-9.-]*[a-z0-9]$/.test(e) ||
				/(\d+\.){3}\d+/.test(e) ||
				/[.-]{2}/.test(e) ||
				(t?.tlsCompatible && GF.test(e))
			)
				throw new Error(`Invalid DNS label ${e}`)
		}, 'validateDNSHostLabel'),
		Oce = De((e) => {
			if (e.isCustomEndpoint) {
				if (e.dualstackEndpoint)
					throw new Error(
						'Dualstack endpoint is not supported with custom endpoint',
					)
				if (e.accelerateEndpoint)
					throw new Error(
						'Accelerate endpoint is not supported with custom endpoint',
					)
			}
		}, 'validateCustomEndpoint'),
		XF = De((e) => {
			let t = e.includes(':') ? ':' : '/',
				[r, ...n] = e.split(t)
			if (r === 'accesspoint') {
				if (n.length !== 1 || n[0] === '')
					throw new Error(
						`Access Point ARN should have one resource accesspoint${t}{accesspointname}`,
					)
				return { accesspointName: n[0] }
			} else if (r === 'outpost') {
				if (!n[0] || n[1] !== 'accesspoint' || !n[2] || n.length !== 3)
					throw new Error(
						`Outpost ARN should have resource outpost${t}{outpostId}${t}accesspoint${t}{accesspointName}`,
					)
				let [i, o, s] = n
				return { outpostId: i, accesspointName: s }
			} else
				throw new Error(
					`ARN resource should begin with 'accesspoint${t}' or 'outpost${t}'`,
				)
		}, 'getArnResources'),
		ef = De((e) => {
			if (e)
				throw new Error(
					'Dualstack endpoint is not supported with Outpost or Multi-region Access Point ARN.',
				)
		}, 'validateNoDualstack'),
		YF = De((e) => {
			if (e) throw new Error('FIPS region is not supported with Outpost.')
		}, 'validateNoFIPS'),
		Rce = De((e) => {
			try {
				e.split('.').forEach((t) => {
					da(t)
				})
			} catch {
				throw new Error(`"${e}" is not a DNS compatible name.`)
			}
		}, 'validateMrapAlias'),
		vy = De((e) => (Oce(e), Ece(e) ? kce(e) : Ice(e)), 'bucketHostname'),
		kce = De(
			({
				accelerateEndpoint: e = !1,
				clientRegion: t,
				baseHostname: r,
				bucketName: n,
				dualstackEndpoint: i = !1,
				fipsEndpoint: o = !1,
				pathStyleEndpoint: s = !1,
				tlsCompatible: c = !0,
				isCustomEndpoint: l = !1,
			}) => {
				let [u, m] = l ? [t, r] : wce(r)
				return s || !bce(n) || (c && GF.test(n))
					? { bucketEndpoint: !1, hostname: i ? `s3.dualstack.${u}.${m}` : r }
					: (e
							? (r = `s3-accelerate${i ? '.dualstack' : ''}.${m}`)
							: i && (r = `s3.dualstack.${u}.${m}`),
						{ bucketEndpoint: !0, hostname: `${n}.${r}` })
			},
			'getEndpointFromBucketName',
		),
		Ice = De((e) => {
			let { isCustomEndpoint: t, baseHostname: r, clientRegion: n } = e,
				i = t ? r : $F(r)[1],
				{
					pathStyleEndpoint: o,
					accelerateEndpoint: s = !1,
					fipsEndpoint: c = !1,
					tlsCompatible: l = !0,
					bucketName: u,
					clientPartition: m = 'aws',
				} = e
			xce({ pathStyleEndpoint: o, accelerateEndpoint: s, tlsCompatible: l })
			let { service: f, partition: p, accountId: g, region: v, resource: _ } = u
			Pce(f), KF(p, { clientPartition: m }), WF(g)
			let { accesspointName: y, outpostId: P } = XF(_)
			return f === 's3-object-lambda'
				? Tce({
						...e,
						tlsCompatible: l,
						bucketName: u,
						accesspointName: y,
						hostnameSuffix: i,
					})
				: v === ''
					? Bce({ ...e, clientRegion: n, mrapAlias: y, hostnameSuffix: i })
					: P
						? Nce({
								...e,
								clientRegion: n,
								outpostId: P,
								accesspointName: y,
								hostnameSuffix: i,
							})
						: Dce({
								...e,
								clientRegion: n,
								accesspointName: y,
								hostnameSuffix: i,
							})
		}, 'getEndpointFromArn'),
		Tce = De(
			({
				dualstackEndpoint: e = !1,
				fipsEndpoint: t = !1,
				tlsCompatible: r = !0,
				useArnRegion: n,
				clientRegion: i,
				clientSigningRegion: o = i,
				accesspointName: s,
				bucketName: c,
				hostnameSuffix: l,
			}) => {
				let { accountId: u, region: m, service: f } = c
				hy(i),
					Zm(m, {
						useArnRegion: n,
						clientRegion: i,
						clientSigningRegion: o,
						allowFipsRegion: !0,
						useFipsEndpoint: t,
					}),
					ef(e)
				let p = `${s}-${u}`
				da(p, { tlsCompatible: r })
				let g = n ? m : i,
					v = n ? m : o
				return {
					bucketEndpoint: !0,
					hostname: `${p}.${f}${t ? '-fips' : ''}.${g}.${l}`,
					signingRegion: v,
					signingService: f,
				}
			},
			'getEndpointFromObjectLambdaArn',
		),
		Bce = De(
			({
				disableMultiregionAccessPoints: e,
				dualstackEndpoint: t = !1,
				isCustomEndpoint: r,
				mrapAlias: n,
				hostnameSuffix: i,
			}) => {
				if (e === !0)
					throw new Error(
						'SDK is attempting to use a MRAP ARN. Please enable to feature.',
					)
				return (
					Rce(n),
					ef(t),
					{
						bucketEndpoint: !0,
						hostname: `${n}${r ? '' : '.accesspoint.s3-global'}.${i}`,
						signingRegion: '*',
					}
				)
			},
			'getEndpointFromMRAPArn',
		),
		Nce = De(
			({
				useArnRegion: e,
				clientRegion: t,
				clientSigningRegion: r = t,
				bucketName: n,
				outpostId: i,
				dualstackEndpoint: o = !1,
				fipsEndpoint: s = !1,
				tlsCompatible: c = !0,
				accesspointName: l,
				isCustomEndpoint: u,
				hostnameSuffix: m,
			}) => {
				hy(t),
					Zm(n.region, {
						useArnRegion: e,
						clientRegion: t,
						clientSigningRegion: r,
						useFipsEndpoint: s,
					})
				let f = `${l}-${n.accountId}`
				da(f, { tlsCompatible: c })
				let p = e ? n.region : t,
					g = e ? n.region : r
				return (
					VF(n.service),
					da(i, { tlsCompatible: c }),
					ef(o),
					YF(s),
					{
						bucketEndpoint: !0,
						hostname: `${`${f}.${i}`}${u ? '' : `.s3-outposts.${p}`}.${m}`,
						signingRegion: g,
						signingService: 's3-outposts',
					}
				)
			},
			'getEndpointFromOutpostArn',
		),
		Dce = De(
			({
				useArnRegion: e,
				clientRegion: t,
				clientSigningRegion: r = t,
				bucketName: n,
				dualstackEndpoint: i = !1,
				fipsEndpoint: o = !1,
				tlsCompatible: s = !0,
				accesspointName: c,
				isCustomEndpoint: l,
				hostnameSuffix: u,
			}) => {
				hy(t),
					Zm(n.region, {
						useArnRegion: e,
						clientRegion: t,
						clientSigningRegion: r,
						allowFipsRegion: !0,
						useFipsEndpoint: o,
					})
				let m = `${c}-${n.accountId}`
				da(m, { tlsCompatible: s })
				let f = e ? n.region : t,
					p = e ? n.region : r
				return (
					Ace(n.service),
					{
						bucketEndpoint: !0,
						hostname: `${m}${l ? '' : `.s3-accesspoint${o ? '-fips' : ''}${i ? '.dualstack' : ''}.${f}`}.${u}`,
						signingRegion: p,
					}
				)
			},
			'getEndpointFromAccessPointArn',
		),
		JF = De(
			(e) => (t, r) => async (n) => {
				let { Bucket: i } = n.input,
					o = e.bucketEndpoint,
					s = n.request
				if (hce.HttpRequest.isInstance(s)) {
					if (e.bucketEndpoint) s.hostname = i
					else if ((0, LF.validate)(i)) {
						let c = (0, LF.parse)(i),
							l = await e.region(),
							u = await e.useDualstackEndpoint(),
							m = await e.useFipsEndpoint(),
							{ partition: f, signingRegion: p = l } =
								(await e.regionInfoProvider(l, {
									useDualstackEndpoint: u,
									useFipsEndpoint: m,
								})) || {},
							g = await e.useArnRegion(),
							{
								hostname: v,
								bucketEndpoint: _,
								signingRegion: y,
								signingService: P,
							} = vy({
								bucketName: c,
								baseHostname: s.hostname,
								accelerateEndpoint: e.useAccelerateEndpoint,
								dualstackEndpoint: u,
								fipsEndpoint: m,
								pathStyleEndpoint: e.forcePathStyle,
								tlsCompatible: s.protocol === 'https:',
								useArnRegion: g,
								clientPartition: f,
								clientSigningRegion: p,
								clientRegion: l,
								isCustomEndpoint: e.isCustomEndpoint,
								disableMultiregionAccessPoints:
									await e.disableMultiregionAccessPoints(),
							})
						y && y !== p && (r.signing_region = y),
							P && P !== 's3' && (r.signing_service = P),
							(s.hostname = v),
							(o = _)
					} else {
						let c = await e.region(),
							l = await e.useDualstackEndpoint(),
							u = await e.useFipsEndpoint(),
							{ hostname: m, bucketEndpoint: f } = vy({
								bucketName: i,
								clientRegion: c,
								baseHostname: s.hostname,
								accelerateEndpoint: e.useAccelerateEndpoint,
								dualstackEndpoint: l,
								fipsEndpoint: u,
								pathStyleEndpoint: e.forcePathStyle,
								tlsCompatible: s.protocol === 'https:',
								isCustomEndpoint: e.isCustomEndpoint,
							})
						;(s.hostname = m), (o = f)
					}
					o &&
						((s.path = s.path.replace(/^(\/)?[^\/]+/, '')),
						s.path === '' && (s.path = '/'))
				}
				return t({ ...n, request: s })
			},
			'bucketEndpointMiddleware',
		),
		QF = {
			tags: ['BUCKET_ENDPOINT'],
			name: 'bucketEndpointMiddleware',
			relation: 'before',
			toMiddleware: 'hostHeaderMiddleware',
			override: !0,
		},
		Lce = De(
			(e) => ({
				applyToStack: (t) => {
					t.addRelativeTo(JF(e), QF)
				},
			}),
			'getBucketEndpointPlugin',
		)
	function ZF(e) {
		let {
			bucketEndpoint: t = !1,
			forcePathStyle: r = !1,
			useAccelerateEndpoint: n = !1,
			useArnRegion: i = !1,
			disableMultiregionAccessPoints: o = !1,
		} = e
		return {
			...e,
			bucketEndpoint: t,
			forcePathStyle: r,
			useAccelerateEndpoint: n,
			useArnRegion: typeof i == 'function' ? i : () => Promise.resolve(i),
			disableMultiregionAccessPoints:
				typeof o == 'function' ? o : () => Promise.resolve(o),
		}
	}
	De(ZF, 'resolveBucketEndpointConfig')
})
var iM = E((DTe, nM) => {
	var tf = Object.defineProperty,
		Fce = Object.getOwnPropertyDescriptor,
		Mce = Object.getOwnPropertyNames,
		qce = Object.prototype.hasOwnProperty,
		jce = (e, t) => tf(e, 'name', { value: t, configurable: !0 }),
		Uce = (e, t) => {
			for (var r in t) tf(e, r, { get: t[r], enumerable: !0 })
		},
		Gce = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Mce(t))
					!qce.call(e, i) &&
						i !== r &&
						tf(e, i, {
							get: () => t[i],
							enumerable: !(n = Fce(t, i)) || n.enumerable,
						})
			return e
		},
		zce = (e) => Gce(tf({}, '__esModule', { value: !0 }), e),
		rM = {}
	Uce(rM, { isArrayBuffer: () => Hce })
	nM.exports = zce(rM)
	var Hce = jce(
		(e) =>
			(typeof ArrayBuffer == 'function' && e instanceof ArrayBuffer) ||
			Object.prototype.toString.call(e) === '[object ArrayBuffer]',
		'isArrayBuffer',
	)
})
var cM = E((LTe, aM) => {
	var rf = Object.defineProperty,
		$ce = Object.getOwnPropertyDescriptor,
		Vce = Object.getOwnPropertyNames,
		Kce = Object.prototype.hasOwnProperty,
		oM = (e, t) => rf(e, 'name', { value: t, configurable: !0 }),
		Wce = (e, t) => {
			for (var r in t) rf(e, r, { get: t[r], enumerable: !0 })
		},
		Xce = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Vce(t))
					!Kce.call(e, i) &&
						i !== r &&
						rf(e, i, {
							get: () => t[i],
							enumerable: !(n = $ce(t, i)) || n.enumerable,
						})
			return e
		},
		Yce = (e) => Xce(rf({}, '__esModule', { value: !0 }), e),
		sM = {}
	Wce(sM, { fromArrayBuffer: () => Qce, fromString: () => Zce })
	aM.exports = Yce(sM)
	var Jce = iM(),
		_y = require('buffer'),
		Qce = oM((e, t = 0, r = e.byteLength - t) => {
			if (!(0, Jce.isArrayBuffer)(e))
				throw new TypeError(
					`The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`,
				)
			return _y.Buffer.from(e, t, r)
		}, 'fromArrayBuffer'),
		Zce = oM((e, t) => {
			if (typeof e != 'string')
				throw new TypeError(
					`The "input" argument must be of type string. Received type ${typeof e} (${e})`,
				)
			return t ? _y.Buffer.from(e, t) : _y.Buffer.from(e)
		}, 'fromString')
})
var fM = E((FTe, mM) => {
	var nf = Object.defineProperty,
		ele = Object.getOwnPropertyDescriptor,
		tle = Object.getOwnPropertyNames,
		rle = Object.prototype.hasOwnProperty,
		yy = (e, t) => nf(e, 'name', { value: t, configurable: !0 }),
		nle = (e, t) => {
			for (var r in t) nf(e, r, { get: t[r], enumerable: !0 })
		},
		ile = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of tle(t))
					!rle.call(e, i) &&
						i !== r &&
						nf(e, i, {
							get: () => t[i],
							enumerable: !(n = ele(t, i)) || n.enumerable,
						})
			return e
		},
		ole = (e) => ile(nf({}, '__esModule', { value: !0 }), e),
		lM = {}
	nle(lM, { fromUtf8: () => uM, toUint8Array: () => sle, toUtf8: () => ale })
	mM.exports = ole(lM)
	var dM = cM(),
		uM = yy((e) => {
			let t = (0, dM.fromString)(e, 'utf8')
			return new Uint8Array(
				t.buffer,
				t.byteOffset,
				t.byteLength / Uint8Array.BYTES_PER_ELEMENT,
			)
		}, 'fromUtf8'),
		sle = yy(
			(e) =>
				typeof e == 'string'
					? uM(e)
					: ArrayBuffer.isView(e)
						? new Uint8Array(
								e.buffer,
								e.byteOffset,
								e.byteLength / Uint8Array.BYTES_PER_ELEMENT,
							)
						: new Uint8Array(e),
			'toUint8Array',
		),
		ale = yy((e) => {
			if (typeof e == 'string') return e
			if (
				typeof e != 'object' ||
				typeof e.byteOffset != 'number' ||
				typeof e.byteLength != 'number'
			)
				throw new Error(
					'@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.',
				)
			return (0, dM.fromArrayBuffer)(
				e.buffer,
				e.byteOffset,
				e.byteLength,
			).toString('utf8')
		}, 'toUtf8')
})
var pM = E((of) => {
	'use strict'
	Object.defineProperty(of, '__esModule', { value: !0 })
	of.convertToBuffer = void 0
	var cle = fM(),
		lle =
			typeof Buffer < 'u' && Buffer.from
				? function (e) {
						return Buffer.from(e, 'utf8')
					}
				: cle.fromUtf8
	function dle(e) {
		return e instanceof Uint8Array
			? e
			: typeof e == 'string'
				? lle(e)
				: ArrayBuffer.isView(e)
					? new Uint8Array(
							e.buffer,
							e.byteOffset,
							e.byteLength / Uint8Array.BYTES_PER_ELEMENT,
						)
					: new Uint8Array(e)
	}
	of.convertToBuffer = dle
})
var gM = E((sf) => {
	'use strict'
	Object.defineProperty(sf, '__esModule', { value: !0 })
	sf.isEmptyData = void 0
	function ule(e) {
		return typeof e == 'string' ? e.length === 0 : e.byteLength === 0
	}
	sf.isEmptyData = ule
})
var vM = E((af) => {
	'use strict'
	Object.defineProperty(af, '__esModule', { value: !0 })
	af.numToUint8 = void 0
	function mle(e) {
		return new Uint8Array([
			(e & 4278190080) >> 24,
			(e & 16711680) >> 16,
			(e & 65280) >> 8,
			e & 255,
		])
	}
	af.numToUint8 = mle
})
var hM = E((cf) => {
	'use strict'
	Object.defineProperty(cf, '__esModule', { value: !0 })
	cf.uint32ArrayFrom = void 0
	function fle(e) {
		if (!Uint32Array.from) {
			for (var t = new Uint32Array(e.length), r = 0; r < e.length; )
				(t[r] = e[r]), (r += 1)
			return t
		}
		return Uint32Array.from(e)
	}
	cf.uint32ArrayFrom = fle
})
var xl = E((Nn) => {
	'use strict'
	Object.defineProperty(Nn, '__esModule', { value: !0 })
	Nn.uint32ArrayFrom =
		Nn.numToUint8 =
		Nn.isEmptyData =
		Nn.convertToBuffer =
			void 0
	var ple = pM()
	Object.defineProperty(Nn, 'convertToBuffer', {
		enumerable: !0,
		get: function () {
			return ple.convertToBuffer
		},
	})
	var gle = gM()
	Object.defineProperty(Nn, 'isEmptyData', {
		enumerable: !0,
		get: function () {
			return gle.isEmptyData
		},
	})
	var vle = vM()
	Object.defineProperty(Nn, 'numToUint8', {
		enumerable: !0,
		get: function () {
			return vle.numToUint8
		},
	})
	var hle = hM()
	Object.defineProperty(Nn, 'uint32ArrayFrom', {
		enumerable: !0,
		get: function () {
			return hle.uint32ArrayFrom
		},
	})
})
var SM = E((lf) => {
	'use strict'
	Object.defineProperty(lf, '__esModule', { value: !0 })
	lf.AwsCrc32 = void 0
	var _M = (Rn(), ve(On)),
		Sy = xl(),
		yM = Pl(),
		_le = (function () {
			function e() {
				this.crc32 = new yM.Crc32()
			}
			return (
				(e.prototype.update = function (t) {
					;(0, Sy.isEmptyData)(t) ||
						this.crc32.update((0, Sy.convertToBuffer)(t))
				}),
				(e.prototype.digest = function () {
					return _M.__awaiter(this, void 0, void 0, function () {
						return _M.__generator(this, function (t) {
							return [2, (0, Sy.numToUint8)(this.crc32.digest())]
						})
					})
				}),
				(e.prototype.reset = function () {
					this.crc32 = new yM.Crc32()
				}),
				e
			)
		})()
	lf.AwsCrc32 = _le
})
var Pl = E((zi) => {
	'use strict'
	Object.defineProperty(zi, '__esModule', { value: !0 })
	zi.AwsCrc32 = zi.Crc32 = zi.crc32 = void 0
	var yle = (Rn(), ve(On)),
		Sle = xl()
	function Cle(e) {
		return new CM().update(e).digest()
	}
	zi.crc32 = Cle
	var CM = (function () {
		function e() {
			this.checksum = 4294967295
		}
		return (
			(e.prototype.update = function (t) {
				var r, n
				try {
					for (var i = yle.__values(t), o = i.next(); !o.done; o = i.next()) {
						var s = o.value
						this.checksum =
							(this.checksum >>> 8) ^ ble[(this.checksum ^ s) & 255]
					}
				} catch (c) {
					r = { error: c }
				} finally {
					try {
						o && !o.done && (n = i.return) && n.call(i)
					} finally {
						if (r) throw r.error
					}
				}
				return this
			}),
			(e.prototype.digest = function () {
				return (this.checksum ^ 4294967295) >>> 0
			}),
			e
		)
	})()
	zi.Crc32 = CM
	var Ele = [
			0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685,
			2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995,
			2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648,
			2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990,
			1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755,
			2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145,
			1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206,
			2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980,
			1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705,
			3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527,
			1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772,
			4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290,
			251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719,
			3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925,
			453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202,
			4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960,
			984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733,
			3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467,
			855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048,
			3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054,
			702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443,
			3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945,
			2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430,
			2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580,
			2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225,
			1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143,
			2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732,
			1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850,
			2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135,
			1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109,
			3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954,
			1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920,
			3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877,
			83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603,
			3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992,
			534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934,
			4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795,
			376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105,
			3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270,
			936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108,
			3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449,
			601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471,
			3272380065, 1510334235, 755167117,
		],
		ble = (0, Sle.uint32ArrayFrom)(Ele),
		wle = SM()
	Object.defineProperty(zi, 'AwsCrc32', {
		enumerable: !0,
		get: function () {
			return wle.AwsCrc32
		},
	})
})
var LM = E((JTe, DM) => {
	var uf = Object.defineProperty,
		xle = Object.getOwnPropertyDescriptor,
		Ple = Object.getOwnPropertyNames,
		Ale = Object.prototype.hasOwnProperty,
		ri = (e, t) => uf(e, 'name', { value: t, configurable: !0 }),
		Ole = (e, t) => {
			for (var r in t) uf(e, r, { get: t[r], enumerable: !0 })
		},
		Rle = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Ple(t))
					!Ale.call(e, i) &&
						i !== r &&
						uf(e, i, {
							get: () => t[i],
							enumerable: !(n = xle(t, i)) || n.enumerable,
						})
			return e
		},
		kle = (e) => Rle(uf({}, '__esModule', { value: !0 }), e),
		bM = {}
	Ole(bM, {
		EventStreamCodec: () => zle,
		HeaderMarshaller: () => AM,
		Int64: () => df,
		MessageDecoderStream: () => Hle,
		MessageEncoderStream: () => $le,
		SmithyMessageDecoderStream: () => Vle,
		SmithyMessageEncoderStream: () => Kle,
	})
	DM.exports = kle(bM)
	var Ile = Pl(),
		wo = Ed(),
		wM = class xM {
			constructor(t) {
				if (((this.bytes = t), t.byteLength !== 8))
					throw new Error('Int64 buffers must be exactly 8 bytes')
			}
			static fromNumber(t) {
				if (t > 9223372036854776e3 || t < -9223372036854776e3)
					throw new Error(
						`${t} is too large (or, if negative, too small) to represent as an Int64`,
					)
				let r = new Uint8Array(8)
				for (
					let n = 7, i = Math.abs(Math.round(t));
					n > -1 && i > 0;
					n--, i /= 256
				)
					r[n] = i
				return t < 0 && Cy(r), new xM(r)
			}
			valueOf() {
				let t = this.bytes.slice(0),
					r = t[0] & 128
				return r && Cy(t), parseInt((0, wo.toHex)(t), 16) * (r ? -1 : 1)
			}
			toString() {
				return String(this.valueOf())
			}
		}
	ri(wM, 'Int64')
	var df = wM
	function Cy(e) {
		for (let t = 0; t < 8; t++) e[t] ^= 255
		for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
	}
	ri(Cy, 'negate')
	var PM = class {
		constructor(t, r) {
			;(this.toUtf8 = t), (this.fromUtf8 = r)
		}
		format(t) {
			let r = []
			for (let o of Object.keys(t)) {
				let s = this.fromUtf8(o)
				r.push(Uint8Array.from([s.byteLength]), s, this.formatHeaderValue(t[o]))
			}
			let n = new Uint8Array(r.reduce((o, s) => o + s.byteLength, 0)),
				i = 0
			for (let o of r) n.set(o, i), (i += o.byteLength)
			return n
		}
		formatHeaderValue(t) {
			switch (t.type) {
				case 'boolean':
					return Uint8Array.from([t.value ? 0 : 1])
				case 'byte':
					return Uint8Array.from([2, t.value])
				case 'short':
					let r = new DataView(new ArrayBuffer(3))
					return (
						r.setUint8(0, 3),
						r.setInt16(1, t.value, !1),
						new Uint8Array(r.buffer)
					)
				case 'integer':
					let n = new DataView(new ArrayBuffer(5))
					return (
						n.setUint8(0, 4),
						n.setInt32(1, t.value, !1),
						new Uint8Array(n.buffer)
					)
				case 'long':
					let i = new Uint8Array(9)
					return (i[0] = 5), i.set(t.value.bytes, 1), i
				case 'binary':
					let o = new DataView(new ArrayBuffer(3 + t.value.byteLength))
					o.setUint8(0, 6), o.setUint16(1, t.value.byteLength, !1)
					let s = new Uint8Array(o.buffer)
					return s.set(t.value, 3), s
				case 'string':
					let c = this.fromUtf8(t.value),
						l = new DataView(new ArrayBuffer(3 + c.byteLength))
					l.setUint8(0, 7), l.setUint16(1, c.byteLength, !1)
					let u = new Uint8Array(l.buffer)
					return u.set(c, 3), u
				case 'timestamp':
					let m = new Uint8Array(9)
					return (m[0] = 8), m.set(df.fromNumber(t.value.valueOf()).bytes, 1), m
				case 'uuid':
					if (!jle.test(t.value))
						throw new Error(`Invalid UUID received: ${t.value}`)
					let f = new Uint8Array(17)
					return (
						(f[0] = 9), f.set((0, wo.fromHex)(t.value.replace(/\-/g, '')), 1), f
					)
			}
		}
		parse(t) {
			let r = {},
				n = 0
			for (; n < t.byteLength; ) {
				let i = t.getUint8(n++),
					o = this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + n, i))
				switch (((n += i), t.getUint8(n++))) {
					case 0:
						r[o] = { type: EM, value: !0 }
						break
					case 1:
						r[o] = { type: EM, value: !1 }
						break
					case 2:
						r[o] = { type: Tle, value: t.getInt8(n++) }
						break
					case 3:
						;(r[o] = { type: Ble, value: t.getInt16(n, !1) }), (n += 2)
						break
					case 4:
						;(r[o] = { type: Nle, value: t.getInt32(n, !1) }), (n += 4)
						break
					case 5:
						;(r[o] = {
							type: Dle,
							value: new df(new Uint8Array(t.buffer, t.byteOffset + n, 8)),
						}),
							(n += 8)
						break
					case 6:
						let s = t.getUint16(n, !1)
						;(n += 2),
							(r[o] = {
								type: Lle,
								value: new Uint8Array(t.buffer, t.byteOffset + n, s),
							}),
							(n += s)
						break
					case 7:
						let c = t.getUint16(n, !1)
						;(n += 2),
							(r[o] = {
								type: Fle,
								value: this.toUtf8(
									new Uint8Array(t.buffer, t.byteOffset + n, c),
								),
							}),
							(n += c)
						break
					case 8:
						;(r[o] = {
							type: Mle,
							value: new Date(
								new df(new Uint8Array(t.buffer, t.byteOffset + n, 8)).valueOf(),
							),
						}),
							(n += 8)
						break
					case 9:
						let l = new Uint8Array(t.buffer, t.byteOffset + n, 16)
						;(n += 16),
							(r[o] = {
								type: qle,
								value: `${(0, wo.toHex)(l.subarray(0, 4))}-${(0, wo.toHex)(l.subarray(4, 6))}-${(0, wo.toHex)(l.subarray(6, 8))}-${(0, wo.toHex)(l.subarray(8, 10))}-${(0, wo.toHex)(l.subarray(10))}`,
							})
						break
					default:
						throw new Error('Unrecognized header type tag')
				}
			}
			return r
		}
	}
	ri(PM, 'HeaderMarshaller')
	var AM = PM,
		EM = 'boolean',
		Tle = 'byte',
		Ble = 'short',
		Nle = 'integer',
		Dle = 'long',
		Lle = 'binary',
		Fle = 'string',
		Mle = 'timestamp',
		qle = 'uuid',
		jle = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/,
		Ule = Pl(),
		OM = 4,
		Hi = OM * 2,
		xo = 4,
		Gle = Hi + xo * 2
	function RM({ byteLength: e, byteOffset: t, buffer: r }) {
		if (e < Gle)
			throw new Error(
				'Provided message too short to accommodate event stream message overhead',
			)
		let n = new DataView(r, t, e),
			i = n.getUint32(0, !1)
		if (e !== i)
			throw new Error(
				'Reported message length does not match received message length',
			)
		let o = n.getUint32(OM, !1),
			s = n.getUint32(Hi, !1),
			c = n.getUint32(e - xo, !1),
			l = new Ule.Crc32().update(new Uint8Array(r, t, Hi))
		if (s !== l.digest())
			throw new Error(
				`The prelude checksum specified in the message (${s}) does not match the calculated CRC32 checksum (${l.digest()})`,
			)
		if ((l.update(new Uint8Array(r, t + Hi, e - (Hi + xo))), c !== l.digest()))
			throw new Error(
				`The message checksum (${l.digest()}) did not match the expected value of ${c}`,
			)
		return {
			headers: new DataView(r, t + Hi + xo, o),
			body: new Uint8Array(r, t + Hi + xo + o, i - o - (Hi + xo + xo)),
		}
	}
	ri(RM, 'splitMessage')
	var kM = class {
		constructor(t, r) {
			;(this.headerMarshaller = new AM(t, r)),
				(this.messageBuffer = []),
				(this.isEndOfStream = !1)
		}
		feed(t) {
			this.messageBuffer.push(this.decode(t))
		}
		endOfStream() {
			this.isEndOfStream = !0
		}
		getMessage() {
			let t = this.messageBuffer.pop(),
				r = this.isEndOfStream
			return {
				getMessage() {
					return t
				},
				isEndOfStream() {
					return r
				},
			}
		}
		getAvailableMessages() {
			let t = this.messageBuffer
			this.messageBuffer = []
			let r = this.isEndOfStream
			return {
				getMessages() {
					return t
				},
				isEndOfStream() {
					return r
				},
			}
		}
		encode({ headers: t, body: r }) {
			let n = this.headerMarshaller.format(t),
				i = n.byteLength + r.byteLength + 16,
				o = new Uint8Array(i),
				s = new DataView(o.buffer, o.byteOffset, o.byteLength),
				c = new Ile.Crc32()
			return (
				s.setUint32(0, i, !1),
				s.setUint32(4, n.byteLength, !1),
				s.setUint32(8, c.update(o.subarray(0, 8)).digest(), !1),
				o.set(n, 12),
				o.set(r, n.byteLength + 12),
				s.setUint32(i - 4, c.update(o.subarray(8, i - 4)).digest(), !1),
				o
			)
		}
		decode(t) {
			let { headers: r, body: n } = RM(t)
			return { headers: this.headerMarshaller.parse(r), body: n }
		}
		formatHeaders(t) {
			return this.headerMarshaller.format(t)
		}
	}
	ri(kM, 'EventStreamCodec')
	var zle = kM,
		IM = class {
			constructor(t) {
				this.options = t
			}
			[Symbol.asyncIterator]() {
				return this.asyncIterator()
			}
			async *asyncIterator() {
				for await (let t of this.options.inputStream)
					yield this.options.decoder.decode(t)
			}
		}
	ri(IM, 'MessageDecoderStream')
	var Hle = IM,
		TM = class {
			constructor(t) {
				this.options = t
			}
			[Symbol.asyncIterator]() {
				return this.asyncIterator()
			}
			async *asyncIterator() {
				for await (let t of this.options.messageStream)
					yield this.options.encoder.encode(t)
				this.options.includeEndFrame && (yield new Uint8Array(0))
			}
		}
	ri(TM, 'MessageEncoderStream')
	var $le = TM,
		BM = class {
			constructor(t) {
				this.options = t
			}
			[Symbol.asyncIterator]() {
				return this.asyncIterator()
			}
			async *asyncIterator() {
				for await (let t of this.options.messageStream) {
					let r = await this.options.deserializer(t)
					r !== void 0 && (yield r)
				}
			}
		}
	ri(BM, 'SmithyMessageDecoderStream')
	var Vle = BM,
		NM = class {
			constructor(t) {
				this.options = t
			}
			[Symbol.asyncIterator]() {
				return this.asyncIterator()
			}
			async *asyncIterator() {
				for await (let t of this.options.inputStream)
					yield this.options.serializer(t)
			}
		}
	ri(NM, 'SmithyMessageEncoderStream')
	var Kle = NM
})
var zM = E((ZTe, GM) => {
	var mf = Object.defineProperty,
		Wle = Object.getOwnPropertyDescriptor,
		Xle = Object.getOwnPropertyNames,
		Yle = Object.prototype.hasOwnProperty,
		ua = (e, t) => mf(e, 'name', { value: t, configurable: !0 }),
		Jle = (e, t) => {
			for (var r in t) mf(e, r, { get: t[r], enumerable: !0 })
		},
		Qle = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Xle(t))
					!Yle.call(e, i) &&
						i !== r &&
						mf(e, i, {
							get: () => t[i],
							enumerable: !(n = Wle(t, i)) || n.enumerable,
						})
			return e
		},
		Zle = (e) => Qle(mf({}, '__esModule', { value: !0 }), e),
		FM = {}
	Jle(FM, {
		EventStreamMarshaller: () => UM,
		eventStreamSerdeProvider: () => ede,
	})
	GM.exports = Zle(FM)
	var Al = LM()
	function MM(e) {
		let t = 0,
			r = 0,
			n = null,
			i = null,
			o = ua((c) => {
				if (typeof c != 'number')
					throw new Error(
						'Attempted to allocate an event message where size was not a number: ' +
							c,
					)
				;(t = c),
					(r = 4),
					(n = new Uint8Array(c)),
					new DataView(n.buffer).setUint32(0, c, !1)
			}, 'allocateMessage'),
			s = ua(async function* () {
				let c = e[Symbol.asyncIterator]()
				for (;;) {
					let { value: l, done: u } = await c.next()
					if (u) {
						if (t)
							if (t === r) yield n
							else throw new Error('Truncated event message received.')
						else return
						return
					}
					let m = l.length,
						f = 0
					for (; f < m; ) {
						if (!n) {
							let g = m - f
							i || (i = new Uint8Array(4))
							let v = Math.min(4 - r, g)
							if ((i.set(l.slice(f, f + v), r), (r += v), (f += v), r < 4))
								break
							o(new DataView(i.buffer).getUint32(0, !1)), (i = null)
						}
						let p = Math.min(t - r, m - f)
						n.set(l.slice(f, f + p), r),
							(r += p),
							(f += p),
							t && t === r && (yield n, (n = null), (t = 0), (r = 0))
					}
				}
			}, 'iterator')
		return { [Symbol.asyncIterator]: s }
	}
	ua(MM, 'getChunkedStream')
	function qM(e, t) {
		return async function (r) {
			let { value: n } = r.headers[':message-type']
			if (n === 'error') {
				let i = new Error(r.headers[':error-message'].value || 'UnknownError')
				throw ((i.name = r.headers[':error-code'].value), i)
			} else if (n === 'exception') {
				let i = r.headers[':exception-type'].value,
					o = { [i]: r },
					s = await e(o)
				if (s.$unknown) {
					let c = new Error(t(r.body))
					throw ((c.name = i), c)
				}
				throw s[i]
			} else if (n === 'event') {
				let i = { [r.headers[':event-type'].value]: r },
					o = await e(i)
				return o.$unknown ? void 0 : o
			} else
				throw Error(
					`Unrecognizable event type: ${r.headers[':event-type'].value}`,
				)
		}
	}
	ua(qM, 'getMessageUnmarshaller')
	var jM = class {
		constructor({ utf8Encoder: t, utf8Decoder: r }) {
			;(this.eventStreamCodec = new Al.EventStreamCodec(t, r)),
				(this.utfEncoder = t)
		}
		deserialize(t, r) {
			let n = MM(t)
			return new Al.SmithyMessageDecoderStream({
				messageStream: new Al.MessageDecoderStream({
					inputStream: n,
					decoder: this.eventStreamCodec,
				}),
				deserializer: qM(r, this.utfEncoder),
			})
		}
		serialize(t, r) {
			return new Al.MessageEncoderStream({
				messageStream: new Al.SmithyMessageEncoderStream({
					inputStream: t,
					serializer: r,
				}),
				encoder: this.eventStreamCodec,
				includeEndFrame: !0,
			})
		}
	}
	ua(jM, 'EventStreamMarshaller')
	var UM = jM,
		ede = ua((e) => new UM(e), 'eventStreamSerdeProvider')
})
var XM = E((tBe, WM) => {
	var ff = Object.defineProperty,
		tde = Object.getOwnPropertyDescriptor,
		rde = Object.getOwnPropertyNames,
		nde = Object.prototype.hasOwnProperty,
		Ey = (e, t) => ff(e, 'name', { value: t, configurable: !0 }),
		ide = (e, t) => {
			for (var r in t) ff(e, r, { get: t[r], enumerable: !0 })
		},
		ode = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of rde(t))
					!nde.call(e, i) &&
						i !== r &&
						ff(e, i, {
							get: () => t[i],
							enumerable: !(n = tde(t, i)) || n.enumerable,
						})
			return e
		},
		sde = (e) => ode(ff({}, '__esModule', { value: !0 }), e),
		HM = {}
	ide(HM, {
		EventStreamMarshaller: () => KM,
		eventStreamSerdeProvider: () => lde,
	})
	WM.exports = sde(HM)
	var ade = zM(),
		cde = require('stream')
	async function* $M(e) {
		let t = !1,
			r = !1,
			n = new Array()
		for (
			e.on('error', (i) => {
				if ((t || (t = !0), i)) throw i
			}),
				e.on('data', (i) => {
					n.push(i)
				}),
				e.on('end', () => {
					t = !0
				});
			!r;
		) {
			let i = await new Promise((o) => setTimeout(() => o(n.shift()), 0))
			i && (yield i), (r = t && n.length === 0)
		}
	}
	Ey($M, 'readabletoIterable')
	var VM = class {
		constructor({ utf8Encoder: t, utf8Decoder: r }) {
			this.universalMarshaller = new ade.EventStreamMarshaller({
				utf8Decoder: r,
				utf8Encoder: t,
			})
		}
		deserialize(t, r) {
			let n = typeof t[Symbol.asyncIterator] == 'function' ? t : $M(t)
			return this.universalMarshaller.deserialize(n, r)
		}
		serialize(t, r) {
			return cde.Readable.from(this.universalMarshaller.serialize(t, r))
		}
	}
	Ey(VM, 'EventStreamMarshaller')
	var KM = VM,
		lde = Ey((e) => new KM(e), 'eventStreamSerdeProvider')
})
var e1 = E((nBe, ZM) => {
	var pf = Object.defineProperty,
		dde = Object.getOwnPropertyDescriptor,
		ude = Object.getOwnPropertyNames,
		mde = Object.prototype.hasOwnProperty,
		gf = (e, t) => pf(e, 'name', { value: t, configurable: !0 }),
		fde = (e, t) => {
			for (var r in t) pf(e, r, { get: t[r], enumerable: !0 })
		},
		pde = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of ude(t))
					!mde.call(e, i) &&
						i !== r &&
						pf(e, i, {
							get: () => t[i],
							enumerable: !(n = dde(t, i)) || n.enumerable,
						})
			return e
		},
		gde = (e) => pde(pf({}, '__esModule', { value: !0 }), e),
		YM = {}
	fde(YM, { fileStreamHasher: () => yde, readableStreamHasher: () => Cde })
	ZM.exports = gde(YM)
	var vde = require('fs'),
		hde = rr(),
		_de = require('stream'),
		JM = class extends _de.Writable {
			constructor(t, r) {
				super(r), (this.hash = t)
			}
			_write(t, r, n) {
				try {
					this.hash.update((0, hde.toUint8Array)(t))
				} catch (i) {
					return n(i)
				}
				n()
			}
		}
	gf(JM, 'HashCalculator')
	var QM = JM,
		yde = gf(
			(e, t) =>
				new Promise((r, n) => {
					if (!Sde(t)) {
						n(new Error('Unable to calculate hash for non-file streams.'))
						return
					}
					let i = (0, vde.createReadStream)(t.path, {
							start: t.start,
							end: t.end,
						}),
						o = new e(),
						s = new QM(o)
					i.pipe(s),
						i.on('error', (c) => {
							s.end(), n(c)
						}),
						s.on('error', n),
						s.on('finish', function () {
							o.digest().then(r).catch(n)
						})
				}),
			'fileStreamHasher',
		),
		Sde = gf((e) => typeof e.path == 'string', 'isReadStream'),
		Cde = gf((e, t) => {
			if (t.readableFlowing !== null)
				throw new Error('Unable to calculate hash for flowing readable stream')
			let r = new e(),
				n = new QM(r)
			return (
				t.pipe(n),
				new Promise((i, o) => {
					t.on('error', (s) => {
						n.end(), o(s)
					}),
						n.on('error', o),
						n.on('finish', () => {
							r.digest().then(i).catch(o)
						})
				})
			)
		}, 'readableStreamHasher')
})
var o1 = E((vf) => {
	'use strict'
	Object.defineProperty(vf, '__esModule', { value: !0 })
	vf.getRuntimeConfig = void 0
	var t1 = (zt(), ve(Gt)),
		Ede = lh(),
		bde = ze(),
		wde = po(),
		r1 = gi(),
		n1 = Rc(),
		i1 = rr(),
		xde = zh(),
		Pde = Uh(),
		Ade = (e) => ({
			apiVersion: '2006-03-01',
			base64Decoder: e?.base64Decoder ?? r1.fromBase64,
			base64Encoder: e?.base64Encoder ?? r1.toBase64,
			disableHostPrefix: e?.disableHostPrefix ?? !1,
			endpointProvider: e?.endpointProvider ?? Pde.defaultEndpointResolver,
			extensions: e?.extensions ?? [],
			getAwsChunkedEncodingStream:
				e?.getAwsChunkedEncodingStream ?? n1.getAwsChunkedEncodingStream,
			httpAuthSchemeProvider:
				e?.httpAuthSchemeProvider ?? xde.defaultS3HttpAuthSchemeProvider,
			httpAuthSchemes: e?.httpAuthSchemes ?? [
				{
					schemeId: 'aws.auth#sigv4',
					identityProvider: (t) => t.getIdentityProvider('aws.auth#sigv4'),
					signer: new t1.AwsSdkSigV4Signer(),
				},
				{
					schemeId: 'aws.auth#sigv4a',
					identityProvider: (t) => t.getIdentityProvider('aws.auth#sigv4a'),
					signer: new t1.AwsSdkSigV4ASigner(),
				},
			],
			logger: e?.logger ?? new bde.NoOpLogger(),
			sdkStreamMixin: e?.sdkStreamMixin ?? n1.sdkStreamMixin,
			serviceId: e?.serviceId ?? 'S3',
			signerConstructor: e?.signerConstructor ?? Ede.SignatureV4MultiRegion,
			signingEscapePath: e?.signingEscapePath ?? !1,
			urlParser: e?.urlParser ?? wde.parseUrl,
			useArnRegion: e?.useArnRegion ?? !1,
			utf8Decoder: e?.utf8Decoder ?? i1.fromUtf8,
			utf8Encoder: e?.utf8Encoder ?? i1.toUtf8,
		})
	vf.getRuntimeConfig = Ade
})
var l1 = E((_f) => {
	'use strict'
	Object.defineProperty(_f, '__esModule', { value: !0 })
	_f.getRuntimeConfig = void 0
	var Ode = (Rn(), ve(On)),
		Rde = Ode.__importDefault(eT()),
		s1 = (zt(), ve(Gt)),
		kde = km(),
		Ide = tM(),
		Tde = re(),
		Bde = nl(),
		hf = wn(),
		Nde = XM(),
		by = il(),
		Dde = e1(),
		a1 = bn(),
		$i = Hn(),
		c1 = co(),
		Lde = ol(),
		Fde = Rs(),
		Mde = o1(),
		qde = ze(),
		jde = cl(),
		Ude = ze(),
		Gde = (e) => {
			;(0, Ude.emitWarningIfUnsupportedVersion)(process.version)
			let t = (0, jde.resolveDefaultsModeConfig)(e),
				r = () => t().then(qde.loadConfigsForDefaultMode),
				n = (0, Mde.getRuntimeConfig)(e)
			return (
				(0, s1.emitWarningIfUnsupportedVersion)(process.version),
				{
					...n,
					...e,
					runtime: 'node',
					defaultsMode: t,
					bodyLengthChecker: e?.bodyLengthChecker ?? Lde.calculateBodyLength,
					credentialDefaultProvider:
						e?.credentialDefaultProvider ?? kde.defaultProvider,
					defaultUserAgentProvider:
						e?.defaultUserAgentProvider ??
						(0, Bde.defaultUserAgent)({
							serviceId: n.serviceId,
							clientVersion: Rde.default.version,
						}),
					disableS3ExpressSessionAuth:
						e?.disableS3ExpressSessionAuth ??
						(0, $i.loadConfig)(
							Tde.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS,
						),
					eventStreamSerdeProvider:
						e?.eventStreamSerdeProvider ?? Nde.eventStreamSerdeProvider,
					maxAttempts:
						e?.maxAttempts ??
						(0, $i.loadConfig)(a1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
					md5: e?.md5 ?? by.Hash.bind(null, 'md5'),
					region:
						e?.region ??
						(0, $i.loadConfig)(
							hf.NODE_REGION_CONFIG_OPTIONS,
							hf.NODE_REGION_CONFIG_FILE_OPTIONS,
						),
					requestHandler: c1.NodeHttpHandler.create(e?.requestHandler ?? r),
					retryMode:
						e?.retryMode ??
						(0, $i.loadConfig)({
							...a1.NODE_RETRY_MODE_CONFIG_OPTIONS,
							default: async () =>
								(await r()).retryMode || Fde.DEFAULT_RETRY_MODE,
						}),
					sha1: e?.sha1 ?? by.Hash.bind(null, 'sha1'),
					sha256: e?.sha256 ?? by.Hash.bind(null, 'sha256'),
					sigv4aSigningRegionSet:
						e?.sigv4aSigningRegionSet ??
						(0, $i.loadConfig)(s1.NODE_SIGV4A_CONFIG_OPTIONS),
					streamCollector: e?.streamCollector ?? c1.streamCollector,
					streamHasher: e?.streamHasher ?? Dde.readableStreamHasher,
					useArnRegion:
						e?.useArnRegion ??
						(0, $i.loadConfig)(Ide.NODE_USE_ARN_REGION_CONFIG_OPTIONS),
					useDualstackEndpoint:
						e?.useDualstackEndpoint ??
						(0, $i.loadConfig)(hf.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
					useFipsEndpoint:
						e?.useFipsEndpoint ??
						(0, $i.loadConfig)(hf.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
				}
			)
		}
	_f.getRuntimeConfig = Gde
})
var f1 = E((sBe, m1) => {
	'use strict'
	var yf = Object.defineProperty,
		zde = Object.getOwnPropertyDescriptor,
		Hde = Object.getOwnPropertyNames,
		$de = Object.prototype.hasOwnProperty,
		wy = (e, t) => yf(e, 'name', { value: t, configurable: !0 }),
		Vde = (e, t) => {
			for (var r in t) yf(e, r, { get: t[r], enumerable: !0 })
		},
		Kde = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Hde(t))
					!$de.call(e, i) &&
						i !== r &&
						yf(e, i, {
							get: () => t[i],
							enumerable: !(n = zde(t, i)) || n.enumerable,
						})
			return e
		},
		Wde = (e) => Kde(yf({}, '__esModule', { value: !0 }), e),
		d1 = {}
	Vde(d1, {
		getSsecPlugin: () => Xde,
		isValidBase64EncodedSSECustomerKey: () => Py,
		ssecMiddleware: () => xy,
		ssecMiddlewareOptions: () => u1,
	})
	m1.exports = Wde(d1)
	function xy(e) {
		return (t) => async (r) => {
			let n = { ...r.input },
				i = [
					{ target: 'SSECustomerKey', hash: 'SSECustomerKeyMD5' },
					{
						target: 'CopySourceSSECustomerKey',
						hash: 'CopySourceSSECustomerKeyMD5',
					},
				]
			for (let o of i) {
				let s = n[o.target]
				if (s) {
					let c
					typeof s == 'string'
						? Py(s, e)
							? (c = e.base64Decoder(s))
							: ((c = e.utf8Decoder(s)), (n[o.target] = e.base64Encoder(c)))
						: ((c = ArrayBuffer.isView(s)
								? new Uint8Array(s.buffer, s.byteOffset, s.byteLength)
								: new Uint8Array(s)),
							(n[o.target] = e.base64Encoder(c)))
					let l = new e.md5()
					l.update(c), (n[o.hash] = e.base64Encoder(await l.digest()))
				}
			}
			return t({ ...r, input: n })
		}
	}
	wy(xy, 'ssecMiddleware')
	var u1 = {
			name: 'ssecMiddleware',
			step: 'initialize',
			tags: ['SSE'],
			override: !0,
		},
		Xde = wy(
			(e) => ({
				applyToStack: (t) => {
					t.add(xy(e), u1)
				},
			}),
			'getSsecPlugin',
		)
	function Py(e, t) {
		if (
			!/^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)
		)
			return !1
		try {
			return t.base64Decoder(e).length === 32
		} catch {
			return !1
		}
	}
	wy(Py, 'isValidBase64EncodedSSECustomerKey')
})
var _1 = E((aBe, h1) => {
	'use strict'
	var Sf = Object.defineProperty,
		Yde = Object.getOwnPropertyDescriptor,
		Jde = Object.getOwnPropertyNames,
		Qde = Object.prototype.hasOwnProperty,
		p1 = (e, t) => Sf(e, 'name', { value: t, configurable: !0 }),
		Zde = (e, t) => {
			for (var r in t) Sf(e, r, { get: t[r], enumerable: !0 })
		},
		eue = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Jde(t))
					!Qde.call(e, i) &&
						i !== r &&
						Sf(e, i, {
							get: () => t[i],
							enumerable: !(n = Yde(t, i)) || n.enumerable,
						})
			return e
		},
		tue = (e) => eue(Sf({}, '__esModule', { value: !0 }), e),
		g1 = {}
	Zde(g1, {
		getLocationConstraintPlugin: () => rue,
		locationConstraintMiddleware: () => Ay,
		locationConstraintMiddlewareOptions: () => v1,
	})
	h1.exports = tue(g1)
	function Ay(e) {
		return (t) => async (r) => {
			let { CreateBucketConfiguration: n } = r.input,
				i = await e.region()
			return (
				!n?.LocationConstraint &&
					!n?.Location &&
					(r = {
						...r,
						input: {
							...r.input,
							CreateBucketConfiguration:
								i === 'us-east-1' ? void 0 : { LocationConstraint: i },
						},
					}),
				t(r)
			)
		}
	}
	p1(Ay, 'locationConstraintMiddleware')
	var v1 = {
			step: 'initialize',
			tags: ['LOCATION_CONSTRAINT', 'CREATE_BUCKET_CONFIGURATION'],
			name: 'locationConstraintMiddleware',
			override: !0,
		},
		rue = p1(
			(e) => ({
				applyToStack: (t) => {
					t.add(Ay(e), v1)
				},
			}),
			'getLocationConstraintPlugin',
		)
})
var C1 = E((Cf) => {
	'use strict'
	Object.defineProperty(Cf, '__esModule', { value: !0 })
	Cf.AwsCrc32c = void 0
	var y1 = (Rn(), ve(On)),
		Oy = xl(),
		S1 = Ry(),
		nue = (function () {
			function e() {
				this.crc32c = new S1.Crc32c()
			}
			return (
				(e.prototype.update = function (t) {
					;(0, Oy.isEmptyData)(t) ||
						this.crc32c.update((0, Oy.convertToBuffer)(t))
				}),
				(e.prototype.digest = function () {
					return y1.__awaiter(this, void 0, void 0, function () {
						return y1.__generator(this, function (t) {
							return [2, (0, Oy.numToUint8)(this.crc32c.digest())]
						})
					})
				}),
				(e.prototype.reset = function () {
					this.crc32c = new S1.Crc32c()
				}),
				e
			)
		})()
	Cf.AwsCrc32c = nue
})
var Ry = E((Vi) => {
	'use strict'
	Object.defineProperty(Vi, '__esModule', { value: !0 })
	Vi.AwsCrc32c = Vi.Crc32c = Vi.crc32c = void 0
	var iue = (Rn(), ve(On)),
		oue = xl()
	function sue(e) {
		return new E1().update(e).digest()
	}
	Vi.crc32c = sue
	var E1 = (function () {
		function e() {
			this.checksum = 4294967295
		}
		return (
			(e.prototype.update = function (t) {
				var r, n
				try {
					for (var i = iue.__values(t), o = i.next(); !o.done; o = i.next()) {
						var s = o.value
						this.checksum =
							(this.checksum >>> 8) ^ cue[(this.checksum ^ s) & 255]
					}
				} catch (c) {
					r = { error: c }
				} finally {
					try {
						o && !o.done && (n = i.return) && n.call(i)
					} finally {
						if (r) throw r.error
					}
				}
				return this
			}),
			(e.prototype.digest = function () {
				return (this.checksum ^ 4294967295) >>> 0
			}),
			e
		)
	})()
	Vi.Crc32c = E1
	var aue = [
			0, 4067132163, 3778769143, 324072436, 3348797215, 904991772, 648144872,
			3570033899, 2329499855, 2024987596, 1809983544, 2575936315, 1296289744,
			3207089363, 2893594407, 1578318884, 274646895, 3795141740, 4049975192,
			51262619, 3619967088, 632279923, 922689671, 3298075524, 2592579488,
			1760304291, 2075979607, 2312596564, 1562183871, 2943781820, 3156637768,
			1313733451, 549293790, 3537243613, 3246849577, 871202090, 3878099393,
			357341890, 102525238, 4101499445, 2858735121, 1477399826, 1264559846,
			3107202533, 1845379342, 2677391885, 2361733625, 2125378298, 820201905,
			3263744690, 3520608582, 598981189, 4151959214, 85089709, 373468761,
			3827903834, 3124367742, 1213305469, 1526817161, 2842354314, 2107672161,
			2412447074, 2627466902, 1861252501, 1098587580, 3004210879, 2688576843,
			1378610760, 2262928035, 1955203488, 1742404180, 2511436119, 3416409459,
			969524848, 714683780, 3639785095, 205050476, 4266873199, 3976438427,
			526918040, 1361435347, 2739821008, 2954799652, 1114974503, 2529119692,
			1691668175, 2005155131, 2247081528, 3690758684, 697762079, 986182379,
			3366744552, 476452099, 3993867776, 4250756596, 255256311, 1640403810,
			2477592673, 2164122517, 1922457750, 2791048317, 1412925310, 1197962378,
			3037525897, 3944729517, 427051182, 170179418, 4165941337, 746937522,
			3740196785, 3451792453, 1070968646, 1905808397, 2213795598, 2426610938,
			1657317369, 3053634322, 1147748369, 1463399397, 2773627110, 4215344322,
			153784257, 444234805, 3893493558, 1021025245, 3467647198, 3722505002,
			797665321, 2197175160, 1889384571, 1674398607, 2443626636, 1164749927,
			3070701412, 2757221520, 1446797203, 137323447, 4198817972, 3910406976,
			461344835, 3484808360, 1037989803, 781091935, 3705997148, 2460548119,
			1623424788, 1939049696, 2180517859, 1429367560, 2807687179, 3020495871,
			1180866812, 410100952, 3927582683, 4182430767, 186734380, 3756733383,
			763408580, 1053836080, 3434856499, 2722870694, 1344288421, 1131464017,
			2971354706, 1708204729, 2545590714, 2229949006, 1988219213, 680717673,
			3673779818, 3383336350, 1002577565, 4010310262, 493091189, 238226049,
			4233660802, 2987750089, 1082061258, 1395524158, 2705686845, 1972364758,
			2279892693, 2494862625, 1725896226, 952904198, 3399985413, 3656866545,
			731699698, 4283874585, 222117402, 510512622, 3959836397, 3280807620,
			837199303, 582374963, 3504198960, 68661723, 4135334616, 3844915500,
			390545967, 1230274059, 3141532936, 2825850620, 1510247935, 2395924756,
			2091215383, 1878366691, 2644384480, 3553878443, 565732008, 854102364,
			3229815391, 340358836, 3861050807, 4117890627, 119113024, 1493875044,
			2875275879, 3090270611, 1247431312, 2660249211, 1828433272, 2141937292,
			2378227087, 3811616794, 291187481, 34330861, 4032846830, 615137029,
			3603020806, 3314634738, 939183345, 1776939221, 2609017814, 2295496738,
			2058945313, 2926798794, 1545135305, 1330124605, 3173225534, 4084100981,
			17165430, 307568514, 3762199681, 888469610, 3332340585, 3587147933,
			665062302, 2042050490, 2346497209, 2559330125, 1793573966, 3190661285,
			1279665062, 1595330642, 2910671697,
		],
		cue = (0, oue.uint32ArrayFrom)(aue),
		lue = C1()
	Object.defineProperty(Vi, 'AwsCrc32c', {
		enumerable: !0,
		get: function () {
			return lue.AwsCrc32c
		},
	})
})
var b1 = E((Ef) => {
	'use strict'
	Object.defineProperty(Ef, '__esModule', { value: !0 })
	Ef.createReadStreamOnBuffer = void 0
	var due = require('stream')
	function uue(e) {
		let t = new due.Transform()
		return t.push(e), t.push(null), t
	}
	Ef.createReadStreamOnBuffer = uue
})
var F1 = E((uBe, L1) => {
	'use strict'
	var bf = Object.defineProperty,
		mue = Object.getOwnPropertyDescriptor,
		fue = Object.getOwnPropertyNames,
		pue = Object.prototype.hasOwnProperty,
		Or = (e, t) => bf(e, 'name', { value: t, configurable: !0 }),
		gue = (e, t) => {
			for (var r in t) bf(e, r, { get: t[r], enumerable: !0 })
		},
		vue = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of fue(t))
					!pue.call(e, i) &&
						i !== r &&
						bf(e, i, {
							get: () => t[i],
							enumerable: !(n = mue(t, i)) || n.enumerable,
						})
			return e
		},
		hue = (e) => vue(bf({}, '__esModule', { value: !0 }), e),
		x1 = {}
	gue(x1, {
		ChecksumAlgorithm: () => P1,
		ChecksumLocation: () => A1,
		DEFAULT_CHECKSUM_ALGORITHM: () => O1,
		S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM: () => R1,
		flexibleChecksumsMiddleware: () => N1,
		flexibleChecksumsMiddlewareOptions: () => B1,
		getFlexibleChecksumsPlugin: () => kue,
	})
	L1.exports = hue(x1)
	var P1 = ((e) => (
			(e.MD5 = 'MD5'),
			(e.CRC32 = 'CRC32'),
			(e.CRC32C = 'CRC32C'),
			(e.SHA1 = 'SHA1'),
			(e.SHA256 = 'SHA256'),
			e
		))(P1 || {}),
		A1 = ((e) => ((e.HEADER = 'header'), (e.TRAILER = 'trailer'), e))(A1 || {}),
		O1 = 'MD5',
		R1 = 'CRC32',
		k1 = Xe(),
		ky = ['CRC32', 'CRC32C', 'SHA1', 'SHA256'],
		_ue = ['CRC32', 'CRC32C', 'SHA1', 'SHA256'],
		yue = Or(
			(e, { requestChecksumRequired: t, requestAlgorithmMember: r }, n) => {
				let i = n ? R1 : O1
				if (!r || !e[r]) return t ? i : void 0
				let o = e[r]
				if (!ky.includes(o))
					throw new Error(
						`The checksum algorithm "${o}" is not supported by the client. Select one of ${ky}.`,
					)
				return o
			},
			'getChecksumAlgorithmForRequest',
		),
		Iy = Or(
			(e) =>
				e === 'MD5' ? 'content-md5' : `x-amz-checksum-${e.toLowerCase()}`,
			'getChecksumLocationName',
		),
		Sue = Or((e, t) => {
			let r = e.toLowerCase()
			for (let n of Object.keys(t)) if (r === n.toLowerCase()) return !0
			return !1
		}, 'hasHeader'),
		Cue = dd(),
		Ty = Or(
			(e) =>
				e !== void 0 &&
				typeof e != 'string' &&
				!ArrayBuffer.isView(e) &&
				!(0, Cue.isArrayBuffer)(e),
			'isStreaming',
		),
		Eue = Pl(),
		bue = Ry(),
		I1 = Or(
			(e, t) =>
				({
					MD5: t.md5,
					CRC32: Eue.AwsCrc32,
					CRC32C: bue.AwsCrc32c,
					SHA1: t.sha1,
					SHA256: t.sha256,
				})[e],
			'selectChecksumAlgorithmFunction',
		),
		wue = rr(),
		T1 = Or((e, t) => {
			let r = new e()
			return r.update((0, wue.toUint8Array)(t || '')), r.digest()
		}, 'stringHasher'),
		B1 = {
			name: 'flexibleChecksumsMiddleware',
			step: 'build',
			tags: ['BODY_CHECKSUM'],
			override: !0,
		},
		N1 = Or(
			(e, t) => (r, n) => async (i) => {
				if (!k1.HttpRequest.isInstance(i.request)) return r(i)
				let { request: o } = i,
					{ body: s, headers: c } = o,
					{ base64Encoder: l, streamHasher: u } = e,
					{
						input: m,
						requestChecksumRequired: f,
						requestAlgorithmMember: p,
					} = t,
					g = yue(
						m,
						{ requestChecksumRequired: f, requestAlgorithmMember: p },
						!!n.isS3ExpressBucket,
					),
					v = s,
					_ = c
				if (g) {
					let P = Iy(g),
						x = I1(g, e)
					if (Ty(s)) {
						let { getAwsChunkedEncodingStream: W, bodyLengthChecker: X } = e
						;(v = W(s, {
							base64Encoder: l,
							bodyLengthChecker: X,
							checksumLocationName: P,
							checksumAlgorithmFn: x,
							streamHasher: u,
						})),
							(_ = {
								...c,
								'content-encoding': c['content-encoding']
									? `${c['content-encoding']},aws-chunked`
									: 'aws-chunked',
								'transfer-encoding': 'chunked',
								'x-amz-decoded-content-length': c['content-length'],
								'x-amz-content-sha256': 'STREAMING-UNSIGNED-PAYLOAD-TRAILER',
								'x-amz-trailer': P,
							}),
							delete _['content-length']
					} else if (!Sue(P, c)) {
						let W = await T1(x, s)
						_ = { ...c, [P]: l(W) }
					}
				}
				return await r({ ...i, request: { ...o, headers: _, body: v } })
			},
			'flexibleChecksumsMiddleware',
		),
		D1 = Or((e = []) => {
			let t = []
			for (let r of _ue) !e.includes(r) || !ky.includes(r) || t.push(r)
			return t
		}, 'getChecksumAlgorithmListForResponse'),
		xue = Or((e) => {
			let t = e.lastIndexOf('-')
			if (t !== -1) {
				let r = e.slice(t + 1)
				if (!r.startsWith('0')) {
					let n = parseInt(r, 10)
					if (!isNaN(n) && n >= 1 && n <= 1e4) return !0
				}
			}
			return !1
		}, 'isChecksumWithPartNumber'),
		w1 = b1(),
		Pue = Or(
			async (
				e,
				{ streamHasher: t, checksumAlgorithmFn: r, base64Encoder: n },
			) => {
				let i = Ty(e) ? t(r, e) : T1(r, e)
				return n(await i)
			},
			'getChecksum',
		),
		Aue = Or(async (e, { config: t, responseAlgorithms: r }) => {
			let n = D1(r),
				{ body: i, headers: o } = e
			for (let s of n) {
				let c = Iy(s),
					l = o[c]
				if (l) {
					let u = I1(s, t),
						{ streamHasher: m, base64Encoder: f } = t,
						p = await Pue(i, {
							streamHasher: m,
							checksumAlgorithmFn: u,
							base64Encoder: f,
						})
					if (p === l) break
					throw new Error(
						`Checksum mismatch: expected "${p}" but received "${l}" in response header "${c}".`,
					)
				}
			}
		}, 'validateChecksumFromResponse'),
		Oue = {
			name: 'flexibleChecksumsResponseMiddleware',
			toMiddleware: 'deserializerMiddleware',
			relation: 'after',
			tags: ['BODY_CHECKSUM'],
			override: !0,
		},
		Rue = Or(
			(e, t) => (r, n) => async (i) => {
				if (!k1.HttpRequest.isInstance(i.request)) return r(i)
				let o = i.input,
					s = await r(i),
					c = s.response,
					l,
					{ requestValidationModeMember: u, responseAlgorithms: m } = t
				if (u && o[u] === 'ENABLED') {
					let { clientName: f, commandName: p } = n
					if (
						f === 'S3Client' &&
						p === 'GetObjectCommand' &&
						D1(m).every((_) => {
							let y = Iy(_),
								P = c.headers[y]
							return !P || xue(P)
						})
					)
						return s
					let v = Ty(c.body)
					v &&
						((l = await e.streamCollector(c.body)),
						(c.body = (0, w1.createReadStreamOnBuffer)(l))),
						await Aue(s.response, { config: e, responseAlgorithms: m }),
						v && l && (c.body = (0, w1.createReadStreamOnBuffer)(l))
				}
				return s
			},
			'flexibleChecksumsResponseMiddleware',
		),
		kue = Or(
			(e, t) => ({
				applyToStack: (r) => {
					r.add(N1(e, t), B1), r.addRelativeTo(Rue(e, t), Oue)
				},
			}),
			'getFlexibleChecksumsPlugin',
		)
})
var z1 = E((mBe, G1) => {
	var wf = Object.defineProperty,
		Iue = Object.getOwnPropertyDescriptor,
		Tue = Object.getOwnPropertyNames,
		Bue = Object.prototype.hasOwnProperty,
		ni = (e, t) => wf(e, 'name', { value: t, configurable: !0 }),
		Nue = (e, t) => {
			for (var r in t) wf(e, r, { get: t[r], enumerable: !0 })
		},
		Due = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of Tue(t))
					!Bue.call(e, i) &&
						i !== r &&
						wf(e, i, {
							get: () => t[i],
							enumerable: !(n = Iue(t, i)) || n.enumerable,
						})
			return e
		},
		Lue = (e) => Due(wf({}, '__esModule', { value: !0 }), e),
		q1 = {}
	Nue(q1, {
		WaiterState: () => U1,
		checkExceptions: () => Mue,
		createWaiter: () => zue,
		waiterServiceDefaults: () => j1,
	})
	G1.exports = Lue(q1)
	var Fue = ni((e) => new Promise((t) => setTimeout(t, e * 1e3)), 'sleep'),
		j1 = { minDelay: 2, maxDelay: 120 },
		U1 = ((e) => (
			(e.ABORTED = 'ABORTED'),
			(e.FAILURE = 'FAILURE'),
			(e.SUCCESS = 'SUCCESS'),
			(e.RETRY = 'RETRY'),
			(e.TIMEOUT = 'TIMEOUT'),
			e
		))(U1 || {}),
		Mue = ni((e) => {
			if (e.state === 'ABORTED') {
				let t = new Error(
					`${JSON.stringify({ ...e, reason: 'Request was aborted' })}`,
				)
				throw ((t.name = 'AbortError'), t)
			} else if (e.state === 'TIMEOUT') {
				let t = new Error(
					`${JSON.stringify({ ...e, reason: 'Waiter has timed out' })}`,
				)
				throw ((t.name = 'TimeoutError'), t)
			} else if (e.state !== 'SUCCESS') throw new Error(`${JSON.stringify(e)}`)
			return e
		}, 'checkExceptions'),
		que = ni((e, t, r, n) => {
			if (n > r) return t
			let i = e * 2 ** (n - 1)
			return jue(e, i)
		}, 'exponentialBackoffWithJitter'),
		jue = ni((e, t) => e + Math.random() * (t - e), 'randomInRange'),
		Uue = ni(
			async (
				{
					minDelay: e,
					maxDelay: t,
					maxWaitTime: r,
					abortController: n,
					client: i,
					abortSignal: o,
				},
				s,
				c,
			) => {
				var l
				let { state: u, reason: m } = await c(i, s)
				if (u !== 'RETRY') return { state: u, reason: m }
				let f = 1,
					p = Date.now() + r * 1e3,
					g = Math.log(t / e) / Math.log(2) + 1
				for (;;) {
					if (((l = n?.signal) != null && l.aborted) || o?.aborted)
						return { state: 'ABORTED' }
					let v = que(e, t, g, f)
					if (Date.now() + v * 1e3 > p) return { state: 'TIMEOUT' }
					await Fue(v)
					let { state: _, reason: y } = await c(i, s)
					if (_ !== 'RETRY') return { state: _, reason: y }
					f += 1
				}
			},
			'runPolling',
		),
		Gue = ni((e) => {
			if (e.maxWaitTime < 1)
				throw new Error(
					'WaiterConfiguration.maxWaitTime must be greater than 0',
				)
			if (e.minDelay < 1)
				throw new Error('WaiterConfiguration.minDelay must be greater than 0')
			if (e.maxDelay < 1)
				throw new Error('WaiterConfiguration.maxDelay must be greater than 0')
			if (e.maxWaitTime <= e.minDelay)
				throw new Error(
					`WaiterConfiguration.maxWaitTime [${e.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${e.minDelay}] for this waiter`,
				)
			if (e.maxDelay < e.minDelay)
				throw new Error(
					`WaiterConfiguration.maxDelay [${e.maxDelay}] must be greater than WaiterConfiguration.minDelay [${e.minDelay}] for this waiter`,
				)
		}, 'validateWaiterOptions'),
		M1 = ni(
			async (e) =>
				new Promise((t) => {
					let r = ni(() => t({ state: 'ABORTED' }), 'onAbort')
					typeof e.addEventListener == 'function'
						? e.addEventListener('abort', r)
						: (e.onabort = r)
				}),
			'abortTimeout',
		),
		zue = ni(async (e, t, r) => {
			let n = { ...j1, ...e }
			Gue(n)
			let i = [Uue(n, t, r)]
			return (
				e.abortController && i.push(M1(e.abortController.signal)),
				e.abortSignal && i.push(M1(e.abortSignal)),
				Promise.race(i)
			)
		}, 'createWaiter')
})
var bC = E((rDe, zH) => {
	'use strict'
	var bp = Object.defineProperty,
		Hue = Object.getOwnPropertyDescriptor,
		$ue = Object.getOwnPropertyNames,
		Vue = Object.prototype.hasOwnProperty,
		d = (e, t) => bp(e, 'name', { value: t, configurable: !0 }),
		Kue = (e, t) => {
			for (var r in t) bp(e, r, { get: t[r], enumerable: !0 })
		},
		Wue = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of $ue(t))
					!Vue.call(e, i) &&
						i !== r &&
						bp(e, i, {
							get: () => t[i],
							enumerable: !(n = Hue(t, i)) || n.enumerable,
						})
			return e
		},
		Xue = (e) => Wue(bp({}, '__esModule', { value: !0 }), e),
		hq = {}
	Kue(hq, {
		AbortMultipartUploadCommand: () => _2,
		AnalyticsFilter: () => ap,
		AnalyticsS3ExportFileFormat: () => xme,
		ArchiveStatus: () => tfe,
		BucketAccelerateStatus: () => sme,
		BucketAlreadyExists: () => Oq,
		BucketAlreadyOwnedByYou: () => Iq,
		BucketCannedACL: () => _me,
		BucketLocationConstraint: () => Eme,
		BucketLogsPermission: () => Dme,
		BucketType: () => Sme,
		BucketVersioningStatus: () => Wme,
		ChecksumAlgorithm: () => mme,
		ChecksumMode: () => Jme,
		CompleteMultipartUploadCommand: () => S2,
		CompleteMultipartUploadOutputFilterSensitiveLog: () => Hq,
		CompleteMultipartUploadRequestFilterSensitiveLog: () => $q,
		CompressionType: () => lfe,
		CopyObjectCommand: () => E2,
		CopyObjectOutputFilterSensitiveLog: () => Vq,
		CopyObjectRequestFilterSensitiveLog: () => Kq,
		CreateBucketCommand: () => w2,
		CreateMultipartUploadCommand: () => P2,
		CreateMultipartUploadOutputFilterSensitiveLog: () => Wq,
		CreateMultipartUploadRequestFilterSensitiveLog: () => Xq,
		CreateSessionCommand: () => _C,
		CreateSessionOutputFilterSensitiveLog: () => Jq,
		DataRedundancy: () => yme,
		DeleteBucketAnalyticsConfigurationCommand: () => O2,
		DeleteBucketCommand: () => k2,
		DeleteBucketCorsCommand: () => T2,
		DeleteBucketEncryptionCommand: () => N2,
		DeleteBucketIntelligentTieringConfigurationCommand: () => L2,
		DeleteBucketInventoryConfigurationCommand: () => M2,
		DeleteBucketLifecycleCommand: () => j2,
		DeleteBucketMetricsConfigurationCommand: () => G2,
		DeleteBucketOwnershipControlsCommand: () => H2,
		DeleteBucketPolicyCommand: () => V2,
		DeleteBucketReplicationCommand: () => W2,
		DeleteBucketTaggingCommand: () => Y2,
		DeleteBucketWebsiteCommand: () => Q2,
		DeleteMarkerReplicationStatus: () => qme,
		DeleteObjectCommand: () => eG,
		DeleteObjectTaggingCommand: () => iG,
		DeleteObjectsCommand: () => rG,
		DeletePublicAccessBlockCommand: () => sG,
		EncodingType: () => rfe,
		EncryptionFilterSensitiveLog: () => Cj,
		Event: () => Fme,
		ExistingObjectReplicationStatus: () => Gme,
		ExpirationStatus: () => Nme,
		ExpressionType: () => cfe,
		FileHeaderInfo: () => dfe,
		FilterRuleName: () => Mme,
		GetBucketAccelerateConfigurationCommand: () => cG,
		GetBucketAclCommand: () => dG,
		GetBucketAnalyticsConfigurationCommand: () => mG,
		GetBucketCorsCommand: () => pG,
		GetBucketEncryptionCommand: () => vG,
		GetBucketEncryptionOutputFilterSensitiveLog: () => ej,
		GetBucketIntelligentTieringConfigurationCommand: () => _G,
		GetBucketInventoryConfigurationCommand: () => SG,
		GetBucketInventoryConfigurationOutputFilterSensitiveLog: () => oj,
		GetBucketLifecycleConfigurationCommand: () => EG,
		GetBucketLocationCommand: () => wG,
		GetBucketLoggingCommand: () => PG,
		GetBucketMetricsConfigurationCommand: () => OG,
		GetBucketNotificationConfigurationCommand: () => kG,
		GetBucketOwnershipControlsCommand: () => TG,
		GetBucketPolicyCommand: () => NG,
		GetBucketPolicyStatusCommand: () => LG,
		GetBucketReplicationCommand: () => MG,
		GetBucketRequestPaymentCommand: () => jG,
		GetBucketTaggingCommand: () => GG,
		GetBucketVersioningCommand: () => HG,
		GetBucketWebsiteCommand: () => VG,
		GetObjectAclCommand: () => WG,
		GetObjectAttributesCommand: () => YG,
		GetObjectAttributesRequestFilterSensitiveLog: () => cj,
		GetObjectCommand: () => QG,
		GetObjectLegalHoldCommand: () => ez,
		GetObjectLockConfigurationCommand: () => rz,
		GetObjectOutputFilterSensitiveLog: () => sj,
		GetObjectRequestFilterSensitiveLog: () => aj,
		GetObjectRetentionCommand: () => iz,
		GetObjectTaggingCommand: () => sz,
		GetObjectTorrentCommand: () => cz,
		GetObjectTorrentOutputFilterSensitiveLog: () => lj,
		GetPublicAccessBlockCommand: () => dz,
		HeadBucketCommand: () => qp,
		HeadObjectCommand: () => jp,
		HeadObjectOutputFilterSensitiveLog: () => dj,
		HeadObjectRequestFilterSensitiveLog: () => uj,
		IntelligentTieringAccessTier: () => Ome,
		IntelligentTieringStatus: () => Ame,
		InvalidObjectState: () => Fq,
		InventoryConfigurationFilterSensitiveLog: () => wp,
		InventoryDestinationFilterSensitiveLog: () => ij,
		InventoryEncryptionFilterSensitiveLog: () => rj,
		InventoryFormat: () => Rme,
		InventoryFrequency: () => Tme,
		InventoryIncludedObjectVersions: () => kme,
		InventoryOptionalField: () => Ime,
		InventoryS3BucketDestinationFilterSensitiveLog: () => nj,
		JSONType: () => ufe,
		LifecycleRuleFilter: () => cp,
		ListBucketAnalyticsConfigurationsCommand: () => pz,
		ListBucketIntelligentTieringConfigurationsCommand: () => vz,
		ListBucketInventoryConfigurationsCommand: () => _z,
		ListBucketInventoryConfigurationsOutputFilterSensitiveLog: () => mj,
		ListBucketMetricsConfigurationsCommand: () => Sz,
		ListBucketsCommand: () => yC,
		ListDirectoryBucketsCommand: () => SC,
		ListMultipartUploadsCommand: () => wz,
		ListObjectVersionsCommand: () => Rz,
		ListObjectsCommand: () => Pz,
		ListObjectsV2Command: () => CC,
		ListPartsCommand: () => EC,
		ListPartsRequestFilterSensitiveLog: () => fj,
		LocationType: () => Cme,
		MFADelete: () => sfe,
		MFADeleteStatus: () => Kme,
		MetadataDirective: () => fme,
		MetricsFilter: () => lp,
		MetricsStatus: () => jme,
		NoSuchBucket: () => Nq,
		NoSuchKey: () => jq,
		NoSuchUpload: () => Eq,
		NotFound: () => zq,
		ObjectAlreadyInActiveTierError: () => _j,
		ObjectAttributes: () => Qme,
		ObjectCannedACL: () => ume,
		ObjectLockEnabled: () => Zme,
		ObjectLockLegalHoldStatus: () => pme,
		ObjectLockMode: () => gme,
		ObjectLockRetentionMode: () => efe,
		ObjectNotInActiveTierError: () => xq,
		ObjectOwnership: () => bme,
		ObjectStorageClass: () => nfe,
		ObjectVersionStorageClass: () => ofe,
		OptionalObjectAttributes: () => ife,
		OutputLocationFilterSensitiveLog: () => bj,
		OwnerOverride: () => lme,
		PartitionDateSource: () => Lme,
		Payer: () => Vme,
		Permission: () => cme,
		Protocol: () => Xme,
		PutBucketAccelerateConfigurationCommand: () => Tz,
		PutBucketAclCommand: () => Nz,
		PutBucketAnalyticsConfigurationCommand: () => Lz,
		PutBucketCorsCommand: () => Mz,
		PutBucketEncryptionCommand: () => jz,
		PutBucketEncryptionRequestFilterSensitiveLog: () => pj,
		PutBucketIntelligentTieringConfigurationCommand: () => Gz,
		PutBucketInventoryConfigurationCommand: () => Hz,
		PutBucketInventoryConfigurationRequestFilterSensitiveLog: () => gj,
		PutBucketLifecycleConfigurationCommand: () => Vz,
		PutBucketLoggingCommand: () => Wz,
		PutBucketMetricsConfigurationCommand: () => Yz,
		PutBucketNotificationConfigurationCommand: () => Qz,
		PutBucketOwnershipControlsCommand: () => eH,
		PutBucketPolicyCommand: () => rH,
		PutBucketReplicationCommand: () => iH,
		PutBucketRequestPaymentCommand: () => sH,
		PutBucketTaggingCommand: () => cH,
		PutBucketVersioningCommand: () => dH,
		PutBucketWebsiteCommand: () => mH,
		PutObjectAclCommand: () => pH,
		PutObjectCommand: () => vH,
		PutObjectLegalHoldCommand: () => _H,
		PutObjectLockConfigurationCommand: () => SH,
		PutObjectOutputFilterSensitiveLog: () => yj,
		PutObjectRequestFilterSensitiveLog: () => Sj,
		PutObjectRetentionCommand: () => EH,
		PutObjectTaggingCommand: () => wH,
		PutPublicAccessBlockCommand: () => PH,
		QuoteFields: () => mfe,
		ReplicaModificationsStatus: () => zme,
		ReplicationRuleFilter: () => dp,
		ReplicationRuleStatus: () => $me,
		ReplicationStatus: () => Yme,
		ReplicationTimeStatus: () => Ume,
		RequestCharged: () => ime,
		RequestPayer: () => ome,
		RestoreObjectCommand: () => OH,
		RestoreObjectRequestFilterSensitiveLog: () => xj,
		RestoreRequestFilterSensitiveLog: () => wj,
		RestoreRequestType: () => ffe,
		S3: () => MH,
		S3Client: () => hc,
		S3LocationFilterSensitiveLog: () => Ej,
		S3ServiceException: () => gn,
		SSEKMSFilterSensitiveLog: () => tj,
		SelectObjectContentCommand: () => kH,
		SelectObjectContentEventStream: () => sS,
		SelectObjectContentEventStreamFilterSensitiveLog: () => pfe,
		SelectObjectContentOutputFilterSensitiveLog: () => Pj,
		SelectObjectContentRequestFilterSensitiveLog: () => Aj,
		ServerSideEncryption: () => dme,
		ServerSideEncryptionByDefaultFilterSensitiveLog: () => Qq,
		ServerSideEncryptionConfigurationFilterSensitiveLog: () => zS,
		ServerSideEncryptionRuleFilterSensitiveLog: () => Zq,
		SessionCredentialsFilterSensitiveLog: () => Yq,
		SessionMode: () => wme,
		SseKmsEncryptedObjectsStatus: () => Hme,
		StorageClass: () => vme,
		StorageClassAnalysisSchemaVersion: () => Pme,
		TaggingDirective: () => hme,
		Tier: () => afe,
		TransitionStorageClass: () => Bme,
		Type: () => ame,
		UploadPartCommand: () => TH,
		UploadPartCopyCommand: () => NH,
		UploadPartCopyOutputFilterSensitiveLog: () => kj,
		UploadPartCopyRequestFilterSensitiveLog: () => Ij,
		UploadPartOutputFilterSensitiveLog: () => Oj,
		UploadPartRequestFilterSensitiveLog: () => Rj,
		WriteGetObjectResponseCommand: () => LH,
		WriteGetObjectResponseRequestFilterSensitiveLog: () => Tj,
		__Client: () => a.Client,
		paginateListBuckets: () => Ixe,
		paginateListDirectoryBuckets: () => Bxe,
		paginateListObjectsV2: () => Dxe,
		paginateListParts: () => Fxe,
		waitForBucketExists: () => Mxe,
		waitForBucketNotExists: () => jxe,
		waitForObjectExists: () => Gxe,
		waitForObjectNotExists: () => Hxe,
		waitUntilBucketExists: () => qxe,
		waitUntilBucketNotExists: () => Uxe,
		waitUntilObjectExists: () => zxe,
		waitUntilObjectNotExists: () => $xe,
	})
	zH.exports = Xue(hq)
	var Yue = gE(),
		H1 = bc(),
		Jue = wc(),
		Que = xc(),
		Ol = re(),
		$1 = Kc(),
		Zue = wn(),
		By = (Ut(), ve(ir)),
		eme = MO(),
		tme = Wc(),
		V1 = bn(),
		K1 = zh(),
		rme = re(),
		q = $n(),
		j = go(),
		nme = d(
			(e) => ({
				...e,
				useFipsEndpoint: e.useFipsEndpoint ?? !1,
				useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
				forcePathStyle: e.forcePathStyle ?? !1,
				useAccelerateEndpoint: e.useAccelerateEndpoint ?? !1,
				useGlobalEndpoint: e.useGlobalEndpoint ?? !1,
				disableMultiregionAccessPoints: e.disableMultiregionAccessPoints ?? !1,
				defaultSigningName: 's3',
			}),
			'resolveClientEndpointParameters',
		),
		U = {
			ForcePathStyle: { type: 'clientContextParams', name: 'forcePathStyle' },
			UseArnRegion: { type: 'clientContextParams', name: 'useArnRegion' },
			DisableMultiRegionAccessPoints: {
				type: 'clientContextParams',
				name: 'disableMultiregionAccessPoints',
			},
			Accelerate: {
				type: 'clientContextParams',
				name: 'useAccelerateEndpoint',
			},
			DisableS3ExpressSessionAuth: {
				type: 'clientContextParams',
				name: 'disableS3ExpressSessionAuth',
			},
			UseGlobalEndpoint: { type: 'builtInParams', name: 'useGlobalEndpoint' },
			UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
			Endpoint: { type: 'builtInParams', name: 'endpoint' },
			Region: { type: 'builtInParams', name: 'region' },
			UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
		},
		a = ze(),
		_q = class yq extends a.ServiceException {
			constructor(t) {
				super(t), Object.setPrototypeOf(this, yq.prototype)
			}
		}
	d(_q, 'S3ServiceException')
	var gn = _q,
		ime = { requester: 'requester' },
		ome = { requester: 'requester' },
		Sq = class Cq extends gn {
			constructor(t) {
				super({ name: 'NoSuchUpload', $fault: 'client', ...t }),
					(this.name = 'NoSuchUpload'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, Cq.prototype)
			}
		}
	d(Sq, 'NoSuchUpload')
	var Eq = Sq,
		sme = { Enabled: 'Enabled', Suspended: 'Suspended' },
		ame = {
			AmazonCustomerByEmail: 'AmazonCustomerByEmail',
			CanonicalUser: 'CanonicalUser',
			Group: 'Group',
		},
		cme = {
			FULL_CONTROL: 'FULL_CONTROL',
			READ: 'READ',
			READ_ACP: 'READ_ACP',
			WRITE: 'WRITE',
			WRITE_ACP: 'WRITE_ACP',
		},
		lme = { Destination: 'Destination' },
		dme = {
			AES256: 'AES256',
			aws_kms: 'aws:kms',
			aws_kms_dsse: 'aws:kms:dsse',
		},
		ume = {
			authenticated_read: 'authenticated-read',
			aws_exec_read: 'aws-exec-read',
			bucket_owner_full_control: 'bucket-owner-full-control',
			bucket_owner_read: 'bucket-owner-read',
			private: 'private',
			public_read: 'public-read',
			public_read_write: 'public-read-write',
		},
		mme = { CRC32: 'CRC32', CRC32C: 'CRC32C', SHA1: 'SHA1', SHA256: 'SHA256' },
		fme = { COPY: 'COPY', REPLACE: 'REPLACE' },
		pme = { OFF: 'OFF', ON: 'ON' },
		gme = { COMPLIANCE: 'COMPLIANCE', GOVERNANCE: 'GOVERNANCE' },
		vme = {
			DEEP_ARCHIVE: 'DEEP_ARCHIVE',
			EXPRESS_ONEZONE: 'EXPRESS_ONEZONE',
			GLACIER: 'GLACIER',
			GLACIER_IR: 'GLACIER_IR',
			INTELLIGENT_TIERING: 'INTELLIGENT_TIERING',
			ONEZONE_IA: 'ONEZONE_IA',
			OUTPOSTS: 'OUTPOSTS',
			REDUCED_REDUNDANCY: 'REDUCED_REDUNDANCY',
			SNOW: 'SNOW',
			STANDARD: 'STANDARD',
			STANDARD_IA: 'STANDARD_IA',
		},
		hme = { COPY: 'COPY', REPLACE: 'REPLACE' },
		bq = class wq extends gn {
			constructor(t) {
				super({ name: 'ObjectNotInActiveTierError', $fault: 'client', ...t }),
					(this.name = 'ObjectNotInActiveTierError'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, wq.prototype)
			}
		}
	d(bq, 'ObjectNotInActiveTierError')
	var xq = bq,
		Pq = class Aq extends gn {
			constructor(t) {
				super({ name: 'BucketAlreadyExists', $fault: 'client', ...t }),
					(this.name = 'BucketAlreadyExists'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, Aq.prototype)
			}
		}
	d(Pq, 'BucketAlreadyExists')
	var Oq = Pq,
		Rq = class kq extends gn {
			constructor(t) {
				super({ name: 'BucketAlreadyOwnedByYou', $fault: 'client', ...t }),
					(this.name = 'BucketAlreadyOwnedByYou'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, kq.prototype)
			}
		}
	d(Rq, 'BucketAlreadyOwnedByYou')
	var Iq = Rq,
		_me = {
			authenticated_read: 'authenticated-read',
			private: 'private',
			public_read: 'public-read',
			public_read_write: 'public-read-write',
		},
		yme = { SingleAvailabilityZone: 'SingleAvailabilityZone' },
		Sme = { Directory: 'Directory' },
		Cme = { AvailabilityZone: 'AvailabilityZone' },
		Eme = {
			EU: 'EU',
			af_south_1: 'af-south-1',
			ap_east_1: 'ap-east-1',
			ap_northeast_1: 'ap-northeast-1',
			ap_northeast_2: 'ap-northeast-2',
			ap_northeast_3: 'ap-northeast-3',
			ap_south_1: 'ap-south-1',
			ap_south_2: 'ap-south-2',
			ap_southeast_1: 'ap-southeast-1',
			ap_southeast_2: 'ap-southeast-2',
			ap_southeast_3: 'ap-southeast-3',
			ca_central_1: 'ca-central-1',
			cn_north_1: 'cn-north-1',
			cn_northwest_1: 'cn-northwest-1',
			eu_central_1: 'eu-central-1',
			eu_north_1: 'eu-north-1',
			eu_south_1: 'eu-south-1',
			eu_south_2: 'eu-south-2',
			eu_west_1: 'eu-west-1',
			eu_west_2: 'eu-west-2',
			eu_west_3: 'eu-west-3',
			me_south_1: 'me-south-1',
			sa_east_1: 'sa-east-1',
			us_east_2: 'us-east-2',
			us_gov_east_1: 'us-gov-east-1',
			us_gov_west_1: 'us-gov-west-1',
			us_west_1: 'us-west-1',
			us_west_2: 'us-west-2',
		},
		bme = {
			BucketOwnerEnforced: 'BucketOwnerEnforced',
			BucketOwnerPreferred: 'BucketOwnerPreferred',
			ObjectWriter: 'ObjectWriter',
		},
		wme = { ReadOnly: 'ReadOnly', ReadWrite: 'ReadWrite' },
		Tq = class Bq extends gn {
			constructor(t) {
				super({ name: 'NoSuchBucket', $fault: 'client', ...t }),
					(this.name = 'NoSuchBucket'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, Bq.prototype)
			}
		}
	d(Tq, 'NoSuchBucket')
	var Nq = Tq,
		ap
	;((e) => {
		e.visit = d(
			(t, r) =>
				t.Prefix !== void 0
					? r.Prefix(t.Prefix)
					: t.Tag !== void 0
						? r.Tag(t.Tag)
						: t.And !== void 0
							? r.And(t.And)
							: r._(t.$unknown[0], t.$unknown[1]),
			'visit',
		)
	})(ap || (ap = {}))
	var xme = { CSV: 'CSV' },
		Pme = { V_1: 'V_1' },
		Ame = { Disabled: 'Disabled', Enabled: 'Enabled' },
		Ome = {
			ARCHIVE_ACCESS: 'ARCHIVE_ACCESS',
			DEEP_ARCHIVE_ACCESS: 'DEEP_ARCHIVE_ACCESS',
		},
		Rme = { CSV: 'CSV', ORC: 'ORC', Parquet: 'Parquet' },
		kme = { All: 'All', Current: 'Current' },
		Ime = {
			BucketKeyStatus: 'BucketKeyStatus',
			ChecksumAlgorithm: 'ChecksumAlgorithm',
			ETag: 'ETag',
			EncryptionStatus: 'EncryptionStatus',
			IntelligentTieringAccessTier: 'IntelligentTieringAccessTier',
			IsMultipartUploaded: 'IsMultipartUploaded',
			LastModifiedDate: 'LastModifiedDate',
			ObjectAccessControlList: 'ObjectAccessControlList',
			ObjectLockLegalHoldStatus: 'ObjectLockLegalHoldStatus',
			ObjectLockMode: 'ObjectLockMode',
			ObjectLockRetainUntilDate: 'ObjectLockRetainUntilDate',
			ObjectOwner: 'ObjectOwner',
			ReplicationStatus: 'ReplicationStatus',
			Size: 'Size',
			StorageClass: 'StorageClass',
		},
		Tme = { Daily: 'Daily', Weekly: 'Weekly' },
		cp
	;((e) => {
		e.visit = d(
			(t, r) =>
				t.Prefix !== void 0
					? r.Prefix(t.Prefix)
					: t.Tag !== void 0
						? r.Tag(t.Tag)
						: t.ObjectSizeGreaterThan !== void 0
							? r.ObjectSizeGreaterThan(t.ObjectSizeGreaterThan)
							: t.ObjectSizeLessThan !== void 0
								? r.ObjectSizeLessThan(t.ObjectSizeLessThan)
								: t.And !== void 0
									? r.And(t.And)
									: r._(t.$unknown[0], t.$unknown[1]),
			'visit',
		)
	})(cp || (cp = {}))
	var Bme = {
			DEEP_ARCHIVE: 'DEEP_ARCHIVE',
			GLACIER: 'GLACIER',
			GLACIER_IR: 'GLACIER_IR',
			INTELLIGENT_TIERING: 'INTELLIGENT_TIERING',
			ONEZONE_IA: 'ONEZONE_IA',
			STANDARD_IA: 'STANDARD_IA',
		},
		Nme = { Disabled: 'Disabled', Enabled: 'Enabled' },
		Dme = { FULL_CONTROL: 'FULL_CONTROL', READ: 'READ', WRITE: 'WRITE' },
		Lme = { DeliveryTime: 'DeliveryTime', EventTime: 'EventTime' },
		lp
	;((e) => {
		e.visit = d(
			(t, r) =>
				t.Prefix !== void 0
					? r.Prefix(t.Prefix)
					: t.Tag !== void 0
						? r.Tag(t.Tag)
						: t.AccessPointArn !== void 0
							? r.AccessPointArn(t.AccessPointArn)
							: t.And !== void 0
								? r.And(t.And)
								: r._(t.$unknown[0], t.$unknown[1]),
			'visit',
		)
	})(lp || (lp = {}))
	var Fme = {
			s3_IntelligentTiering: 's3:IntelligentTiering',
			s3_LifecycleExpiration_: 's3:LifecycleExpiration:*',
			s3_LifecycleExpiration_Delete: 's3:LifecycleExpiration:Delete',
			s3_LifecycleExpiration_DeleteMarkerCreated:
				's3:LifecycleExpiration:DeleteMarkerCreated',
			s3_LifecycleTransition: 's3:LifecycleTransition',
			s3_ObjectAcl_Put: 's3:ObjectAcl:Put',
			s3_ObjectCreated_: 's3:ObjectCreated:*',
			s3_ObjectCreated_CompleteMultipartUpload:
				's3:ObjectCreated:CompleteMultipartUpload',
			s3_ObjectCreated_Copy: 's3:ObjectCreated:Copy',
			s3_ObjectCreated_Post: 's3:ObjectCreated:Post',
			s3_ObjectCreated_Put: 's3:ObjectCreated:Put',
			s3_ObjectRemoved_: 's3:ObjectRemoved:*',
			s3_ObjectRemoved_Delete: 's3:ObjectRemoved:Delete',
			s3_ObjectRemoved_DeleteMarkerCreated:
				's3:ObjectRemoved:DeleteMarkerCreated',
			s3_ObjectRestore_: 's3:ObjectRestore:*',
			s3_ObjectRestore_Completed: 's3:ObjectRestore:Completed',
			s3_ObjectRestore_Delete: 's3:ObjectRestore:Delete',
			s3_ObjectRestore_Post: 's3:ObjectRestore:Post',
			s3_ObjectTagging_: 's3:ObjectTagging:*',
			s3_ObjectTagging_Delete: 's3:ObjectTagging:Delete',
			s3_ObjectTagging_Put: 's3:ObjectTagging:Put',
			s3_ReducedRedundancyLostObject: 's3:ReducedRedundancyLostObject',
			s3_Replication_: 's3:Replication:*',
			s3_Replication_OperationFailedReplication:
				's3:Replication:OperationFailedReplication',
			s3_Replication_OperationMissedThreshold:
				's3:Replication:OperationMissedThreshold',
			s3_Replication_OperationNotTracked: 's3:Replication:OperationNotTracked',
			s3_Replication_OperationReplicatedAfterThreshold:
				's3:Replication:OperationReplicatedAfterThreshold',
		},
		Mme = { prefix: 'prefix', suffix: 'suffix' },
		qme = { Disabled: 'Disabled', Enabled: 'Enabled' },
		jme = { Disabled: 'Disabled', Enabled: 'Enabled' },
		Ume = { Disabled: 'Disabled', Enabled: 'Enabled' },
		Gme = { Disabled: 'Disabled', Enabled: 'Enabled' },
		dp
	;((e) => {
		e.visit = d(
			(t, r) =>
				t.Prefix !== void 0
					? r.Prefix(t.Prefix)
					: t.Tag !== void 0
						? r.Tag(t.Tag)
						: t.And !== void 0
							? r.And(t.And)
							: r._(t.$unknown[0], t.$unknown[1]),
			'visit',
		)
	})(dp || (dp = {}))
	var zme = { Disabled: 'Disabled', Enabled: 'Enabled' },
		Hme = { Disabled: 'Disabled', Enabled: 'Enabled' },
		$me = { Disabled: 'Disabled', Enabled: 'Enabled' },
		Vme = { BucketOwner: 'BucketOwner', Requester: 'Requester' },
		Kme = { Disabled: 'Disabled', Enabled: 'Enabled' },
		Wme = { Enabled: 'Enabled', Suspended: 'Suspended' },
		Xme = { http: 'http', https: 'https' },
		Yme = {
			COMPLETE: 'COMPLETE',
			COMPLETED: 'COMPLETED',
			FAILED: 'FAILED',
			PENDING: 'PENDING',
			REPLICA: 'REPLICA',
		},
		Jme = { ENABLED: 'ENABLED' },
		Dq = class Lq extends gn {
			constructor(t) {
				super({ name: 'InvalidObjectState', $fault: 'client', ...t }),
					(this.name = 'InvalidObjectState'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, Lq.prototype),
					(this.StorageClass = t.StorageClass),
					(this.AccessTier = t.AccessTier)
			}
		}
	d(Dq, 'InvalidObjectState')
	var Fq = Dq,
		Mq = class qq extends gn {
			constructor(t) {
				super({ name: 'NoSuchKey', $fault: 'client', ...t }),
					(this.name = 'NoSuchKey'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, qq.prototype)
			}
		}
	d(Mq, 'NoSuchKey')
	var jq = Mq,
		Qme = {
			CHECKSUM: 'Checksum',
			ETAG: 'ETag',
			OBJECT_PARTS: 'ObjectParts',
			OBJECT_SIZE: 'ObjectSize',
			STORAGE_CLASS: 'StorageClass',
		},
		Zme = { Enabled: 'Enabled' },
		efe = { COMPLIANCE: 'COMPLIANCE', GOVERNANCE: 'GOVERNANCE' },
		Uq = class Gq extends gn {
			constructor(t) {
				super({ name: 'NotFound', $fault: 'client', ...t }),
					(this.name = 'NotFound'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, Gq.prototype)
			}
		}
	d(Uq, 'NotFound')
	var zq = Uq,
		tfe = {
			ARCHIVE_ACCESS: 'ARCHIVE_ACCESS',
			DEEP_ARCHIVE_ACCESS: 'DEEP_ARCHIVE_ACCESS',
		},
		rfe = { url: 'url' },
		nfe = {
			DEEP_ARCHIVE: 'DEEP_ARCHIVE',
			EXPRESS_ONEZONE: 'EXPRESS_ONEZONE',
			GLACIER: 'GLACIER',
			GLACIER_IR: 'GLACIER_IR',
			INTELLIGENT_TIERING: 'INTELLIGENT_TIERING',
			ONEZONE_IA: 'ONEZONE_IA',
			OUTPOSTS: 'OUTPOSTS',
			REDUCED_REDUNDANCY: 'REDUCED_REDUNDANCY',
			SNOW: 'SNOW',
			STANDARD: 'STANDARD',
			STANDARD_IA: 'STANDARD_IA',
		},
		ife = { RESTORE_STATUS: 'RestoreStatus' },
		ofe = { STANDARD: 'STANDARD' },
		Hq = d(
			(e) => ({
				...e,
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
			}),
			'CompleteMultipartUploadOutputFilterSensitiveLog',
		),
		$q = d(
			(e) => ({
				...e,
				...(e.SSECustomerKey && { SSECustomerKey: a.SENSITIVE_STRING }),
			}),
			'CompleteMultipartUploadRequestFilterSensitiveLog',
		),
		Vq = d(
			(e) => ({
				...e,
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
				...(e.SSEKMSEncryptionContext && {
					SSEKMSEncryptionContext: a.SENSITIVE_STRING,
				}),
			}),
			'CopyObjectOutputFilterSensitiveLog',
		),
		Kq = d(
			(e) => ({
				...e,
				...(e.SSECustomerKey && { SSECustomerKey: a.SENSITIVE_STRING }),
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
				...(e.SSEKMSEncryptionContext && {
					SSEKMSEncryptionContext: a.SENSITIVE_STRING,
				}),
				...(e.CopySourceSSECustomerKey && {
					CopySourceSSECustomerKey: a.SENSITIVE_STRING,
				}),
			}),
			'CopyObjectRequestFilterSensitiveLog',
		),
		Wq = d(
			(e) => ({
				...e,
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
				...(e.SSEKMSEncryptionContext && {
					SSEKMSEncryptionContext: a.SENSITIVE_STRING,
				}),
			}),
			'CreateMultipartUploadOutputFilterSensitiveLog',
		),
		Xq = d(
			(e) => ({
				...e,
				...(e.SSECustomerKey && { SSECustomerKey: a.SENSITIVE_STRING }),
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
				...(e.SSEKMSEncryptionContext && {
					SSEKMSEncryptionContext: a.SENSITIVE_STRING,
				}),
			}),
			'CreateMultipartUploadRequestFilterSensitiveLog',
		),
		Yq = d(
			(e) => ({
				...e,
				...(e.SecretAccessKey && { SecretAccessKey: a.SENSITIVE_STRING }),
				...(e.SessionToken && { SessionToken: a.SENSITIVE_STRING }),
			}),
			'SessionCredentialsFilterSensitiveLog',
		),
		Jq = d(
			(e) => ({
				...e,
				...(e.Credentials && { Credentials: Yq(e.Credentials) }),
			}),
			'CreateSessionOutputFilterSensitiveLog',
		),
		Qq = d(
			(e) => ({
				...e,
				...(e.KMSMasterKeyID && { KMSMasterKeyID: a.SENSITIVE_STRING }),
			}),
			'ServerSideEncryptionByDefaultFilterSensitiveLog',
		),
		Zq = d(
			(e) => ({
				...e,
				...(e.ApplyServerSideEncryptionByDefault && {
					ApplyServerSideEncryptionByDefault: Qq(
						e.ApplyServerSideEncryptionByDefault,
					),
				}),
			}),
			'ServerSideEncryptionRuleFilterSensitiveLog',
		),
		zS = d(
			(e) => ({ ...e, ...(e.Rules && { Rules: e.Rules.map((t) => Zq(t)) }) }),
			'ServerSideEncryptionConfigurationFilterSensitiveLog',
		),
		ej = d(
			(e) => ({
				...e,
				...(e.ServerSideEncryptionConfiguration && {
					ServerSideEncryptionConfiguration: zS(
						e.ServerSideEncryptionConfiguration,
					),
				}),
			}),
			'GetBucketEncryptionOutputFilterSensitiveLog',
		),
		tj = d(
			(e) => ({ ...e, ...(e.KeyId && { KeyId: a.SENSITIVE_STRING }) }),
			'SSEKMSFilterSensitiveLog',
		),
		rj = d(
			(e) => ({ ...e, ...(e.SSEKMS && { SSEKMS: tj(e.SSEKMS) }) }),
			'InventoryEncryptionFilterSensitiveLog',
		),
		nj = d(
			(e) => ({ ...e, ...(e.Encryption && { Encryption: rj(e.Encryption) }) }),
			'InventoryS3BucketDestinationFilterSensitiveLog',
		),
		ij = d(
			(e) => ({
				...e,
				...(e.S3BucketDestination && {
					S3BucketDestination: nj(e.S3BucketDestination),
				}),
			}),
			'InventoryDestinationFilterSensitiveLog',
		),
		wp = d(
			(e) => ({
				...e,
				...(e.Destination && { Destination: ij(e.Destination) }),
			}),
			'InventoryConfigurationFilterSensitiveLog',
		),
		oj = d(
			(e) => ({
				...e,
				...(e.InventoryConfiguration && {
					InventoryConfiguration: wp(e.InventoryConfiguration),
				}),
			}),
			'GetBucketInventoryConfigurationOutputFilterSensitiveLog',
		),
		sj = d(
			(e) => ({
				...e,
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
			}),
			'GetObjectOutputFilterSensitiveLog',
		),
		aj = d(
			(e) => ({
				...e,
				...(e.SSECustomerKey && { SSECustomerKey: a.SENSITIVE_STRING }),
			}),
			'GetObjectRequestFilterSensitiveLog',
		),
		cj = d(
			(e) => ({
				...e,
				...(e.SSECustomerKey && { SSECustomerKey: a.SENSITIVE_STRING }),
			}),
			'GetObjectAttributesRequestFilterSensitiveLog',
		),
		lj = d((e) => ({ ...e }), 'GetObjectTorrentOutputFilterSensitiveLog'),
		dj = d(
			(e) => ({
				...e,
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
			}),
			'HeadObjectOutputFilterSensitiveLog',
		),
		uj = d(
			(e) => ({
				...e,
				...(e.SSECustomerKey && { SSECustomerKey: a.SENSITIVE_STRING }),
			}),
			'HeadObjectRequestFilterSensitiveLog',
		),
		mj = d(
			(e) => ({
				...e,
				...(e.InventoryConfigurationList && {
					InventoryConfigurationList: e.InventoryConfigurationList.map((t) =>
						wp(t),
					),
				}),
			}),
			'ListBucketInventoryConfigurationsOutputFilterSensitiveLog',
		),
		fj = d(
			(e) => ({
				...e,
				...(e.SSECustomerKey && { SSECustomerKey: a.SENSITIVE_STRING }),
			}),
			'ListPartsRequestFilterSensitiveLog',
		),
		pj = d(
			(e) => ({
				...e,
				...(e.ServerSideEncryptionConfiguration && {
					ServerSideEncryptionConfiguration: zS(
						e.ServerSideEncryptionConfiguration,
					),
				}),
			}),
			'PutBucketEncryptionRequestFilterSensitiveLog',
		),
		gj = d(
			(e) => ({
				...e,
				...(e.InventoryConfiguration && {
					InventoryConfiguration: wp(e.InventoryConfiguration),
				}),
			}),
			'PutBucketInventoryConfigurationRequestFilterSensitiveLog',
		),
		me = (zt(), ve(Gt)),
		S = II(),
		G = (Ut(), ve(ir)),
		oS = Xe(),
		sfe = { Disabled: 'Disabled', Enabled: 'Enabled' },
		vj = class hj extends gn {
			constructor(t) {
				super({
					name: 'ObjectAlreadyInActiveTierError',
					$fault: 'client',
					...t,
				}),
					(this.name = 'ObjectAlreadyInActiveTierError'),
					(this.$fault = 'client'),
					Object.setPrototypeOf(this, hj.prototype)
			}
		}
	d(vj, 'ObjectAlreadyInActiveTierError')
	var _j = vj,
		afe = { Bulk: 'Bulk', Expedited: 'Expedited', Standard: 'Standard' },
		cfe = { SQL: 'SQL' },
		lfe = { BZIP2: 'BZIP2', GZIP: 'GZIP', NONE: 'NONE' },
		dfe = { IGNORE: 'IGNORE', NONE: 'NONE', USE: 'USE' },
		ufe = { DOCUMENT: 'DOCUMENT', LINES: 'LINES' },
		mfe = { ALWAYS: 'ALWAYS', ASNEEDED: 'ASNEEDED' },
		ffe = { SELECT: 'SELECT' },
		sS
	;((e) => {
		e.visit = d(
			(t, r) =>
				t.Records !== void 0
					? r.Records(t.Records)
					: t.Stats !== void 0
						? r.Stats(t.Stats)
						: t.Progress !== void 0
							? r.Progress(t.Progress)
							: t.Cont !== void 0
								? r.Cont(t.Cont)
								: t.End !== void 0
									? r.End(t.End)
									: r._(t.$unknown[0], t.$unknown[1]),
			'visit',
		)
	})(sS || (sS = {}))
	var yj = d(
			(e) => ({
				...e,
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
				...(e.SSEKMSEncryptionContext && {
					SSEKMSEncryptionContext: a.SENSITIVE_STRING,
				}),
			}),
			'PutObjectOutputFilterSensitiveLog',
		),
		Sj = d(
			(e) => ({
				...e,
				...(e.SSECustomerKey && { SSECustomerKey: a.SENSITIVE_STRING }),
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
				...(e.SSEKMSEncryptionContext && {
					SSEKMSEncryptionContext: a.SENSITIVE_STRING,
				}),
			}),
			'PutObjectRequestFilterSensitiveLog',
		),
		Cj = d(
			(e) => ({ ...e, ...(e.KMSKeyId && { KMSKeyId: a.SENSITIVE_STRING }) }),
			'EncryptionFilterSensitiveLog',
		),
		Ej = d(
			(e) => ({ ...e, ...(e.Encryption && { Encryption: Cj(e.Encryption) }) }),
			'S3LocationFilterSensitiveLog',
		),
		bj = d(
			(e) => ({ ...e, ...(e.S3 && { S3: Ej(e.S3) }) }),
			'OutputLocationFilterSensitiveLog',
		),
		wj = d(
			(e) => ({
				...e,
				...(e.OutputLocation && { OutputLocation: bj(e.OutputLocation) }),
			}),
			'RestoreRequestFilterSensitiveLog',
		),
		xj = d(
			(e) => ({
				...e,
				...(e.RestoreRequest && { RestoreRequest: wj(e.RestoreRequest) }),
			}),
			'RestoreObjectRequestFilterSensitiveLog',
		),
		pfe = d((e) => {
			if (e.Records !== void 0) return { Records: e.Records }
			if (e.Stats !== void 0) return { Stats: e.Stats }
			if (e.Progress !== void 0) return { Progress: e.Progress }
			if (e.Cont !== void 0) return { Cont: e.Cont }
			if (e.End !== void 0) return { End: e.End }
			if (e.$unknown !== void 0) return { [e.$unknown[0]]: 'UNKNOWN' }
		}, 'SelectObjectContentEventStreamFilterSensitiveLog'),
		Pj = d(
			(e) => ({ ...e, ...(e.Payload && { Payload: 'STREAMING_CONTENT' }) }),
			'SelectObjectContentOutputFilterSensitiveLog',
		),
		Aj = d(
			(e) => ({
				...e,
				...(e.SSECustomerKey && { SSECustomerKey: a.SENSITIVE_STRING }),
			}),
			'SelectObjectContentRequestFilterSensitiveLog',
		),
		Oj = d(
			(e) => ({
				...e,
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
			}),
			'UploadPartOutputFilterSensitiveLog',
		),
		Rj = d(
			(e) => ({
				...e,
				...(e.SSECustomerKey && { SSECustomerKey: a.SENSITIVE_STRING }),
			}),
			'UploadPartRequestFilterSensitiveLog',
		),
		kj = d(
			(e) => ({
				...e,
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
			}),
			'UploadPartCopyOutputFilterSensitiveLog',
		),
		Ij = d(
			(e) => ({
				...e,
				...(e.SSECustomerKey && { SSECustomerKey: a.SENSITIVE_STRING }),
				...(e.CopySourceSSECustomerKey && {
					CopySourceSSECustomerKey: a.SENSITIVE_STRING,
				}),
			}),
			'UploadPartCopyRequestFilterSensitiveLog',
		),
		Tj = d(
			(e) => ({
				...e,
				...(e.SSEKMSKeyId && { SSEKMSKeyId: a.SENSITIVE_STRING }),
			}),
			'WriteGetObjectResponseRequestFilterSensitiveLog',
		),
		gfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [Me]: e[Fe], [V]: e[$] })
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({
				[qt]: [, 'AbortMultipartUpload'],
				[Ml]: [, (0, a.expectNonNull)(e[Er], 'UploadId')],
			})
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_AbortMultipartUploadCommand'),
		vfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[ps]: e[He],
					[gs]: e[$e],
					[vs]: e[Ve],
					[hs]: e[Ke],
					[Me]: e[Fe],
					[V]: e[$],
					[Np]: e[Ap],
					[Ft]: e[At],
					[yn]: e[vn],
					[Mt]: e[Ot],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [Ml]: [, (0, a.expectNonNull)(e[Er], 'UploadId')] }),
				o,
				s
			return (
				e.MultipartUpload !== void 0 &&
					((s = yhe(e.MultipartUpload, t)),
					(s = s.n('CompleteMultipartUpload')),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('POST').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_CompleteMultipartUploadCommand'),
		hfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[uc]: e[Qa],
					[Bl]: e[Za],
					[fC]: e[Ce],
					[Nl]: e[ec],
					[Dl]: e[tc],
					[Ll]: e[rc],
					[Fl]: e[nc],
					[n2]: e[tU],
					[i2]: e[rU],
					[o2]: [
						() => I(e[up]),
						() => (0, a.dateToUtcString)(e[up]).toString(),
					],
					[s2]: e[nU],
					[a2]: [
						() => I(e[mp]),
						() => (0, a.dateToUtcString)(e[mp]).toString(),
					],
					[ls]: [
						() => I(e[jn]),
						() => (0, a.dateToUtcString)(e[jn]).toString(),
					],
					[mc]: e[ic],
					[fc]: e[oc],
					[pc]: e[sc],
					[gc]: e[ac],
					[uwe]: e[rEe],
					[Swe]: e[XEe],
					[hn]: e[br],
					[Gl]: e[_e],
					[zl]: e[Tl],
					[Ft]: e[At],
					[yn]: e[vn],
					[Mt]: e[Ot],
					[_n]: e[gr],
					[vc]: e[lc],
					[xt]: [() => I(e[ct]), () => e[ct].toString()],
					[c2]: e[iU],
					[l2]: e[oU],
					[d2]: e[sU],
					[Me]: e[Fe],
					[hC]: e[os],
					[Ul]: e[cc],
					[ds]: [
						() => I(e[Un]),
						() => (0, a.serializeDateTime)(e[Un]).toString(),
					],
					[jl]: e[ms],
					[V]: e[$],
					[p2]: e[lU],
					...(e.Metadata !== void 0 &&
						Object.keys(e.Metadata).reduce(
							(s, c) => (
								(s[`x-amz-meta-${c.toLowerCase()}`] = e.Metadata[c]), s
							),
							{},
						)),
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [qt]: [, 'CopyObject'] })
			return (
				r
					.m('PUT')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_CopyObjectCommand'),
		_fe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[uc]: e[Qa],
					[mc]: e[ic],
					[fc]: e[oc],
					[pc]: e[sc],
					[pC]: e[YS],
					[gc]: e[ac],
					[xbe]: [() => I(e[iq]), () => e[iq].toString()],
					[pwe]: e[Rl],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i, o
			return (
				e.CreateBucketConfiguration !== void 0 &&
					((o = Phe(e.CreateBucketConfiguration, t)),
					(i = Ue),
					o.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(i += o.toString())),
				r.m('PUT').h(n).b(i),
				r.build()
			)
		}, 'se_CreateBucketCommand'),
		yfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[uc]: e[Qa],
					[Bl]: e[Za],
					[Nl]: e[ec],
					[Dl]: e[tc],
					[Ll]: e[rc],
					[Fl]: e[nc],
					[ls]: [
						() => I(e[jn]),
						() => (0, a.dateToUtcString)(e[jn]).toString(),
					],
					[mc]: e[ic],
					[fc]: e[oc],
					[pc]: e[sc],
					[gc]: e[ac],
					[hn]: e[br],
					[Gl]: e[_e],
					[zl]: e[Tl],
					[Ft]: e[At],
					[yn]: e[vn],
					[Mt]: e[Ot],
					[_n]: e[gr],
					[vc]: e[lc],
					[xt]: [() => I(e[ct]), () => e[ct].toString()],
					[Me]: e[Fe],
					[hC]: e[os],
					[Ul]: e[cc],
					[ds]: [
						() => I(e[Un]),
						() => (0, a.serializeDateTime)(e[Un]).toString(),
					],
					[jl]: e[ms],
					[V]: e[$],
					[fC]: e[Ce],
					...(e.Metadata !== void 0 &&
						Object.keys(e.Metadata).reduce(
							(s, c) => (
								(s[`x-amz-meta-${c.toLowerCase()}`] = e.Metadata[c]), s
							),
							{},
						)),
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [QU]: [, ''] })
			return (
				r
					.m('POST')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_CreateMultipartUploadCommand'),
		Sfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [Obe]: e[HEe] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [pbe]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_CreateSessionCommand'),
		Cfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			return (
				r.bp('/'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r
					.m('DELETE')
					.h(n)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketCommand'),
		Efe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Op]: [, ''],
				[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
			})
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketAnalyticsConfigurationCommand'),
		bfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [nC]: [, ''] })
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketCorsCommand'),
		wfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [iC]: [, ''] })
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketEncryptionCommand'),
		xfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = {}
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Dp]: [, ''],
				[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
			})
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketIntelligentTieringConfigurationCommand'),
		Pfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Bp]: [, ''],
				[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
			})
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketInventoryConfigurationCommand'),
		Afe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [oC]: [, ''] })
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketLifecycleCommand'),
		Ofe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Lp]: [, ''],
				[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
			})
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketMetricsConfigurationCommand'),
		Rfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [aC]: [, ''] })
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketOwnershipControlsCommand'),
		kfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [cC]: [, ''] })
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketPolicyCommand'),
		Ife = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [dC]: [, ''] })
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketReplicationCommand'),
		Tfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [dc]: [, ''] })
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketTaggingCommand'),
		Bfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [uC]: [, ''] })
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteBucketWebsiteCommand'),
		Nfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[gC]: e[JS],
					[Me]: e[Fe],
					[mC]: [() => I(e[$a]), () => e[$a].toString()],
					[V]: e[$],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [qt]: [, 'DeleteObject'], [wr]: [, e[Se]] })
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteObjectCommand'),
		Dfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[gC]: e[JS],
					[Me]: e[Fe],
					[mC]: [() => I(e[$a]), () => e[$a].toString()],
					[V]: e[$],
					[gt]: e[Ce],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [nbe]: [, ''] }),
				o,
				s
			return (
				e.Delete !== void 0 &&
					((s = khe(e.Delete, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('POST').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_DeleteObjectsCommand'),
		Lfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [dc]: [, ''], [wr]: [, e[Se]] })
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeleteObjectTaggingCommand'),
		Ffe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [lC]: [, ''] })
			return (
				r
					.m('DELETE')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_DeletePublicAccessBlockCommand'),
		Mfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$], [Me]: e[Fe] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [IU]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketAccelerateConfigurationCommand'),
		qfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [Rp]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketAclCommand'),
		jfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Op]: [, ''],
				[qt]: [, 'GetBucketAnalyticsConfiguration'],
				[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketAnalyticsConfigurationCommand'),
		Ufe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [nC]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketCorsCommand'),
		Gfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [iC]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketEncryptionCommand'),
		zfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = {}
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Dp]: [, ''],
				[qt]: [, 'GetBucketIntelligentTieringConfiguration'],
				[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketIntelligentTieringConfigurationCommand'),
		Hfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Bp]: [, ''],
				[qt]: [, 'GetBucketInventoryConfiguration'],
				[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketInventoryConfigurationCommand'),
		$fe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [oC]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketLifecycleConfigurationCommand'),
		Vfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [qU]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketLocationCommand'),
		Kfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [jU]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketLoggingCommand'),
		Wfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Lp]: [, ''],
				[qt]: [, 'GetBucketMetricsConfiguration'],
				[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketMetricsConfigurationCommand'),
		Xfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [UU]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketNotificationConfigurationCommand'),
		Yfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [aC]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketOwnershipControlsCommand'),
		Jfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [cC]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketPolicyCommand'),
		Qfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [ube]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketPolicyStatusCommand'),
		Zfe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [dC]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketReplicationCommand'),
		epe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [zU]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketRequestPaymentCommand'),
		tpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [dc]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketTaggingCommand'),
		rpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [ZU]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketVersioningCommand'),
		npe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [uC]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetBucketWebsiteCommand'),
		ipe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[NU]: e[fU],
					[DU]: [
						() => I(e[fp]),
						() => (0, a.dateToUtcString)(e[fp]).toString(),
					],
					[Np]: e[Ap],
					[LU]: [
						() => I(e[pp]),
						() => (0, a.dateToUtcString)(e[pp]).toString(),
					],
					[HU]: e[SU],
					[Ft]: e[At],
					[yn]: e[vn],
					[Mt]: e[Ot],
					[Me]: e[Fe],
					[V]: e[$],
					[r2]: e[Zj],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({
				[qt]: [, 'GetObject'],
				[$U]: [, e[CU]],
				[VU]: [, e[EU]],
				[KU]: [, e[bU]],
				[WU]: [, e[wU]],
				[XU]: [, e[xU]],
				[YU]: [
					() => e.ResponseExpires !== void 0,
					() => (0, a.dateToUtcString)(e[PU]).toString(),
				],
				[wr]: [, e[Se]],
				[Fp]: [() => e.PartNumber !== void 0, () => e[yr].toString()],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetObjectCommand'),
		ope = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [Me]: e[Fe], [V]: e[$] })
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [Rp]: [, ''], [wr]: [, e[Se]] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetObjectAclCommand'),
		spe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[mwe]: [() => I(e[si]), () => e[si].toString()],
					[gwe]: e[Yi],
					[Ft]: e[At],
					[yn]: e[vn],
					[Mt]: e[Ot],
					[Me]: e[Fe],
					[V]: e[$],
					[fwe]: [() => I(e[nq]), () => (e[nq] || []).map((s) => s).join(', ')],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [tbe]: [, ''], [wr]: [, e[Se]] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetObjectAttributesCommand'),
		ape = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [Me]: e[Fe], [V]: e[$] })
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [MU]: [, ''], [wr]: [, e[Se]] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetObjectLegalHoldCommand'),
		cpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [GU]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetObjectLockConfigurationCommand'),
		lpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [Me]: e[Fe], [V]: e[$] })
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [JU]: [, ''], [wr]: [, e[Se]] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetObjectRetentionCommand'),
		dpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$], [Me]: e[Fe] })
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [dc]: [, ''], [wr]: [, e[Se]] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetObjectTaggingCommand'),
		upe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [Me]: e[Fe], [V]: e[$] })
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [_be]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetObjectTorrentCommand'),
		mpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [lC]: [, ''] })
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_GetPublicAccessBlockCommand'),
		fpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			return (
				r.bp('/'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r
					.m('HEAD')
					.h(n)
					.b(void 0),
				r.build()
			)
		}, 'se_HeadBucketCommand'),
		ppe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[NU]: e[fU],
					[DU]: [
						() => I(e[fp]),
						() => (0, a.dateToUtcString)(e[fp]).toString(),
					],
					[Np]: e[Ap],
					[LU]: [
						() => I(e[pp]),
						() => (0, a.dateToUtcString)(e[pp]).toString(),
					],
					[HU]: e[SU],
					[Ft]: e[At],
					[yn]: e[vn],
					[Mt]: e[Ot],
					[Me]: e[Fe],
					[V]: e[$],
					[r2]: e[Zj],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({
				[$U]: [, e[CU]],
				[VU]: [, e[EU]],
				[KU]: [, e[bU]],
				[WU]: [, e[wU]],
				[XU]: [, e[xU]],
				[YU]: [
					() => e.ResponseExpires !== void 0,
					() => (0, a.dateToUtcString)(e[PU]).toString(),
				],
				[wr]: [, e[Se]],
				[Fp]: [() => e.PartNumber !== void 0, () => e[yr].toString()],
			})
			return (
				r
					.m('HEAD')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_HeadObjectCommand'),
		gpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Op]: [, ''],
				[qt]: [, 'ListBucketAnalyticsConfigurations'],
				[fs]: [, e[je]],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListBucketAnalyticsConfigurationsCommand'),
		vpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = {}
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Dp]: [, ''],
				[qt]: [, 'ListBucketIntelligentTieringConfigurations'],
				[fs]: [, e[je]],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListBucketIntelligentTieringConfigurationsCommand'),
		hpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Bp]: [, ''],
				[qt]: [, 'ListBucketInventoryConfigurations'],
				[fs]: [, e[je]],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListBucketInventoryConfigurationsCommand'),
		_pe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Lp]: [, ''],
				[qt]: [, 'ListBucketMetricsConfigurations'],
				[fs]: [, e[je]],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListBucketMetricsConfigurationsCommand'),
		ype = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = {}
			r.bp('/')
			let i = (0, a.map)({
				[qt]: [, 'ListBuckets'],
				[abe]: [() => e.MaxBuckets !== void 0, () => e[tEe].toString()],
				[fs]: [, e[je]],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListBucketsCommand'),
		Spe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = {}
			r.bp('/')
			let i = (0, a.map)({
				[qt]: [, 'ListDirectoryBuckets'],
				[fs]: [, e[je]],
				[cbe]: [
					() => e.MaxDirectoryBuckets !== void 0,
					() => e[nEe].toString(),
				],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListDirectoryBucketsCommand'),
		Cpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { [V]: e[$], [Me]: e[Fe] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[QU]: [, ''],
				[kp]: [, e[Zt]],
				[Ip]: [, e[er]],
				[FU]: [, e[Xi]],
				[dbe]: [() => e.MaxUploads !== void 0, () => e[jf].toString()],
				[Mp]: [, e[H]],
				[ybe]: [, e[ip]],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListMultipartUploadsCommand'),
		Epe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[Me]: e[Fe],
					[V]: e[$],
					[vC]: [() => I(e[Va]), () => (e[Va] || []).map((s) => s).join(', ')],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[kp]: [, e[Zt]],
				[Ip]: [, e[er]],
				[sbe]: [, e[Mf]],
				[sC]: [() => e.MaxKeys !== void 0, () => e[Vr].toString()],
				[Mp]: [, e[H]],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListObjectsCommand'),
		bpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[Me]: e[Fe],
					[V]: e[$],
					[vC]: [() => I(e[Va]), () => (e[Va] || []).map((s) => s).join(', ')],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[obe]: [, '2'],
				[kp]: [, e[Zt]],
				[Ip]: [, e[er]],
				[sC]: [() => e.MaxKeys !== void 0, () => e[Vr].toString()],
				[Mp]: [, e[H]],
				[fs]: [, e[je]],
				[ibe]: [() => e.FetchOwner !== void 0, () => e[E0e].toString()],
				[gbe]: [, e[Jf]],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListObjectsV2Command'),
		wpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[V]: e[$],
					[Me]: e[Fe],
					[vC]: [() => I(e[Va]), () => (e[Va] || []).map((s) => s).join(', ')],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
				[Sbe]: [, ''],
				[kp]: [, e[Zt]],
				[Ip]: [, e[er]],
				[FU]: [, e[Xi]],
				[sC]: [() => e.MaxKeys !== void 0, () => e[Vr].toString()],
				[Mp]: [, e[H]],
				[Cbe]: [, e[sp]],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListObjectVersionsCommand'),
		xpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[Me]: e[Fe],
					[V]: e[$],
					[Ft]: e[At],
					[yn]: e[vn],
					[Mt]: e[Ot],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({
				[qt]: [, 'ListParts'],
				[lbe]: [() => e.MaxParts !== void 0, () => e[si].toString()],
				[mbe]: [, e[Yi]],
				[Ml]: [, (0, a.expectNonNull)(e[Er], 'UploadId')],
			})
			return (
				r
					.m('GET')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_ListPartsCommand'),
		Ppe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[V]: e[$],
					[gt]: e[Ce],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [IU]: [, ''] }),
				o,
				s
			return (
				e.AccelerateConfiguration !== void 0 &&
					((s = she(e.AccelerateConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketAccelerateConfigurationCommand'),
		Ape = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[uc]: e[Qa],
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[mc]: e[ic],
					[fc]: e[oc],
					[pc]: e[sc],
					[pC]: e[YS],
					[gc]: e[ac],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [Rp]: [, ''] }),
				o,
				s
			return (
				e.AccessControlPolicy !== void 0 &&
					((s = Bj(e.AccessControlPolicy, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketAclCommand'),
		Ope = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { 'content-type': 'application/xml', [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
					[Op]: [, ''],
					[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
				}),
				o,
				s
			return (
				e.AnalyticsConfiguration !== void 0 &&
					((s = mhe(e.AnalyticsConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketAnalyticsConfigurationCommand'),
		Rpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [nC]: [, ''] }),
				o,
				s
			return (
				e.CORSConfiguration !== void 0 &&
					((s = bhe(e.CORSConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketCorsCommand'),
		kpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [iC]: [, ''] }),
				o,
				s
			return (
				e.ServerSideEncryptionConfiguration !== void 0 &&
					((s = tye(e.ServerSideEncryptionConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketEncryptionCommand'),
		Ipe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = { 'content-type': 'application/xml' }
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
					[Dp]: [, ''],
					[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
				}),
				o,
				s
			return (
				e.IntelligentTieringConfiguration !== void 0 &&
					((s = $he(e.IntelligentTieringConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketIntelligentTieringConfigurationCommand'),
		Tpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { 'content-type': 'application/xml', [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
					[Bp]: [, ''],
					[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
				}),
				o,
				s
			return (
				e.InventoryConfiguration !== void 0 &&
					((s = Khe(e.InventoryConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketInventoryConfigurationCommand'),
		Bpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [oC]: [, ''] }),
				o,
				s
			return (
				e.LifecycleConfiguration !== void 0 &&
					((s = hhe(e.LifecycleConfiguration, t)),
					(s = s.n('LifecycleConfiguration')),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketLifecycleConfigurationCommand'),
		Npe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [jU]: [, ''] }),
				o,
				s
			return (
				e.BucketLoggingStatus !== void 0 &&
					((s = _he(e.BucketLoggingStatus, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketLoggingCommand'),
		Dpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, { 'content-type': 'application/xml', [V]: e[$] })
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({
					[Lp]: [, ''],
					[Zr]: [, (0, a.expectNonNull)(e[ce], 'Id')],
				}),
				o,
				s
			return (
				e.MetricsConfiguration !== void 0 &&
					((s = p_e(e.MetricsConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketMetricsConfigurationCommand'),
		Lpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[V]: e[$],
					[ywe]: [() => I(e[sq]), () => e[sq].toString()],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [UU]: [, ''] }),
				o,
				s
			return (
				e.NotificationConfiguration !== void 0 &&
					((s = y_e(e.NotificationConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketNotificationConfigurationCommand'),
		Fpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Rt]: e[Pt],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [aC]: [, ''] }),
				o,
				s
			return (
				e.OwnershipControls !== void 0 &&
					((s = O_e(e.OwnershipControls, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketOwnershipControlsCommand'),
		Mpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'text/plain',
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[Abe]: [() => I(e[Y1]), () => e[Y1].toString()],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [cC]: [, ''] }),
				o,
				s
			return (
				e.Policy !== void 0 && ((s = e.Policy), (o = s)),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketPolicyCommand'),
		qpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[t2]: e[RU],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [dC]: [, ''] }),
				o,
				s
			return (
				e.ReplicationConfiguration !== void 0 &&
					((s = q_e(e.ReplicationConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketReplicationCommand'),
		jpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [zU]: [, ''] }),
				o,
				s
			return (
				e.RequestPaymentConfiguration !== void 0 &&
					((s = $_e(e.RequestPaymentConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketRequestPaymentCommand'),
		Upe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [dc]: [, ''] }),
				o,
				s
			return (
				e.Tagging !== void 0 &&
					((s = VS(e.Tagging, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketTaggingCommand'),
		Gpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[gC]: e[JS],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [ZU]: [, ''] }),
				o,
				s
			return (
				e.VersioningConfiguration !== void 0 &&
					((s = Cye(e.VersioningConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketVersioningCommand'),
		zpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [uC]: [, ''] }),
				o,
				s
			return (
				e.WebsiteConfiguration !== void 0 &&
					((s = Eye(e.WebsiteConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutBucketWebsiteCommand'),
		Hpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[Fl]: e[nc] || 'application/octet-stream',
					[uc]: e[Qa],
					[Bl]: e[Za],
					[Nl]: e[ec],
					[Dl]: e[tc],
					[Ll]: e[rc],
					[cs]: [() => I(e[Qi]), () => e[Qi].toString()],
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[ps]: e[He],
					[gs]: e[$e],
					[vs]: e[Ve],
					[hs]: e[Ke],
					[ls]: [
						() => I(e[jn]),
						() => (0, a.dateToUtcString)(e[jn]).toString(),
					],
					[Np]: e[Ap],
					[mc]: e[ic],
					[fc]: e[oc],
					[pc]: e[sc],
					[gc]: e[ac],
					[hn]: e[br],
					[Gl]: e[_e],
					[zl]: e[Tl],
					[Ft]: e[At],
					[yn]: e[vn],
					[Mt]: e[Ot],
					[_n]: e[gr],
					[vc]: e[lc],
					[xt]: [() => I(e[ct]), () => e[ct].toString()],
					[Me]: e[Fe],
					[hC]: e[os],
					[Ul]: e[cc],
					[ds]: [
						() => I(e[Un]),
						() => (0, a.serializeDateTime)(e[Un]).toString(),
					],
					[jl]: e[ms],
					[V]: e[$],
					...(e.Metadata !== void 0 &&
						Object.keys(e.Metadata).reduce(
							(c, l) => (
								(c[`x-amz-meta-${l.toLowerCase()}`] = e.Metadata[l]), c
							),
							{},
						)),
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [qt]: [, 'PutObject'] }),
				o,
				s
			return (
				e.Body !== void 0 && ((s = e.Body), (o = s)),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutObjectCommand'),
		$pe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[uc]: e[Qa],
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[mc]: e[ic],
					[fc]: e[oc],
					[pc]: e[sc],
					[pC]: e[YS],
					[gc]: e[ac],
					[Me]: e[Fe],
					[V]: e[$],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [Rp]: [, ''], [wr]: [, e[Se]] }),
				o,
				s
			return (
				e.AccessControlPolicy !== void 0 &&
					((s = Bj(e.AccessControlPolicy, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutObjectAclCommand'),
		Vpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Me]: e[Fe],
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [MU]: [, ''], [wr]: [, e[Se]] }),
				o,
				s
			return (
				e.LegalHold !== void 0 &&
					((s = b_e(e.LegalHold, t)),
					(s = s.n('LegalHold')),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutObjectLegalHoldCommand'),
		Kpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Me]: e[Fe],
					[t2]: e[RU],
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [GU]: [, ''] }),
				o,
				s
			return (
				e.ObjectLockConfiguration !== void 0 &&
					((s = E_e(e.ObjectLockConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutObjectLockConfigurationCommand'),
		Wpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Me]: e[Fe],
					[mC]: [() => I(e[$a]), () => e[$a].toString()],
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [JU]: [, ''], [wr]: [, e[Se]] }),
				o,
				s
			return (
				e.Retention !== void 0 &&
					((s = w_e(e.Retention, t)),
					(s = s.n('Retention')),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutObjectRetentionCommand'),
		Xpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[V]: e[$],
					[Me]: e[Fe],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [dc]: [, ''], [wr]: [, e[Se]] }),
				o,
				s
			return (
				e.Tagging !== void 0 &&
					((s = VS(e.Tagging, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutObjectTaggingCommand'),
		Ype = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/'), r.p('Bucket', () => e.Bucket, '{Bucket}', !1)
			let i = (0, a.map)({ [lC]: [, ''] }),
				o,
				s
			return (
				e.PublicAccessBlockConfiguration !== void 0 &&
					((s = B_e(e.PublicAccessBlockConfiguration, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_PutPublicAccessBlockCommand'),
		Jpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Me]: e[Fe],
					[gt]: e[Ce],
					[V]: e[$],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [fbe]: [, ''], [wr]: [, e[Se]] }),
				o,
				s
			return (
				e.RestoreRequest !== void 0 &&
					((s = K_e(e.RestoreRequest, t)),
					(o = Ue),
					s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
					(o += s.toString())),
				r.m('POST').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_RestoreObjectCommand'),
		Qpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/xml',
					[Ft]: e[At],
					[yn]: e[vn],
					[Mt]: e[Ot],
					[V]: e[$],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({ [vbe]: [, ''], [hbe]: [, '2'] }),
				o
			o = Ue
			let s = new S.XmlNode($Ee)
			return (
				s.a('xmlns', 'http://s3.amazonaws.com/doc/2006-03-01/'),
				s.cc(e, uU),
				s.cc(e, dU),
				e[Ho] != null && s.c(Lj(e[Ho], t).n(Ho)),
				e[Xo] != null && s.c(Fj(e[Xo], t).n(Xo)),
				e[Xf] != null && s.c(V_e(e[Xf], t).n(Xf)),
				e[Zf] != null && s.c(Q_e(e[Zf], t).n(Zf)),
				(o += s.toString()),
				r.m('POST').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_SelectObjectContentCommand'),
		Zpe = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'content-type': 'application/octet-stream',
					[cs]: [() => I(e[Qi]), () => e[Qi].toString()],
					[Rt]: e[Pt],
					[gt]: e[Ce],
					[ps]: e[He],
					[gs]: e[$e],
					[vs]: e[Ve],
					[hs]: e[Ke],
					[Ft]: e[At],
					[yn]: e[vn],
					[Mt]: e[Ot],
					[Me]: e[Fe],
					[V]: e[$],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({
					[qt]: [, 'UploadPart'],
					[Fp]: [
						(0, a.expectNonNull)(e.PartNumber, 'PartNumber') != null,
						() => e[yr].toString(),
					],
					[Ml]: [, (0, a.expectNonNull)(e[Er], 'UploadId')],
				}),
				o,
				s
			return (
				e.Body !== void 0 && ((s = e.Body), (o = s)),
				r.m('PUT').h(n).q(i).b(o),
				r.build()
			)
		}, 'se_UploadPartCommand'),
		ege = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					[n2]: e[tU],
					[i2]: e[rU],
					[o2]: [
						() => I(e[up]),
						() => (0, a.dateToUtcString)(e[up]).toString(),
					],
					[s2]: e[nU],
					[a2]: [
						() => I(e[mp]),
						() => (0, a.dateToUtcString)(e[mp]).toString(),
					],
					[Rbe]: e[a0e],
					[Ft]: e[At],
					[yn]: e[vn],
					[Mt]: e[Ot],
					[c2]: e[iU],
					[l2]: e[oU],
					[d2]: e[sU],
					[Me]: e[Fe],
					[V]: e[$],
					[p2]: e[lU],
				})
			r.bp('/{Key+}'),
				r.p('Bucket', () => e.Bucket, '{Bucket}', !1),
				r.p('Key', () => e.Key, '{Key+}', !0)
			let i = (0, a.map)({
				[qt]: [, 'UploadPartCopy'],
				[Fp]: [
					(0, a.expectNonNull)(e.PartNumber, 'PartNumber') != null,
					() => e[yr].toString(),
				],
				[Ml]: [, (0, a.expectNonNull)(e[Er], 'UploadId')],
			})
			return (
				r
					.m('PUT')
					.h(n)
					.q(i)
					.b(void 0),
				r.build()
			)
		}, 'se_UploadPartCopyCommand'),
		tge = d(async (e, t) => {
			let r = (0, G.requestBuilder)(e, t),
				n = (0, a.map)({}, I, {
					'x-amz-content-sha256': 'UNSIGNED-PAYLOAD',
					'content-type': 'application/octet-stream',
					[hwe]: e[REe],
					[_we]: e[LEe],
					[dwe]: [() => I(e[oq]), () => e[oq].toString()],
					[kbe]: e[v0e],
					[Ibe]: e[h0e],
					[Tbe]: e[XS],
					[Bbe]: e[Za],
					[Nbe]: e[ec],
					[Dbe]: e[tc],
					[Lbe]: e[rc],
					[cs]: [() => I(e[Qi]), () => e[Qi].toString()],
					[Fbe]: e[eU],
					[Mbe]: e[nc],
					[Gbe]: e[He],
					[zbe]: e[$e],
					[Hbe]: e[Ve],
					[$be]: e[Ke],
					[Vbe]: [() => I(e[fn]), () => e[fn].toString()],
					[qbe]: e[We],
					[jbe]: [
						() => I(e[jn]),
						() => (0, a.dateToUtcString)(e[jn]).toString(),
					],
					[Kbe]: e[mr],
					[Ube]: [
						() => I(e[dt]),
						() => (0, a.dateToUtcString)(e[dt]).toString(),
					],
					[Wbe]: [() => I(e[gp]), () => e[gp].toString()],
					[Jbe]: e[cc],
					[Ybe]: e[ms],
					[Qbe]: [
						() => I(e[Un]),
						() => (0, a.serializeDateTime)(e[Un]).toString(),
					],
					[Xbe]: [() => I(e[Ka]), () => e[Ka].toString()],
					[twe]: e[tC],
					[ewe]: e[Ze],
					[Zbe]: e[rC],
					[nwe]: e[br],
					[swe]: e[At],
					[iwe]: e[gr],
					[awe]: e[Ot],
					[rwe]: e[_e],
					[cwe]: [() => I(e[DS]), () => e[DS].toString()],
					[lwe]: e[Se],
					[owe]: [() => I(e[ct]), () => e[ct].toString()],
					...(e.Metadata !== void 0 &&
						Object.keys(e.Metadata).reduce(
							(c, l) => (
								(c[`x-amz-meta-${l.toLowerCase()}`] = e.Metadata[l]), c
							),
							{},
						)),
				})
			r.bp('/WriteGetObjectResponse')
			let i, o
			e.Body !== void 0 && ((o = e.Body), (i = o))
			let { hostname: s } = await t.endpoint()
			if (t.disableHostPrefix !== !0) {
				if (((s = '{RequestRoute}.' + s), e.RequestRoute === void 0))
					throw new Error(
						'Empty value provided for input host prefix: RequestRoute.',
					)
				if (
					((s = s.replace('{RequestRoute}', e.RequestRoute)),
					!(0, oS.isValidHostname)(s))
				)
					throw new Error(
						'ValidationError: prefixed hostname must be hostname compatible.',
					)
			}
			return r.hn(s), r.m('POST').h(n).b(i), r.build()
		}, 'se_WriteGetObjectResponseCommand'),
		rge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_AbortMultipartUploadCommand'),
		nge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
					$metadata: D(e),
					[mr]: [, e.headers[ql]],
					[br]: [, e.headers[hn]],
					[Se]: [, e.headers[Gn]],
					[gr]: [, e.headers[_n]],
					[ct]: [
						() => e.headers[xt] !== void 0,
						() => (0, a.parseBoolean)(e.headers[xt]),
					],
					[Ze]: [, e.headers[tt]],
				}),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n[Pe] != null && (r[Pe] = (0, a.expectString)(n[Pe])),
				n[He] != null && (r[He] = (0, a.expectString)(n[He])),
				n[$e] != null && (r[$e] = (0, a.expectString)(n[$e])),
				n[Ve] != null && (r[Ve] = (0, a.expectString)(n[Ve])),
				n[Ke] != null && (r[Ke] = (0, a.expectString)(n[Ke])),
				n[We] != null && (r[We] = (0, a.expectString)(n[We])),
				n[pe] != null && (r[pe] = (0, a.expectString)(n[pe])),
				n[$o] != null && (r[$o] = (0, a.expectString)(n[$o])),
				r
			)
		}, 'de_CompleteMultipartUploadCommand'),
		ige = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
					$metadata: D(e),
					[mr]: [, e.headers[ql]],
					[aU]: [, e.headers[u2]],
					[Se]: [, e.headers[Gn]],
					[br]: [, e.headers[hn]],
					[At]: [, e.headers[Ft]],
					[Ot]: [, e.headers[Mt]],
					[gr]: [, e.headers[_n]],
					[lc]: [, e.headers[vc]],
					[ct]: [
						() => e.headers[xt] !== void 0,
						() => (0, a.parseBoolean)(e.headers[xt]),
					],
					[Ze]: [, e.headers[tt]],
				}),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.CopyObjectResult = Mye(n, t)), r
		}, 'de_CopyObjectCommand'),
		oge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [$o]: [, e.headers[qU]] })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_CreateBucketCommand'),
		sge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
					$metadata: D(e),
					[Jj]: [
						() => e.headers[Sp] !== void 0,
						() =>
							(0, a.expectNonNull)((0, a.parseRfc7231DateTime)(e.headers[Sp])),
					],
					[Qj]: [, e.headers[e2]],
					[br]: [, e.headers[hn]],
					[At]: [, e.headers[Ft]],
					[Ot]: [, e.headers[Mt]],
					[gr]: [, e.headers[_n]],
					[lc]: [, e.headers[vc]],
					[ct]: [
						() => e.headers[xt] !== void 0,
						() => (0, a.parseBoolean)(e.headers[xt]),
					],
					[Ze]: [, e.headers[tt]],
					[Ce]: [, e.headers[fC]],
				}),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n[Pe] != null && (r[Pe] = (0, a.expectString)(n[Pe])),
				n[pe] != null && (r[pe] = (0, a.expectString)(n[pe])),
				n[Er] != null && (r[Er] = (0, a.expectString)(n[Er])),
				r
			)
		}, 'de_CreateMultipartUploadCommand'),
		age = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return n[Dy] != null && (r[Dy] = hCe(n[Dy], t)), r
		}, 'de_CreateSessionCommand'),
		cge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketCommand'),
		lge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketAnalyticsConfigurationCommand'),
		dge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketCorsCommand'),
		uge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketEncryptionCommand'),
		mge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketIntelligentTieringConfigurationCommand'),
		fge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketInventoryConfigurationCommand'),
		pge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketLifecycleCommand'),
		gge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketMetricsConfigurationCommand'),
		vge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketOwnershipControlsCommand'),
		hge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketPolicyCommand'),
		_ge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketReplicationCommand'),
		yge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketTaggingCommand'),
		Sge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteBucketWebsiteCommand'),
		Cge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
				$metadata: D(e),
				[fn]: [
					() => e.headers[Zi] !== void 0,
					() => (0, a.parseBoolean)(e.headers[Zi]),
				],
				[Se]: [, e.headers[Gn]],
				[Ze]: [, e.headers[tt]],
			})
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteObjectCommand'),
		Ege = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.Deleted === ''
					? (r[Pf] = [])
					: n[Pf] != null &&
						(r[Pf] = Hye((0, a.getArrayIfSingleItem)(n[Pf]), t)),
				n.Error === ''
					? (r[Z1] = [])
					: n[Q1] != null &&
						(r[Z1] = Zye((0, a.getArrayIfSingleItem)(n[Q1]), t)),
				r
			)
		}, 'de_DeleteObjectsCommand'),
		bge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Se]: [, e.headers[Gn]] })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeleteObjectTaggingCommand'),
		wge = d(async (e, t) => {
			if (e.statusCode !== 204 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_DeletePublicAccessBlockCommand'),
		xge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return n[J] != null && (r[J] = (0, a.expectString)(n[J])), r
		}, 'de_GetBucketAccelerateConfigurationCommand'),
		Pge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.AccessControlList === ''
					? (r[kl] = [])
					: n[Bo] != null &&
						n[Bo][ci] != null &&
						(r[kl] = zj((0, a.getArrayIfSingleItem)(n[Bo][ci]), t)),
				n[ke] != null && (r[ke] = eo(n[ke], t)),
				r
			)
		}, 'de_GetBucketAclCommand'),
		Age = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.AnalyticsConfiguration = qj(n, t)), r
		}, 'de_GetBucketAnalyticsConfigurationCommand'),
		Oge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.CORSRule === ''
					? (r[vS] = [])
					: n[gS] != null &&
						(r[vS] = Uye((0, a.getArrayIfSingleItem)(n[gS]), t)),
				r
			)
		}, 'de_GetBucketCorsCommand'),
		Rge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.ServerSideEncryptionConfiguration = pCe(n, t)), r
		}, 'de_GetBucketEncryptionCommand'),
		kge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.IntelligentTieringConfiguration = $j(n, t)), r
		}, 'de_GetBucketIntelligentTieringConfigurationCommand'),
		Ige = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.InventoryConfiguration = Vj(n, t)), r
		}, 'de_GetBucketInventoryConfigurationCommand'),
		Tge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.Rule === ''
					? (r[Qr] = [])
					: n[Sr] != null &&
						(r[Qr] = wSe((0, a.getArrayIfSingleItem)(n[Sr]), t)),
				r
			)
		}, 'de_GetBucketLifecycleConfigurationCommand'),
		Bge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return n[Da] != null && (r[Da] = (0, a.expectString)(n[Da])), r
		}, 'de_GetBucketLocationCommand'),
		Nge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return n[Vo] != null && (r[Vo] = xSe(n[Vo], t)), r
		}, 'de_GetBucketLoggingCommand'),
		Dge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.MetricsConfiguration = Kj(n, t)), r
		}, 'de_GetBucketMetricsConfigurationCommand'),
		Lge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n[qo] != null && (r[qo] = eSe(n[qo], t)),
				n.CloudFunctionConfiguration === ''
					? (r[wS] = [])
					: n[X1] != null &&
						(r[wS] = ySe((0, a.getArrayIfSingleItem)(n[X1]), t)),
				n.QueueConfiguration === ''
					? (r[kS] = [])
					: n[RS] != null &&
						(r[kS] = eCe((0, a.getArrayIfSingleItem)(n[RS]), t)),
				n.TopicConfiguration === ''
					? (r[FS] = [])
					: n[LS] != null &&
						(r[FS] = TCe((0, a.getArrayIfSingleItem)(n[LS]), t)),
				r
			)
		}, 'de_GetBucketNotificationConfigurationCommand'),
		Fge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.OwnershipControls = zSe(n, t)), r
		}, 'de_GetBucketOwnershipControlsCommand'),
		Mge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = await DCe(e.body, t)
			return (r.Policy = (0, a.expectString)(n)), r
		}, 'de_GetBucketPolicyCommand'),
		qge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.PolicyStatus = YSe(n, t)), r
		}, 'de_GetBucketPolicyStatusCommand'),
		jge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.ReplicationConfiguration = iCe(n, t)), r
		}, 'de_GetBucketReplicationCommand'),
		Uge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return n[Hf] != null && (r[Hf] = (0, a.expectString)(n[Hf])), r
		}, 'de_GetBucketRequestPaymentCommand'),
		Gge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.TagSet === ''
					? (r[mn] = [])
					: n[mn] != null &&
						n[mn][Ee] != null &&
						(r[mn] = us((0, a.getArrayIfSingleItem)(n[mn][Ee]), t)),
				r
			)
		}, 'de_GetBucketTaggingCommand'),
		zge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n[PS] != null && (r[qf] = (0, a.expectString)(n[PS])),
				n[J] != null && (r[J] = (0, a.expectString)(n[J])),
				r
			)
		}, 'de_GetBucketVersioningCommand'),
		Hge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n[Uo] != null && (r[Uo] = Qye(n[Uo], t)),
				n[zo] != null && (r[zo] = aSe(n[zo], t)),
				n[Jo] != null && (r[Jo] = rCe(n[Jo], t)),
				n.RoutingRules === ''
					? (r[fa] = [])
					: n[fa] != null &&
						n[fa][hp] != null &&
						(r[fa] = uCe((0, a.getArrayIfSingleItem)(n[fa][hp]), t)),
				r
			)
		}, 'de_GetBucketWebsiteCommand'),
		$ge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
					$metadata: D(e),
					[fn]: [
						() => e.headers[Zi] !== void 0,
						() => (0, a.parseBoolean)(e.headers[Zi]),
					],
					[XS]: [, e.headers[TU]],
					[mr]: [, e.headers[ql]],
					[rC]: [, e.headers[m2]],
					[dt]: [
						() => e.headers[Wa] !== void 0,
						() =>
							(0, a.expectNonNull)((0, a.parseRfc7231DateTime)(e.headers[Wa])),
					],
					[Qi]: [
						() => e.headers[cs] !== void 0,
						() => (0, a.strictParseLong)(e.headers[cs]),
					],
					[We]: [, e.headers[Tp]],
					[He]: [, e.headers[ps]],
					[$e]: [, e.headers[gs]],
					[Ve]: [, e.headers[vs]],
					[Ke]: [, e.headers[hs]],
					[gp]: [
						() => e.headers[Cp] !== void 0,
						() => (0, a.strictParseInt32)(e.headers[Cp]),
					],
					[Se]: [, e.headers[Gn]],
					[Za]: [, e.headers[Bl]],
					[ec]: [, e.headers[Nl]],
					[tc]: [, e.headers[Dl]],
					[rc]: [, e.headers[Ll]],
					[eU]: [, e.headers[rbe]],
					[nc]: [, e.headers[Fl]],
					[jn]: [
						() => e.headers[ls] !== void 0,
						() =>
							(0, a.expectNonNull)((0, a.parseRfc7231DateTime)(e.headers[ls])),
					],
					[cU]: [, e.headers[BU]],
					[Tl]: [, e.headers[zl]],
					[br]: [, e.headers[hn]],
					[At]: [, e.headers[Ft]],
					[Ot]: [, e.headers[Mt]],
					[gr]: [, e.headers[_n]],
					[ct]: [
						() => e.headers[xt] !== void 0,
						() => (0, a.parseBoolean)(e.headers[xt]),
					],
					[_e]: [, e.headers[Gl]],
					[Ze]: [, e.headers[tt]],
					[tC]: [, e.headers[f2]],
					[Ka]: [
						() => e.headers[Ep] !== void 0,
						() => (0, a.strictParseInt32)(e.headers[Ep]),
					],
					[DS]: [
						() => e.headers[fq] !== void 0,
						() => (0, a.strictParseInt32)(e.headers[fq]),
					],
					[cc]: [, e.headers[Ul]],
					[Un]: [
						() => e.headers[ds] !== void 0,
						() =>
							(0, a.expectNonNull)(
								(0, a.parseRfc3339DateTimeWithOffset)(e.headers[ds]),
							),
					],
					[ms]: [, e.headers[jl]],
					Metadata: [
						,
						Object.keys(e.headers)
							.filter((i) => i.startsWith('x-amz-meta-'))
							.reduce((i, o) => ((i[o.substring(11)] = e.headers[o]), i), {}),
					],
				}),
				n = e.body
			return t.sdkStreamMixin(n), (r.Body = n), r
		}, 'de_GetObjectCommand'),
		Vge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.AccessControlList === ''
					? (r[kl] = [])
					: n[Bo] != null &&
						n[Bo][ci] != null &&
						(r[kl] = zj((0, a.getArrayIfSingleItem)(n[Bo][ci]), t)),
				n[ke] != null && (r[ke] = eo(n[ke], t)),
				r
			)
		}, 'de_GetObjectAclCommand'),
		Kge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
					$metadata: D(e),
					[fn]: [
						() => e.headers[Zi] !== void 0,
						() => (0, a.parseBoolean)(e.headers[Zi]),
					],
					[dt]: [
						() => e.headers[Wa] !== void 0,
						() =>
							(0, a.expectNonNull)((0, a.parseRfc7231DateTime)(e.headers[Wa])),
					],
					[Se]: [, e.headers[Gn]],
					[Ze]: [, e.headers[tt]],
				}),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n[My] != null && (r[My] = Nye(n[My], t)),
				n[We] != null && (r[We] = (0, a.expectString)(n[We])),
				n[Qy] != null && (r[Qy] = oSe(n[Qy], t)),
				n[Zy] != null && (r[Zy] = (0, a.strictParseLong)(n[Zy])),
				n[_e] != null && (r[_e] = (0, a.expectString)(n[_e])),
				r
			)
		}, 'de_GetObjectAttributesCommand'),
		Wge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.LegalHold = FSe(n, t)), r
		}, 'de_GetObjectLegalHoldCommand'),
		Xge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.ObjectLockConfiguration = LSe(n, t)), r
		}, 'de_GetObjectLockConfigurationCommand'),
		Yge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.Retention = MSe(n, t)), r
		}, 'de_GetObjectRetentionCommand'),
		Jge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Se]: [, e.headers[Gn]] }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.TagSet === ''
					? (r[mn] = [])
					: n[mn] != null &&
						n[mn][Ee] != null &&
						(r[mn] = us((0, a.getArrayIfSingleItem)(n[mn][Ee]), t)),
				r
			)
		}, 'de_GetObjectTaggingCommand'),
		Qge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] }),
				n = e.body
			return t.sdkStreamMixin(n), (r.Body = n), r
		}, 'de_GetObjectTorrentCommand'),
		Zge = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.PublicAccessBlockConfiguration = QSe(n, t)), r
		}, 'de_GetPublicAccessBlockCommand'),
		eve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
				$metadata: D(e),
				[ZCe]: [, e.headers[wbe]],
				[YCe]: [, e.headers[bbe]],
				[e0e]: [, e.headers[Pbe]],
				[GCe]: [
					() => e.headers[mq] !== void 0,
					() => (0, a.parseBoolean)(e.headers[mq]),
				],
			})
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_HeadBucketCommand'),
		tve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
				$metadata: D(e),
				[fn]: [
					() => e.headers[Zi] !== void 0,
					() => (0, a.parseBoolean)(e.headers[Zi]),
				],
				[XS]: [, e.headers[TU]],
				[mr]: [, e.headers[ql]],
				[rC]: [, e.headers[m2]],
				[zCe]: [, e.headers[Ebe]],
				[dt]: [
					() => e.headers[Wa] !== void 0,
					() =>
						(0, a.expectNonNull)((0, a.parseRfc7231DateTime)(e.headers[Wa])),
				],
				[Qi]: [
					() => e.headers[cs] !== void 0,
					() => (0, a.strictParseLong)(e.headers[cs]),
				],
				[He]: [, e.headers[ps]],
				[$e]: [, e.headers[gs]],
				[Ve]: [, e.headers[vs]],
				[Ke]: [, e.headers[hs]],
				[We]: [, e.headers[Tp]],
				[gp]: [
					() => e.headers[Cp] !== void 0,
					() => (0, a.strictParseInt32)(e.headers[Cp]),
				],
				[Se]: [, e.headers[Gn]],
				[Za]: [, e.headers[Bl]],
				[ec]: [, e.headers[Nl]],
				[tc]: [, e.headers[Dl]],
				[rc]: [, e.headers[Ll]],
				[nc]: [, e.headers[Fl]],
				[jn]: [
					() => e.headers[ls] !== void 0,
					() =>
						(0, a.expectNonNull)((0, a.parseRfc7231DateTime)(e.headers[ls])),
				],
				[cU]: [, e.headers[BU]],
				[Tl]: [, e.headers[zl]],
				[br]: [, e.headers[hn]],
				[At]: [, e.headers[Ft]],
				[Ot]: [, e.headers[Mt]],
				[gr]: [, e.headers[_n]],
				[ct]: [
					() => e.headers[xt] !== void 0,
					() => (0, a.parseBoolean)(e.headers[xt]),
				],
				[_e]: [, e.headers[Gl]],
				[Ze]: [, e.headers[tt]],
				[tC]: [, e.headers[f2]],
				[Ka]: [
					() => e.headers[Ep] !== void 0,
					() => (0, a.strictParseInt32)(e.headers[Ep]),
				],
				[cc]: [, e.headers[Ul]],
				[Un]: [
					() => e.headers[ds] !== void 0,
					() =>
						(0, a.expectNonNull)(
							(0, a.parseRfc3339DateTimeWithOffset)(e.headers[ds]),
						),
				],
				[ms]: [, e.headers[jl]],
				Metadata: [
					,
					Object.keys(e.headers)
						.filter((n) => n.startsWith('x-amz-meta-'))
						.reduce((n, i) => ((n[i.substring(11)] = e.headers[i]), n), {}),
				],
			})
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_HeadObjectCommand'),
		rve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.AnalyticsConfiguration === ''
					? (r[W1] = [])
					: n[aS] != null &&
						(r[W1] = Rye((0, a.getArrayIfSingleItem)(n[aS]), t)),
				n[je] != null && (r[je] = (0, a.expectString)(n[je])),
				n[Le] != null && (r[Le] = (0, a.parseBoolean)(n[Le])),
				n[fr] != null && (r[fr] = (0, a.expectString)(n[fr])),
				r
			)
		}, 'de_ListBucketAnalyticsConfigurationsCommand'),
		nve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n[je] != null && (r[je] = (0, a.expectString)(n[je])),
				n.IntelligentTieringConfiguration === ''
					? (r[tq] = [])
					: n[bS] != null &&
						(r[tq] = lSe((0, a.getArrayIfSingleItem)(n[bS]), t)),
				n[Le] != null && (r[Le] = (0, a.parseBoolean)(n[Le])),
				n[fr] != null && (r[fr] = (0, a.expectString)(n[fr])),
				r
			)
		}, 'de_ListBucketIntelligentTieringConfigurationsCommand'),
		ive = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n[je] != null && (r[je] = (0, a.expectString)(n[je])),
				n.InventoryConfiguration === ''
					? (r[eq] = [])
					: n[ES] != null &&
						(r[eq] = uSe((0, a.getArrayIfSingleItem)(n[ES]), t)),
				n[Le] != null && (r[Le] = (0, a.parseBoolean)(n[Le])),
				n[fr] != null && (r[fr] = (0, a.expectString)(n[fr])),
				r
			)
		}, 'de_ListBucketInventoryConfigurationsCommand'),
		ove = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n[je] != null && (r[je] = (0, a.expectString)(n[je])),
				n[Le] != null && (r[Le] = (0, a.parseBoolean)(n[Le])),
				n.MetricsConfiguration === ''
					? (r[rq] = [])
					: n[xS] != null &&
						(r[rq] = OSe((0, a.getArrayIfSingleItem)(n[xS]), t)),
				n[fr] != null && (r[fr] = (0, a.expectString)(n[fr])),
				r
			)
		}, 'de_ListBucketMetricsConfigurationsCommand'),
		sve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.Buckets === ''
					? (r[Dn] = [])
					: n[Dn] != null &&
						n[Dn][Pe] != null &&
						(r[Dn] = jj((0, a.getArrayIfSingleItem)(n[Dn][Pe]), t)),
				n[je] != null && (r[je] = (0, a.expectString)(n[je])),
				n[ke] != null && (r[ke] = eo(n[ke], t)),
				r
			)
		}, 'de_ListBucketsCommand'),
		ave = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.Buckets === ''
					? (r[Dn] = [])
					: n[Dn] != null &&
						n[Dn][Pe] != null &&
						(r[Dn] = jj((0, a.getArrayIfSingleItem)(n[Dn][Pe]), t)),
				n[je] != null && (r[je] = (0, a.expectString)(n[je])),
				r
			)
		}, 'de_ListDirectoryBucketsCommand'),
		cve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n[Pe] != null && (r[Pe] = (0, a.expectString)(n[Pe])),
				n.CommonPrefixes === ''
					? (r[Qt] = [])
					: n[Qt] != null &&
						(r[Qt] = xp((0, a.getArrayIfSingleItem)(n[Qt]), t)),
				n[Zt] != null && (r[Zt] = (0, a.expectString)(n[Zt])),
				n[er] != null && (r[er] = (0, a.expectString)(n[er])),
				n[Le] != null && (r[Le] = (0, a.parseBoolean)(n[Le])),
				n[Xi] != null && (r[Xi] = (0, a.expectString)(n[Xi])),
				n[jf] != null && (r[jf] = (0, a.strictParseInt32)(n[jf])),
				n[La] != null && (r[La] = (0, a.expectString)(n[La])),
				n[Yy] != null && (r[Yy] = (0, a.expectString)(n[Yy])),
				n[H] != null && (r[H] = (0, a.expectString)(n[H])),
				n[ip] != null && (r[ip] = (0, a.expectString)(n[ip])),
				n.Upload === ''
					? (r[cq] = [])
					: n[aq] != null &&
						(r[cq] = ISe((0, a.getArrayIfSingleItem)(n[aq]), t)),
				r
			)
		}, 'de_ListMultipartUploadsCommand'),
		lve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.CommonPrefixes === ''
					? (r[Qt] = [])
					: n[Qt] != null &&
						(r[Qt] = xp((0, a.getArrayIfSingleItem)(n[Qt]), t)),
				n.Contents === ''
					? (r[Ki] = [])
					: n[Ki] != null &&
						(r[Ki] = Wj((0, a.getArrayIfSingleItem)(n[Ki]), t)),
				n[Zt] != null && (r[Zt] = (0, a.expectString)(n[Zt])),
				n[er] != null && (r[er] = (0, a.expectString)(n[er])),
				n[Le] != null && (r[Le] = (0, a.parseBoolean)(n[Le])),
				n[Mf] != null && (r[Mf] = (0, a.expectString)(n[Mf])),
				n[Vr] != null && (r[Vr] = (0, a.strictParseInt32)(n[Vr])),
				n[it] != null && (r[it] = (0, a.expectString)(n[it])),
				n[Xy] != null && (r[Xy] = (0, a.expectString)(n[Xy])),
				n[H] != null && (r[H] = (0, a.expectString)(n[H])),
				r
			)
		}, 'de_ListObjectsCommand'),
		dve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.CommonPrefixes === ''
					? (r[Qt] = [])
					: n[Qt] != null &&
						(r[Qt] = xp((0, a.getArrayIfSingleItem)(n[Qt]), t)),
				n.Contents === ''
					? (r[Ki] = [])
					: n[Ki] != null &&
						(r[Ki] = Wj((0, a.getArrayIfSingleItem)(n[Ki]), t)),
				n[je] != null && (r[je] = (0, a.expectString)(n[je])),
				n[Zt] != null && (r[Zt] = (0, a.expectString)(n[Zt])),
				n[er] != null && (r[er] = (0, a.expectString)(n[er])),
				n[Le] != null && (r[Le] = (0, a.parseBoolean)(n[Le])),
				n[Vy] != null && (r[Vy] = (0, a.strictParseInt32)(n[Vy])),
				n[Vr] != null && (r[Vr] = (0, a.strictParseInt32)(n[Vr])),
				n[it] != null && (r[it] = (0, a.expectString)(n[it])),
				n[fr] != null && (r[fr] = (0, a.expectString)(n[fr])),
				n[H] != null && (r[H] = (0, a.expectString)(n[H])),
				n[Jf] != null && (r[Jf] = (0, a.expectString)(n[Jf])),
				r
			)
		}, 'de_ListObjectsV2Command'),
		uve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] }),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n.CommonPrefixes === ''
					? (r[Qt] = [])
					: n[Qt] != null &&
						(r[Qt] = xp((0, a.getArrayIfSingleItem)(n[Qt]), t)),
				n.DeleteMarker === ''
					? (r[J1] = [])
					: n[fn] != null &&
						(r[J1] = Kye((0, a.getArrayIfSingleItem)(n[fn]), t)),
				n[Zt] != null && (r[Zt] = (0, a.expectString)(n[Zt])),
				n[er] != null && (r[er] = (0, a.expectString)(n[er])),
				n[Le] != null && (r[Le] = (0, a.parseBoolean)(n[Le])),
				n[Xi] != null && (r[Xi] = (0, a.expectString)(n[Xi])),
				n[Vr] != null && (r[Vr] = (0, a.strictParseInt32)(n[Vr])),
				n[it] != null && (r[it] = (0, a.expectString)(n[it])),
				n[La] != null && (r[La] = (0, a.expectString)(n[La])),
				n[Jy] != null && (r[Jy] = (0, a.expectString)(n[Jy])),
				n[H] != null && (r[H] = (0, a.expectString)(n[H])),
				n[sp] != null && (r[sp] = (0, a.expectString)(n[sp])),
				n.Version === ''
					? (r[dq] = [])
					: n[lq] != null &&
						(r[dq] = GSe((0, a.getArrayIfSingleItem)(n[lq]), t)),
				r
			)
		}, 'de_ListObjectVersionsCommand'),
		mve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
					$metadata: D(e),
					[Jj]: [
						() => e.headers[Sp] !== void 0,
						() =>
							(0, a.expectNonNull)((0, a.parseRfc7231DateTime)(e.headers[Sp])),
					],
					[Qj]: [, e.headers[e2]],
					[Ze]: [, e.headers[tt]],
				}),
				n = (0, a.expectNonNull)(
					(0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t)),
					'body',
				)
			return (
				n[Pe] != null && (r[Pe] = (0, a.expectString)(n[Pe])),
				n[Ce] != null && (r[Ce] = (0, a.expectString)(n[Ce])),
				n[Ia] != null && (r[Ia] = Hj(n[Ia], t)),
				n[Le] != null && (r[Le] = (0, a.parseBoolean)(n[Le])),
				n[pe] != null && (r[pe] = (0, a.expectString)(n[pe])),
				n[si] != null && (r[si] = (0, a.strictParseInt32)(n[si])),
				n[Fa] != null && (r[Fa] = (0, a.expectString)(n[Fa])),
				n[ke] != null && (r[ke] = eo(n[ke], t)),
				n[Yi] != null && (r[Yi] = (0, a.expectString)(n[Yi])),
				n.Part === ''
					? (r[Il] = [])
					: n[vp] != null &&
						(r[Il] = WSe((0, a.getArrayIfSingleItem)(n[vp]), t)),
				n[_e] != null && (r[_e] = (0, a.expectString)(n[_e])),
				n[Er] != null && (r[Er] = (0, a.expectString)(n[Er])),
				r
			)
		}, 'de_ListPartsCommand'),
		fve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketAccelerateConfigurationCommand'),
		pve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketAclCommand'),
		gve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketAnalyticsConfigurationCommand'),
		vve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketCorsCommand'),
		hve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketEncryptionCommand'),
		_ve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketIntelligentTieringConfigurationCommand'),
		yve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketInventoryConfigurationCommand'),
		Sve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketLifecycleConfigurationCommand'),
		Cve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketLoggingCommand'),
		Eve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketMetricsConfigurationCommand'),
		bve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketNotificationConfigurationCommand'),
		wve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketOwnershipControlsCommand'),
		xve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketPolicyCommand'),
		Pve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketReplicationCommand'),
		Ave = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketRequestPaymentCommand'),
		Ove = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketTaggingCommand'),
		Rve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketVersioningCommand'),
		kve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutBucketWebsiteCommand'),
		Ive = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
				$metadata: D(e),
				[mr]: [, e.headers[ql]],
				[We]: [, e.headers[Tp]],
				[He]: [, e.headers[ps]],
				[$e]: [, e.headers[gs]],
				[Ve]: [, e.headers[vs]],
				[Ke]: [, e.headers[hs]],
				[br]: [, e.headers[hn]],
				[Se]: [, e.headers[Gn]],
				[At]: [, e.headers[Ft]],
				[Ot]: [, e.headers[Mt]],
				[gr]: [, e.headers[_n]],
				[lc]: [, e.headers[vc]],
				[ct]: [
					() => e.headers[xt] !== void 0,
					() => (0, a.parseBoolean)(e.headers[xt]),
				],
				[Ze]: [, e.headers[tt]],
			})
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutObjectCommand'),
		Tve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutObjectAclCommand'),
		Bve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutObjectLegalHoldCommand'),
		Nve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutObjectLockConfigurationCommand'),
		Dve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Ze]: [, e.headers[tt]] })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutObjectRetentionCommand'),
		Lve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e), [Se]: [, e.headers[Gn]] })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutObjectTaggingCommand'),
		Fve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_PutPublicAccessBlockCommand'),
		Mve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
				$metadata: D(e),
				[Ze]: [, e.headers[tt]],
				[AEe]: [, e.headers[vwe]],
			})
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_RestoreObjectCommand'),
		qve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) }),
				n = e.body
			return (r.Payload = Zve(n, t)), r
		}, 'de_SelectObjectContentCommand'),
		jve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
				$metadata: D(e),
				[br]: [, e.headers[hn]],
				[We]: [, e.headers[Tp]],
				[He]: [, e.headers[ps]],
				[$e]: [, e.headers[gs]],
				[Ve]: [, e.headers[vs]],
				[Ke]: [, e.headers[hs]],
				[At]: [, e.headers[Ft]],
				[Ot]: [, e.headers[Mt]],
				[gr]: [, e.headers[_n]],
				[ct]: [
					() => e.headers[xt] !== void 0,
					() => (0, a.parseBoolean)(e.headers[xt]),
				],
				[Ze]: [, e.headers[tt]],
			})
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_UploadPartCommand'),
		Uve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({
					$metadata: D(e),
					[aU]: [, e.headers[u2]],
					[br]: [, e.headers[hn]],
					[At]: [, e.headers[Ft]],
					[Ot]: [, e.headers[Mt]],
					[gr]: [, e.headers[_n]],
					[ct]: [
						() => e.headers[xt] !== void 0,
						() => (0, a.parseBoolean)(e.headers[xt]),
					],
					[Ze]: [, e.headers[tt]],
				}),
				n = (0, a.expectObject)(await (0, me.parseXmlBody)(e.body, t))
			return (r.CopyPartResult = qye(n, t)), r
		}, 'de_UploadPartCopyCommand'),
		Gve = d(async (e, t) => {
			if (e.statusCode !== 200 && e.statusCode >= 300) return z(e, t)
			let r = (0, a.map)({ $metadata: D(e) })
			return await (0, a.collectBody)(e.body, t), r
		}, 'de_WriteGetObjectResponseCommand'),
		z = d(async (e, t) => {
			let r = { ...e, body: await (0, me.parseXmlErrorBody)(e.body, t) },
				n = (0, me.loadRestXmlErrorCode)(e, r.body)
			switch (n) {
				case 'NoSuchUpload':
				case 'com.amazonaws.s3#NoSuchUpload':
					throw await Xve(r, t)
				case 'ObjectNotInActiveTierError':
				case 'com.amazonaws.s3#ObjectNotInActiveTierError':
					throw await Qve(r, t)
				case 'BucketAlreadyExists':
				case 'com.amazonaws.s3#BucketAlreadyExists':
					throw await Hve(r, t)
				case 'BucketAlreadyOwnedByYou':
				case 'com.amazonaws.s3#BucketAlreadyOwnedByYou':
					throw await $ve(r, t)
				case 'NoSuchBucket':
				case 'com.amazonaws.s3#NoSuchBucket':
					throw await Kve(r, t)
				case 'InvalidObjectState':
				case 'com.amazonaws.s3#InvalidObjectState':
					throw await Vve(r, t)
				case 'NoSuchKey':
				case 'com.amazonaws.s3#NoSuchKey':
					throw await Wve(r, t)
				case 'NotFound':
				case 'com.amazonaws.s3#NotFound':
					throw await Yve(r, t)
				case 'ObjectAlreadyInActiveTierError':
				case 'com.amazonaws.s3#ObjectAlreadyInActiveTierError':
					throw await Jve(r, t)
				default:
					let i = r.body
					return zve({ output: e, parsedBody: i, errorCode: n })
			}
		}, 'de_CommandError'),
		zve = (0, a.withBaseException)(gn),
		Hve = d(async (e, t) => {
			let r = (0, a.map)({}),
				n = e.body,
				i = new Oq({ $metadata: D(e), ...r })
			return (0, a.decorateServiceException)(i, e.body)
		}, 'de_BucketAlreadyExistsRes'),
		$ve = d(async (e, t) => {
			let r = (0, a.map)({}),
				n = e.body,
				i = new Iq({ $metadata: D(e), ...r })
			return (0, a.decorateServiceException)(i, e.body)
		}, 'de_BucketAlreadyOwnedByYouRes'),
		Vve = d(async (e, t) => {
			let r = (0, a.map)({}),
				n = e.body
			n[oi] != null && (r[oi] = (0, a.expectString)(n[oi])),
				n[_e] != null && (r[_e] = (0, a.expectString)(n[_e]))
			let i = new Fq({ $metadata: D(e), ...r })
			return (0, a.decorateServiceException)(i, e.body)
		}, 'de_InvalidObjectStateRes'),
		Kve = d(async (e, t) => {
			let r = (0, a.map)({}),
				n = e.body,
				i = new Nq({ $metadata: D(e), ...r })
			return (0, a.decorateServiceException)(i, e.body)
		}, 'de_NoSuchBucketRes'),
		Wve = d(async (e, t) => {
			let r = (0, a.map)({}),
				n = e.body,
				i = new jq({ $metadata: D(e), ...r })
			return (0, a.decorateServiceException)(i, e.body)
		}, 'de_NoSuchKeyRes'),
		Xve = d(async (e, t) => {
			let r = (0, a.map)({}),
				n = e.body,
				i = new Eq({ $metadata: D(e), ...r })
			return (0, a.decorateServiceException)(i, e.body)
		}, 'de_NoSuchUploadRes'),
		Yve = d(async (e, t) => {
			let r = (0, a.map)({}),
				n = e.body,
				i = new zq({ $metadata: D(e), ...r })
			return (0, a.decorateServiceException)(i, e.body)
		}, 'de_NotFoundRes'),
		Jve = d(async (e, t) => {
			let r = (0, a.map)({}),
				n = e.body,
				i = new _j({ $metadata: D(e), ...r })
			return (0, a.decorateServiceException)(i, e.body)
		}, 'de_ObjectAlreadyInActiveTierErrorRes'),
		Qve = d(async (e, t) => {
			let r = (0, a.map)({}),
				n = e.body,
				i = new xq({ $metadata: D(e), ...r })
			return (0, a.decorateServiceException)(i, e.body)
		}, 'de_ObjectNotInActiveTierErrorRes'),
		Zve = d(
			(e, t) =>
				t.eventStreamMarshaller.deserialize(e, async (r) =>
					r.Records != null
						? { Records: await nhe(r.Records, t) }
						: r.Stats != null
							? { Stats: await ihe(r.Stats, t) }
							: r.Progress != null
								? { Progress: await rhe(r.Progress, t) }
								: r.Cont != null
									? { Cont: await ehe(r.Cont, t) }
									: r.End != null
										? { End: await the(r.End, t) }
										: { $unknown: e },
				),
			'de_SelectObjectContentEventStream',
		),
		ehe = d(async (e, t) => {
			let r = {},
				n = await (0, me.parseXmlBody)(e.body, t)
			return Object.assign(r, Fye(n, t)), r
		}, 'de_ContinuationEvent_event'),
		the = d(async (e, t) => {
			let r = {},
				n = await (0, me.parseXmlBody)(e.body, t)
			return Object.assign(r, Yye(n, t)), r
		}, 'de_EndEvent_event'),
		rhe = d(async (e, t) => {
			let r = {},
				n = await (0, me.parseXmlBody)(e.body, t)
			return (r.Details = JSe(n, t)), r
		}, 'de_ProgressEvent_event'),
		nhe = d(async (e, t) => {
			let r = {}
			return (r.Payload = e.body), r
		}, 'de_RecordsEvent_event'),
		ihe = d(async (e, t) => {
			let r = {},
				n = await (0, me.parseXmlBody)(e.body, t)
			return (r.Details = bCe(n, t)), r
		}, 'de_StatsEvent_event'),
		ohe = d((e, t) => {
			let r = new S.XmlNode(Do)
			return e[Po] != null && r.c(S.XmlNode.of(Po, String(e[Po])).n(Po)), r
		}, 'se_AbortIncompleteMultipartUpload'),
		she = d((e, t) => {
			let r = new S.XmlNode(MCe)
			return e[J] != null && r.c(S.XmlNode.of(VCe, e[J]).n(J)), r
		}, 'se_AccelerateConfiguration'),
		Bj = d((e, t) => {
			let r = new S.XmlNode(FCe)
			return (
				r.lc(e, 'Grants', 'AccessControlList', () => Dj(e[kl], t)),
				e[ke] != null && r.c(A_e(e[ke], t).n(ke)),
				r
			)
		}, 'se_AccessControlPolicy'),
		ahe = d((e, t) => {
			let r = new S.XmlNode(No)
			return e[ke] != null && r.c(S.XmlNode.of(yEe, e[ke]).n(ke)), r
		}, 'se_AccessControlTranslation'),
		che = d(
			(e, t) =>
				e.filter((r) => r != null).map((r) => S.XmlNode.of(cS, r).n(kt)),
			'se_AllowedHeaders',
		),
		lhe = d(
			(e, t) =>
				e.filter((r) => r != null).map((r) => S.XmlNode.of(dS, r).n(kt)),
			'se_AllowedMethods',
		),
		dhe = d(
			(e, t) =>
				e.filter((r) => r != null).map((r) => S.XmlNode.of(mS, r).n(kt)),
			'se_AllowedOrigins',
		),
		uhe = d((e, t) => {
			let r = new S.XmlNode(LCe)
			return r.cc(e, H), r.l(e, 'Tags', 'Tag', () => Ya(e[pr], t)), r
		}, 'se_AnalyticsAndOperator'),
		mhe = d((e, t) => {
			let r = new S.XmlNode(aS)
			return (
				e[ce] != null && r.c(S.XmlNode.of(UCe, e[ce]).n(ce)),
				e[ae] != null && r.c(phe(e[ae], t).n(ae)),
				e[ts] != null && r.c(lye(e[ts], t).n(ts)),
				r
			)
		}, 'se_AnalyticsConfiguration'),
		fhe = d((e, t) => {
			let r = new S.XmlNode(qCe)
			return e[Yr] != null && r.c(ghe(e[Yr], t).n(Yr)), r
		}, 'se_AnalyticsExportDestination'),
		phe = d((e, t) => {
			let r = new S.XmlNode(jCe)
			return (
				ap.visit(e, {
					Prefix: (n) => {
						e[H] != null && r.c(S.XmlNode.of(H, n).n(H))
					},
					Tag: (n) => {
						e[Ee] != null && r.c(Xa(n, t).n(Ee))
					},
					And: (n) => {
						e[ft] != null && r.c(uhe(n, t).n(ft))
					},
					_: (n, i) => {
						if (!(i instanceof S.XmlNode || i instanceof S.XmlText))
							throw new Error(
								'Unable to serialize unknown union members in XML.',
							)
						r.c(new S.XmlNode(n).c(i))
					},
				}),
				r
			)
		}, 'se_AnalyticsFilter'),
		ghe = d((e, t) => {
			let r = new S.XmlNode(HCe)
			return (
				e[$r] != null && r.c(S.XmlNode.of($Ce, e[$r]).n($r)),
				e[_a] != null && r.c(S.XmlNode.of(ga, e[_a]).n(_a)),
				e[Pe] != null && r.c(S.XmlNode.of(Pp, e[Pe]).n(Pe)),
				r.cc(e, H),
				r
			)
		}, 'se_AnalyticsS3BucketDestination'),
		vhe = d((e, t) => {
			let r = new S.XmlNode(KCe)
			return (
				r.cc(e, f0e), e[Cr] != null && r.c(S.XmlNode.of(t0e, e[Cr]).n(Cr)), r
			)
		}, 'se_BucketInfo'),
		hhe = d((e, t) => {
			let r = new S.XmlNode(WCe)
			return r.l(e, 'Rules', 'Rule', () => c_e(e[Qr], t)), r
		}, 'se_BucketLifecycleConfiguration'),
		_he = d((e, t) => {
			let r = new S.XmlNode(QCe)
			return e[Vo] != null && r.c(d_e(e[Vo], t).n(Vo)), r
		}, 'se_BucketLoggingStatus'),
		yhe = d((e, t) => {
			let r = new S.XmlNode(i0e)
			return r.l(e, 'Parts', 'Part', () => Che(e[Il], t)), r
		}, 'se_CompletedMultipartUpload'),
		She = d((e, t) => {
			let r = new S.XmlNode(s0e)
			return (
				r.cc(e, We),
				r.cc(e, He),
				r.cc(e, $e),
				r.cc(e, Ve),
				r.cc(e, Ke),
				e[yr] != null && r.c(S.XmlNode.of(yr, String(e[yr])).n(yr)),
				r
			)
		}, 'se_CompletedPart'),
		Che = d(
			(e, t) => e.filter((r) => r != null).map((r) => She(r, t).n(kt)),
			'se_CompletedPartList',
		),
		Ehe = d((e, t) => {
			let r = new S.XmlNode(Lo)
			return r.cc(e, Nf), r.cc(e, Lf), r
		}, 'se_Condition'),
		bhe = d((e, t) => {
			let r = new S.XmlNode(o0e)
			return r.l(e, 'CORSRules', 'CORSRule', () => xhe(e[vS], t)), r
		}, 'se_CORSConfiguration'),
		whe = d((e, t) => {
			let r = new S.XmlNode(gS)
			return (
				r.cc(e, lt),
				r.l(e, 'AllowedHeaders', 'AllowedHeader', () => che(e[lS], t)),
				r.l(e, 'AllowedMethods', 'AllowedMethod', () => lhe(e[uS], t)),
				r.l(e, 'AllowedOrigins', 'AllowedOrigin', () => dhe(e[fS], t)),
				r.l(e, 'ExposeHeaders', 'ExposeHeader', () => Mhe(e[hS], t)),
				e[Ro] != null && r.c(S.XmlNode.of(Ro, String(e[Ro])).n(Ro)),
				r
			)
		}, 'se_CORSRule'),
		xhe = d(
			(e, t) => e.filter((r) => r != null).map((r) => whe(r, t).n(kt)),
			'se_CORSRules',
		),
		Phe = d((e, t) => {
			let r = new S.XmlNode(n0e)
			return (
				e[Da] != null && r.c(S.XmlNode.of(XCe, e[Da]).n(Da)),
				e[$o] != null && r.c(l_e(e[$o], t).n($o)),
				e[Pe] != null && r.c(vhe(e[Pe], t).n(Pe)),
				r
			)
		}, 'se_CreateBucketConfiguration'),
		Ahe = d((e, t) => {
			let r = new S.XmlNode(c0e)
			return (
				r.cc(e, C0e),
				r.cc(e, u0e),
				r.cc(e, yU),
				r.cc(e, eC),
				r.cc(e, mU),
				r.cc(e, _U),
				e[xf] != null && r.c(S.XmlNode.of(xf, String(e[xf])).n(xf)),
				r
			)
		}, 'se_CSVInput'),
		Ohe = d((e, t) => {
			let r = new S.XmlNode(l0e)
			return r.cc(e, wEe), r.cc(e, yU), r.cc(e, eC), r.cc(e, mU), r.cc(e, _U), r
		}, 'se_CSVOutput'),
		Rhe = d((e, t) => {
			let r = new S.XmlNode(Mo)
			return (
				e[Kr] != null && r.c(S.XmlNode.of(gU, e[Kr]).n(Kr)),
				e[Ie] != null && r.c(S.XmlNode.of(Ie, String(e[Ie])).n(Ie)),
				e[To] != null && r.c(S.XmlNode.of(To, String(e[To])).n(To)),
				r
			)
		}, 'se_DefaultRetention'),
		khe = d((e, t) => {
			let r = new S.XmlNode(p0e)
			return (
				r.l(e, 'Objects', 'Object', () => C_e(e[CEe], t)),
				e[Of] != null && r.c(S.XmlNode.of(Of, String(e[Of])).n(Of)),
				r
			)
		}, 'se_Delete'),
		Ihe = d((e, t) => {
			let r = new S.XmlNode(Fo)
			return e[J] != null && r.c(S.XmlNode.of(m0e, e[J]).n(J)), r
		}, 'se_DeleteMarkerReplication'),
		The = d((e, t) => {
			let r = new S.XmlNode(wt)
			return (
				e[Pe] != null && r.c(S.XmlNode.of(Pp, e[Pe]).n(Pe)),
				e[ha] != null && r.c(S.XmlNode.of(ga, e[ha]).n(ha)),
				r.cc(e, _e),
				e[No] != null && r.c(ahe(e[No], t).n(No)),
				e[jo] != null && r.c(Nhe(e[jo], t).n(jo)),
				e[Zo] != null && r.c(H_e(e[Zo], t).n(Zo)),
				e[Ko] != null && r.c(m_e(e[Ko], t).n(Ko)),
				r
			)
		}, 'se_Destination'),
		Bhe = d((e, t) => {
			let r = new S.XmlNode(Ln)
			return (
				e[Uy] != null && r.c(S.XmlNode.of(br, e[Uy]).n(Uy)),
				e[Ky] != null && r.c(S.XmlNode.of(gr, e[Ky]).n(Ky)),
				r.cc(e, H0e),
				r
			)
		}, 'se_Encryption'),
		Nhe = d((e, t) => {
			let r = new S.XmlNode(jo)
			return r.cc(e, Vf), r
		}, 'se_EncryptionConfiguration'),
		Dhe = d((e, t) => {
			let r = new S.XmlNode(Uo)
			return e[pe] != null && r.c(S.XmlNode.of(ZS, e[pe]).n(pe)), r
		}, 'se_ErrorDocument'),
		Lhe = d((e, t) => new S.XmlNode(qo), 'se_EventBridgeConfiguration'),
		HS = d(
			(e, t) =>
				e.filter((r) => r != null).map((r) => S.XmlNode.of(as, r).n(kt)),
			'se_EventList',
		),
		Fhe = d((e, t) => {
			let r = new S.XmlNode(Go)
			return e[J] != null && r.c(S.XmlNode.of(_0e, e[J]).n(J)), r
		}, 'se_ExistingObjectReplication'),
		Mhe = d(
			(e, t) =>
				e.filter((r) => r != null).map((r) => S.XmlNode.of(_S, r).n(kt)),
			'se_ExposeHeaders',
		),
		qhe = d((e, t) => {
			let r = new S.XmlNode(yS)
			return (
				e[it] != null && r.c(S.XmlNode.of(b0e, e[it]).n(it)),
				e[kr] != null && r.c(S.XmlNode.of(w0e, e[kr]).n(kr)),
				r
			)
		}, 'se_FilterRule'),
		jhe = d(
			(e, t) => e.filter((r) => r != null).map((r) => qhe(r, t).n(kt)),
			'se_FilterRuleList',
		),
		Uhe = d((e, t) => {
			let r = new S.XmlNode(Bf)
			return r.cc(e, OU), r
		}, 'se_GlacierJobParameters'),
		Ghe = d((e, t) => {
			let r = new S.XmlNode(ci)
			if (e[Rr] != null) {
				let n = Nj(e[Rr], t).n(Rr)
				n.a('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance'), r.c(n)
			}
			return r.cc(e, qn), r
		}, 'se_Grant'),
		Nj = d((e, t) => {
			let r = new S.XmlNode(Rr)
			return (
				r.cc(e, pn),
				r.cc(e, Tf),
				r.cc(e, lt),
				r.cc(e, op),
				r.a('xsi:type', e[Cr]),
				r
			)
		}, 'se_Grantee'),
		Dj = d(
			(e, t) => e.filter((r) => r != null).map((r) => Ghe(r, t).n(ci)),
			'se_Grants',
		),
		zhe = d((e, t) => {
			let r = new S.XmlNode(zo)
			return r.cc(e, ep), r
		}, 'se_IndexDocument'),
		Lj = d((e, t) => {
			let r = new S.XmlNode(Ho)
			return (
				e[wa] != null && r.c(Ahe(e[wa], t).n(wa)),
				r.cc(e, d0e),
				e[Ta] != null && r.c(e_e(e[Ta], t).n(Ta)),
				e[eS] != null && r.c(I_e(e[eS], t).n(eS)),
				r
			)
		}, 'se_InputSerialization'),
		Hhe = d((e, t) => {
			let r = new S.XmlNode(D0e)
			return r.cc(e, H), r.l(e, 'Tags', 'Tag', () => Ya(e[pr], t)), r
		}, 'se_IntelligentTieringAndOperator'),
		$he = d((e, t) => {
			let r = new S.XmlNode(bS)
			return (
				e[ce] != null && r.c(S.XmlNode.of(q0e, e[ce]).n(ce)),
				e[ae] != null && r.c(Vhe(e[ae], t).n(ae)),
				e[J] != null && r.c(S.XmlNode.of(j0e, e[J]).n(J)),
				r.l(e, 'Tierings', 'Tiering', () => gye(e[MS], t)),
				r
			)
		}, 'se_IntelligentTieringConfiguration'),
		Vhe = d((e, t) => {
			let r = new S.XmlNode(M0e)
			return (
				r.cc(e, H),
				e[Ee] != null && r.c(Xa(e[Ee], t).n(Ee)),
				e[ft] != null && r.c(Hhe(e[ft], t).n(ft)),
				r
			)
		}, 'se_IntelligentTieringFilter'),
		Khe = d((e, t) => {
			let r = new S.XmlNode(ES)
			return (
				e[wt] != null && r.c(Whe(e[wt], t).n(wt)),
				e[Oo] != null && r.c(S.XmlNode.of(Oo, String(e[Oo])).n(Oo)),
				e[ae] != null && r.c(Yhe(e[ae], t).n(ae)),
				e[ce] != null && r.c(S.XmlNode.of(k0e, e[ce]).n(ce)),
				e[Ra] != null && r.c(S.XmlNode.of(I0e, e[Ra]).n(Ra)),
				r.lc(e, 'OptionalFields', 'OptionalFields', () => Jhe(e[ma], t)),
				e[za] != null && r.c(Zhe(e[za], t).n(za)),
				r
			)
		}, 'se_InventoryConfiguration'),
		Whe = d((e, t) => {
			let r = new S.XmlNode(x0e)
			return e[Yr] != null && r.c(Qhe(e[Yr], t).n(Yr)), r
		}, 'se_InventoryDestination'),
		Xhe = d((e, t) => {
			let r = new S.XmlNode(P0e)
			return (
				e[NS] != null && r.c(cye(e[NS], t).n(yp)),
				e[BS] != null && r.c(sye(e[BS], t).n(_p)),
				r
			)
		}, 'se_InventoryEncryption'),
		Yhe = d((e, t) => {
			let r = new S.XmlNode(A0e)
			return r.cc(e, H), r
		}, 'se_InventoryFilter'),
		Jhe = d(
			(e, t) =>
				e.filter((r) => r != null).map((r) => S.XmlNode.of(T0e, r).n(CS)),
			'se_InventoryOptionalFields',
		),
		Qhe = d((e, t) => {
			let r = new S.XmlNode(B0e)
			return (
				r.cc(e, ga),
				e[Pe] != null && r.c(S.XmlNode.of(Pp, e[Pe]).n(Pe)),
				e[$r] != null && r.c(S.XmlNode.of(O0e, e[$r]).n($r)),
				r.cc(e, H),
				e[Ln] != null && r.c(Xhe(e[Ln], t).n(Ln)),
				r
			)
		}, 'se_InventoryS3BucketDestination'),
		Zhe = d((e, t) => {
			let r = new S.XmlNode(N0e)
			return e[Aa] != null && r.c(S.XmlNode.of(R0e, e[Aa]).n(Aa)), r
		}, 'se_InventorySchedule'),
		e_e = d((e, t) => {
			let r = new S.XmlNode(U0e)
			return e[Cr] != null && r.c(S.XmlNode.of(z0e, e[Cr]).n(Cr)), r
		}, 'se_JSONInput'),
		t_e = d((e, t) => {
			let r = new S.XmlNode(G0e)
			return r.cc(e, eC), r
		}, 'se_JSONOutput'),
		r_e = d((e, t) => {
			let r = new S.XmlNode(V0e)
			return (
				e[ce] != null && r.c(S.XmlNode.of(QS, e[ce]).n(ce)),
				e[Ff] != null && r.c(S.XmlNode.of(Ff, e[Ff]).n(pS)),
				r.l(e, 'Events', 'Event', () => HS(e[ai], t)),
				e[ae] != null && r.c($S(e[ae], t).n(ae)),
				r
			)
		}, 'se_LambdaFunctionConfiguration'),
		n_e = d(
			(e, t) => e.filter((r) => r != null).map((r) => r_e(r, t).n(kt)),
			'se_LambdaFunctionConfigurationList',
		),
		i_e = d((e, t) => {
			let r = new S.XmlNode($0e)
			return (
				e[ur] != null &&
					r.c(
						S.XmlNode.of(ur, (0, a.serializeDateTime)(e[ur]).toString()).n(ur),
					),
				e[Ie] != null && r.c(S.XmlNode.of(Ie, String(e[Ie])).n(Ie)),
				e[Ao] != null && r.c(S.XmlNode.of(Ao, String(e[Ao])).n(Ao)),
				r
			)
		}, 'se_LifecycleExpiration'),
		o_e = d((e, t) => {
			let r = new S.XmlNode(Y0e)
			return (
				e[mr] != null && r.c(i_e(e[mr], t).n(mr)),
				r.cc(e, lt),
				r.cc(e, H),
				e[ae] != null && r.c(a_e(e[ae], t).n(ae)),
				e[J] != null && r.c(S.XmlNode.of(S0e, e[J]).n(J)),
				r.l(e, 'Transitions', 'Transition', () => yye(e[US], t)),
				r.l(
					e,
					'NoncurrentVersionTransitions',
					'NoncurrentVersionTransition',
					() => __e(e[AS], t),
				),
				e[Wo] != null && r.c(v_e(e[Wo], t).n(Wo)),
				e[Do] != null && r.c(ohe(e[Do], t).n(Do)),
				r
			)
		}, 'se_LifecycleRule'),
		s_e = d((e, t) => {
			let r = new S.XmlNode(J0e)
			return (
				r.cc(e, H),
				r.l(e, 'Tags', 'Tag', () => Ya(e[pr], t)),
				e[Fn] != null && r.c(S.XmlNode.of(vU, String(e[Fn])).n(Fn)),
				e[Mn] != null && r.c(S.XmlNode.of(hU, String(e[Mn])).n(Mn)),
				r
			)
		}, 'se_LifecycleRuleAndOperator'),
		a_e = d((e, t) => {
			let r = new S.XmlNode(Q0e)
			return (
				cp.visit(e, {
					Prefix: (n) => {
						e[H] != null && r.c(S.XmlNode.of(H, n).n(H))
					},
					Tag: (n) => {
						e[Ee] != null && r.c(Xa(n, t).n(Ee))
					},
					ObjectSizeGreaterThan: (n) => {
						e[Fn] != null && r.c(S.XmlNode.of(vU, String(n)).n(Fn))
					},
					ObjectSizeLessThan: (n) => {
						e[Mn] != null && r.c(S.XmlNode.of(hU, String(n)).n(Mn))
					},
					And: (n) => {
						e[ft] != null && r.c(s_e(n, t).n(ft))
					},
					_: (n, i) => {
						if (!(i instanceof S.XmlNode || i instanceof S.XmlText))
							throw new Error(
								'Unable to serialize unknown union members in XML.',
							)
						r.c(new S.XmlNode(n).c(i))
					},
				}),
				r
			)
		}, 'se_LifecycleRuleFilter'),
		c_e = d(
			(e, t) => e.filter((r) => r != null).map((r) => o_e(r, t).n(kt)),
			'se_LifecycleRules',
		),
		l_e = d((e, t) => {
			let r = new S.XmlNode(K0e)
			return (
				e[Cr] != null && r.c(S.XmlNode.of(Z0e, e[Cr]).n(Cr)),
				e[it] != null && r.c(S.XmlNode.of(W0e, e[it]).n(it)),
				r
			)
		}, 'se_LocationInfo'),
		d_e = d((e, t) => {
			let r = new S.XmlNode(Vo)
			return (
				r.cc(e, rp),
				r.lc(e, 'TargetGrants', 'TargetGrants', () => mye(e[pa], t)),
				r.cc(e, np),
				e[ss] != null && r.c(fye(e[ss], t).n(ss)),
				r
			)
		}, 'se_LoggingEnabled'),
		u_e = d((e, t) => {
			let r = new S.XmlNode(pU)
			return (
				e[it] != null && r.c(S.XmlNode.of(sEe, e[it]).n(it)),
				e[kr] != null && r.c(S.XmlNode.of(cEe, e[kr]).n(kr)),
				r
			)
		}, 'se_MetadataEntry'),
		m_e = d((e, t) => {
			let r = new S.XmlNode(Ko)
			return (
				e[J] != null && r.c(S.XmlNode.of(aEe, e[J]).n(J)),
				e[Pa] != null && r.c(Mj(e[Pa], t).n(Pa)),
				r
			)
		}, 'se_Metrics'),
		f_e = d((e, t) => {
			let r = new S.XmlNode(eEe)
			return (
				r.cc(e, H), r.l(e, 'Tags', 'Tag', () => Ya(e[pr], t)), r.cc(e, ii), r
			)
		}, 'se_MetricsAndOperator'),
		p_e = d((e, t) => {
			let r = new S.XmlNode(xS)
			return (
				e[ce] != null && r.c(S.XmlNode.of(oEe, e[ce]).n(ce)),
				e[ae] != null && r.c(g_e(e[ae], t).n(ae)),
				r
			)
		}, 'se_MetricsConfiguration'),
		g_e = d((e, t) => {
			let r = new S.XmlNode(iEe)
			return (
				lp.visit(e, {
					Prefix: (n) => {
						e[H] != null && r.c(S.XmlNode.of(H, n).n(H))
					},
					Tag: (n) => {
						e[Ee] != null && r.c(Xa(n, t).n(Ee))
					},
					AccessPointArn: (n) => {
						e[ii] != null && r.c(S.XmlNode.of(ii, n).n(ii))
					},
					And: (n) => {
						e[ft] != null && r.c(f_e(n, t).n(ft))
					},
					_: (n, i) => {
						if (!(i instanceof S.XmlNode || i instanceof S.XmlText))
							throw new Error(
								'Unable to serialize unknown union members in XML.',
							)
						r.c(new S.XmlNode(n).c(i))
					},
				}),
				r
			)
		}, 'se_MetricsFilter'),
		v_e = d((e, t) => {
			let r = new S.XmlNode(Wo)
			return (
				e[Wr] != null && r.c(S.XmlNode.of(Ie, String(e[Wr])).n(Wr)),
				e[Xr] != null && r.c(S.XmlNode.of(kU, String(e[Xr])).n(Xr)),
				r
			)
		}, 'se_NoncurrentVersionExpiration'),
		h_e = d((e, t) => {
			let r = new S.XmlNode(OS)
			return (
				e[Wr] != null && r.c(S.XmlNode.of(Ie, String(e[Wr])).n(Wr)),
				e[_e] != null && r.c(S.XmlNode.of(AU, e[_e]).n(_e)),
				e[Xr] != null && r.c(S.XmlNode.of(kU, String(e[Xr])).n(Xr)),
				r
			)
		}, 'se_NoncurrentVersionTransition'),
		__e = d(
			(e, t) => e.filter((r) => r != null).map((r) => h_e(r, t).n(kt)),
			'se_NoncurrentVersionTransitionList',
		),
		y_e = d((e, t) => {
			let r = new S.XmlNode(lEe)
			return (
				r.l(e, 'TopicConfigurations', 'TopicConfiguration', () =>
					hye(e[FS], t),
				),
				r.l(e, 'QueueConfigurations', 'QueueConfiguration', () =>
					D_e(e[kS], t),
				),
				r.l(
					e,
					'LambdaFunctionConfigurations',
					'CloudFunctionConfiguration',
					() => n_e(e[wS], t),
				),
				e[qo] != null && r.c(Lhe(e[qo], t).n(qo)),
				r
			)
		}, 'se_NotificationConfiguration'),
		$S = d((e, t) => {
			let r = new S.XmlNode(dEe)
			return e[pe] != null && r.c(Y_e(e[pe], t).n(TS)), r
		}, 'se_NotificationConfigurationFilter'),
		S_e = d((e, t) => {
			let r = new S.XmlNode(pEe)
			return (
				e[pe] != null && r.c(S.XmlNode.of(ZS, e[pe]).n(pe)),
				e[Se] != null && r.c(S.XmlNode.of(SEe, e[Se]).n(Se)),
				r
			)
		}, 'se_ObjectIdentifier'),
		C_e = d(
			(e, t) => e.filter((r) => r != null).map((r) => S_e(r, t).n(kt)),
			'se_ObjectIdentifierList',
		),
		E_e = d((e, t) => {
			let r = new S.XmlNode(gEe)
			return r.cc(e, Gf), e[Sr] != null && r.c(x_e(e[Sr], t).n(Sr)), r
		}, 'se_ObjectLockConfiguration'),
		b_e = d((e, t) => {
			let r = new S.XmlNode(vEe)
			return e[J] != null && r.c(S.XmlNode.of(ms, e[J]).n(J)), r
		}, 'se_ObjectLockLegalHold'),
		w_e = d((e, t) => {
			let r = new S.XmlNode(hEe)
			return (
				e[Kr] != null && r.c(S.XmlNode.of(gU, e[Kr]).n(Kr)),
				e[Ua] != null &&
					r.c(
						S.XmlNode.of(ur, (0, a.serializeDateTime)(e[Ua]).toString()).n(Ua),
					),
				r
			)
		}, 'se_ObjectLockRetention'),
		x_e = d((e, t) => {
			let r = new S.XmlNode(_Ee)
			return e[Mo] != null && r.c(Rhe(e[Mo], t).n(Mo)), r
		}, 'se_ObjectLockRule'),
		P_e = d((e, t) => {
			let r = new S.XmlNode(Uf)
			return e[iS] != null && r.c(J_e(e[iS], t).n(iS)), r
		}, 'se_OutputLocation'),
		Fj = d((e, t) => {
			let r = new S.XmlNode(Xo)
			return (
				e[wa] != null && r.c(Ohe(e[wa], t).n(wa)),
				e[Ta] != null && r.c(t_e(e[Ta], t).n(Ta)),
				r
			)
		}, 'se_OutputSerialization'),
		A_e = d((e, t) => {
			let r = new S.XmlNode(ke)
			return r.cc(e, pn), r.cc(e, lt), r
		}, 'se_Owner'),
		O_e = d((e, t) => {
			let r = new S.XmlNode(uEe)
			return r.l(e, 'Rules', 'Rule', () => k_e(e[Qr], t)), r
		}, 'se_OwnershipControls'),
		R_e = d((e, t) => {
			let r = new S.XmlNode(fEe)
			return r.cc(e, Rl), r
		}, 'se_OwnershipControlsRule'),
		k_e = d(
			(e, t) => e.filter((r) => r != null).map((r) => R_e(r, t).n(kt)),
			'se_OwnershipControlsRules',
		),
		I_e = d((e, t) => new S.XmlNode(bEe), 'se_ParquetInput'),
		T_e = d((e, t) => {
			let r = new S.XmlNode(Yo)
			return r.cc(e, zf), r
		}, 'se_PartitionedPrefix'),
		B_e = d((e, t) => {
			let r = new S.XmlNode(EEe)
			return (
				e[Sa] != null && r.c(S.XmlNode.of(Rf, String(e[Sa])).n(Sa)),
				e[ka] != null && r.c(S.XmlNode.of(Rf, String(e[ka])).n(ka)),
				e[Ca] != null && r.c(S.XmlNode.of(Rf, String(e[Ca])).n(Ca)),
				e[qa] != null && r.c(S.XmlNode.of(Rf, String(e[qa])).n(qa)),
				r
			)
		}, 'se_PublicAccessBlockConfiguration'),
		N_e = d((e, t) => {
			let r = new S.XmlNode(RS)
			return (
				e[ce] != null && r.c(S.XmlNode.of(QS, e[ce]).n(ce)),
				e[$f] != null && r.c(S.XmlNode.of($f, e[$f]).n(IS)),
				r.l(e, 'Events', 'Event', () => HS(e[ai], t)),
				e[ae] != null && r.c($S(e[ae], t).n(ae)),
				r
			)
		}, 'se_QueueConfiguration'),
		D_e = d(
			(e, t) => e.filter((r) => r != null).map((r) => N_e(r, t).n(kt)),
			'se_QueueConfigurationList',
		),
		L_e = d((e, t) => {
			let r = new S.XmlNode(es)
			return r.cc(e, Wi), r.cc(e, Df), r.cc(e, Ji), r.cc(e, Kf), r.cc(e, Wf), r
		}, 'se_Redirect'),
		F_e = d((e, t) => {
			let r = new S.XmlNode(Jo)
			return r.cc(e, Wi), r.cc(e, Ji), r
		}, 'se_RedirectAllRequestsTo'),
		M_e = d((e, t) => {
			let r = new S.XmlNode(Qo)
			return e[J] != null && r.c(S.XmlNode.of(PEe, e[J]).n(J)), r
		}, 'se_ReplicaModifications'),
		q_e = d((e, t) => {
			let r = new S.XmlNode(xEe)
			return r.cc(e, Yf), r.l(e, 'Rules', 'Rule', () => z_e(e[Qr], t)), r
		}, 'se_ReplicationConfiguration'),
		j_e = d((e, t) => {
			let r = new S.XmlNode(NEe)
			return (
				r.cc(e, lt),
				e[Io] != null && r.c(S.XmlNode.of(Io, String(e[Io])).n(Io)),
				r.cc(e, H),
				e[ae] != null && r.c(G_e(e[ae], t).n(ae)),
				e[J] != null && r.c(S.XmlNode.of(TEe, e[J]).n(J)),
				e[is] != null && r.c(oye(e[is], t).n(is)),
				e[Go] != null && r.c(Fhe(e[Go], t).n(Go)),
				e[wt] != null && r.c(The(e[wt], t).n(wt)),
				e[Fo] != null && r.c(Ihe(e[Fo], t).n(Fo)),
				r
			)
		}, 'se_ReplicationRule'),
		U_e = d((e, t) => {
			let r = new S.XmlNode(kEe)
			return r.cc(e, H), r.l(e, 'Tags', 'Tag', () => Ya(e[pr], t)), r
		}, 'se_ReplicationRuleAndOperator'),
		G_e = d((e, t) => {
			let r = new S.XmlNode(IEe)
			return (
				dp.visit(e, {
					Prefix: (n) => {
						e[H] != null && r.c(S.XmlNode.of(H, n).n(H))
					},
					Tag: (n) => {
						e[Ee] != null && r.c(Xa(n, t).n(Ee))
					},
					And: (n) => {
						e[ft] != null && r.c(U_e(n, t).n(ft))
					},
					_: (n, i) => {
						if (!(i instanceof S.XmlNode || i instanceof S.XmlText))
							throw new Error(
								'Unable to serialize unknown union members in XML.',
							)
						r.c(new S.XmlNode(n).c(i))
					},
				}),
				r
			)
		}, 'se_ReplicationRuleFilter'),
		z_e = d(
			(e, t) => e.filter((r) => r != null).map((r) => j_e(r, t).n(kt)),
			'se_ReplicationRules',
		),
		H_e = d((e, t) => {
			let r = new S.XmlNode(Zo)
			return (
				e[J] != null && r.c(S.XmlNode.of(FEe, e[J]).n(J)),
				e[Ha] != null && r.c(Mj(e[Ha], t).n(Ha)),
				r
			)
		}, 'se_ReplicationTime'),
		Mj = d((e, t) => {
			let r = new S.XmlNode(MEe)
			return e[ko] != null && r.c(S.XmlNode.of(ko, String(e[ko])).n(ko)), r
		}, 'se_ReplicationTimeValue'),
		$_e = d((e, t) => {
			let r = new S.XmlNode(OEe)
			return r.cc(e, Hf), r
		}, 'se_RequestPaymentConfiguration'),
		V_e = d((e, t) => {
			let r = new S.XmlNode(Xf)
			return e[Gy] != null && r.c(S.XmlNode.of(y0e, String(e[Gy])).n(Gy)), r
		}, 'se_RequestProgress'),
		K_e = d((e, t) => {
			let r = new S.XmlNode(DEe)
			return (
				e[Ie] != null && r.c(S.XmlNode.of(Ie, String(e[Ie])).n(Ie)),
				e[Bf] != null && r.c(Uhe(e[Bf], t).n(Bf)),
				e[Cr] != null && r.c(S.XmlNode.of(BEe, e[Cr]).n(Cr)),
				r.cc(e, OU),
				r.cc(e, g0e),
				e[Qf] != null && r.c(Z_e(e[Qf], t).n(Qf)),
				e[Uf] != null && r.c(P_e(e[Uf], t).n(Uf)),
				r
			)
		}, 'se_RestoreRequest'),
		W_e = d((e, t) => {
			let r = new S.XmlNode(hp)
			return (
				e[Lo] != null && r.c(Ehe(e[Lo], t).n(Lo)),
				e[es] != null && r.c(L_e(e[es], t).n(es)),
				r
			)
		}, 'se_RoutingRule'),
		X_e = d(
			(e, t) => e.filter((r) => r != null).map((r) => W_e(r, t).n(hp)),
			'se_RoutingRules',
		),
		Y_e = d((e, t) => {
			let r = new S.XmlNode(GEe)
			return r.l(e, 'FilterRules', 'FilterRule', () => jhe(e[SS], t)), r
		}, 'se_S3KeyFilter'),
		J_e = d((e, t) => {
			let r = new S.XmlNode(zEe)
			return (
				r.cc(e, Pp),
				e[H] != null && r.c(S.XmlNode.of(X0e, e[H]).n(H)),
				e[Ln] != null && r.c(Bhe(e[Ln], t).n(Ln)),
				e[Ly] != null && r.c(S.XmlNode.of(mEe, e[Ly]).n(Ly)),
				r.lc(e, 'AccessControlList', 'AccessControlList', () => Dj(e[Bo], t)),
				e[os] != null && r.c(VS(e[os], t).n(os)),
				r.lc(e, 'UserMetadata', 'UserMetadata', () => Sye(e[QEe], t)),
				r.cc(e, _e),
				r
			)
		}, 'se_S3Location'),
		Q_e = d((e, t) => {
			let r = new S.XmlNode(Zf)
			return (
				e[kf] != null && r.c(S.XmlNode.of(kf, String(e[kf])).n(kf)),
				e[Af] != null && r.c(S.XmlNode.of(Af, String(e[Af])).n(Af)),
				r
			)
		}, 'se_ScanRange'),
		Z_e = d((e, t) => {
			let r = new S.XmlNode(Qf)
			return (
				e[Ho] != null && r.c(Lj(e[Ho], t).n(Ho)),
				r.cc(e, dU),
				r.cc(e, uU),
				e[Xo] != null && r.c(Fj(e[Xo], t).n(Xo)),
				r
			)
		}, 'se_SelectParameters'),
		eye = d((e, t) => {
			let r = new S.XmlNode(VEe)
			return (
				e[Ga] != null && r.c(S.XmlNode.of(br, e[Ga]).n(Ga)),
				e[Na] != null && r.c(S.XmlNode.of(gr, e[Na]).n(Na)),
				r
			)
		}, 'se_ServerSideEncryptionByDefault'),
		tye = d((e, t) => {
			let r = new S.XmlNode(KEe)
			return r.l(e, 'Rules', 'Rule', () => nye(e[Qr], t)), r
		}, 'se_ServerSideEncryptionConfiguration'),
		rye = d((e, t) => {
			let r = new S.XmlNode(WEe)
			return (
				e[va] != null && r.c(eye(e[va], t).n(va)),
				e[ct] != null && r.c(S.XmlNode.of(ct, String(e[ct])).n(ct)),
				r
			)
		}, 'se_ServerSideEncryptionRule'),
		nye = d(
			(e, t) => e.filter((r) => r != null).map((r) => rye(r, t).n(kt)),
			'se_ServerSideEncryptionRules',
		),
		iye = d((e, t) => new S.XmlNode(ns), 'se_SimplePrefix'),
		oye = d((e, t) => {
			let r = new S.XmlNode(is)
			return (
				e[rs] != null && r.c(aye(e[rs], t).n(rs)),
				e[Qo] != null && r.c(M_e(e[Qo], t).n(Qo)),
				r
			)
		}, 'se_SourceSelectionCriteria'),
		sye = d((e, t) => {
			let r = new S.XmlNode(_p)
			return e[Ba] != null && r.c(S.XmlNode.of(gr, e[Ba]).n(Ba)), r
		}, 'se_SSEKMS'),
		aye = d((e, t) => {
			let r = new S.XmlNode(rs)
			return e[J] != null && r.c(S.XmlNode.of(UEe, e[J]).n(J)), r
		}, 'se_SseKmsEncryptedObjects'),
		cye = d((e, t) => new S.XmlNode(yp), 'se_SSES3'),
		lye = d((e, t) => {
			let r = new S.XmlNode(ts)
			return e[xa] != null && r.c(dye(e[xa], t).n(xa)), r
		}, 'se_StorageClassAnalysis'),
		dye = d((e, t) => {
			let r = new S.XmlNode(qEe)
			return (
				e[Ma] != null && r.c(S.XmlNode.of(jEe, e[Ma]).n(Ma)),
				e[wt] != null && r.c(fhe(e[wt], t).n(wt)),
				r
			)
		}, 'se_StorageClassAnalysisDataExport'),
		Xa = d((e, t) => {
			let r = new S.XmlNode(Ee)
			return e[pe] != null && r.c(S.XmlNode.of(ZS, e[pe]).n(pe)), r.cc(e, kr), r
		}, 'se_Tag'),
		VS = d((e, t) => {
			let r = new S.XmlNode(os)
			return r.lc(e, 'TagSet', 'TagSet', () => Ya(e[mn], t)), r
		}, 'se_Tagging'),
		Ya = d(
			(e, t) => e.filter((r) => r != null).map((r) => Xa(r, t).n(Ee)),
			'se_TagSet',
		),
		uye = d((e, t) => {
			let r = new S.XmlNode(YEe)
			if (e[Rr] != null) {
				let n = Nj(e[Rr], t).n(Rr)
				n.a('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance'), r.c(n)
			}
			return e[qn] != null && r.c(S.XmlNode.of(JCe, e[qn]).n(qn)), r
		}, 'se_TargetGrant'),
		mye = d(
			(e, t) => e.filter((r) => r != null).map((r) => uye(r, t).n(ci)),
			'se_TargetGrants',
		),
		fye = d((e, t) => {
			let r = new S.XmlNode(ss)
			return (
				e[ns] != null && r.c(iye(e[ns], t).n(ns)),
				e[Yo] != null && r.c(T_e(e[Yo], t).n(Yo)),
				r
			)
		}, 'se_TargetObjectKeyFormat'),
		pye = d((e, t) => {
			let r = new S.XmlNode(qS)
			return (
				e[Ie] != null && r.c(S.XmlNode.of(F0e, String(e[Ie])).n(Ie)),
				e[oi] != null && r.c(S.XmlNode.of(L0e, e[oi]).n(oi)),
				r
			)
		}, 'se_Tiering'),
		gye = d(
			(e, t) => e.filter((r) => r != null).map((r) => pye(r, t).n(kt)),
			'se_TieringList',
		),
		vye = d((e, t) => {
			let r = new S.XmlNode(LS)
			return (
				e[ce] != null && r.c(S.XmlNode.of(QS, e[ce]).n(ce)),
				e[tp] != null && r.c(S.XmlNode.of(tp, e[tp]).n(jS)),
				r.l(e, 'Events', 'Event', () => HS(e[ai], t)),
				e[ae] != null && r.c($S(e[ae], t).n(ae)),
				r
			)
		}, 'se_TopicConfiguration'),
		hye = d(
			(e, t) => e.filter((r) => r != null).map((r) => vye(r, t).n(kt)),
			'se_TopicConfigurationList',
		),
		_ye = d((e, t) => {
			let r = new S.XmlNode(GS)
			return (
				e[ur] != null &&
					r.c(
						S.XmlNode.of(ur, (0, a.serializeDateTime)(e[ur]).toString()).n(ur),
					),
				e[Ie] != null && r.c(S.XmlNode.of(Ie, String(e[Ie])).n(Ie)),
				e[_e] != null && r.c(S.XmlNode.of(AU, e[_e]).n(_e)),
				r
			)
		}, 'se_Transition'),
		yye = d(
			(e, t) => e.filter((r) => r != null).map((r) => _ye(r, t).n(kt)),
			'se_TransitionList',
		),
		Sye = d(
			(e, t) => e.filter((r) => r != null).map((r) => u_e(r, t).n(pU)),
			'se_UserMetadata',
		),
		Cye = d((e, t) => {
			let r = new S.XmlNode(ZEe)
			return (
				e[qf] != null && r.c(S.XmlNode.of(qf, e[qf]).n(PS)),
				e[J] != null && r.c(S.XmlNode.of(r0e, e[J]).n(J)),
				r
			)
		}, 'se_VersioningConfiguration'),
		Eye = d((e, t) => {
			let r = new S.XmlNode(ebe)
			return (
				e[Uo] != null && r.c(Dhe(e[Uo], t).n(Uo)),
				e[zo] != null && r.c(zhe(e[zo], t).n(zo)),
				e[Jo] != null && r.c(F_e(e[Jo], t).n(Jo)),
				r.lc(e, 'RoutingRules', 'RoutingRules', () => X_e(e[fa], t)),
				r
			)
		}, 'se_WebsiteConfiguration'),
		bye = d((e, t) => {
			let r = {}
			return e[Po] != null && (r[Po] = (0, a.strictParseInt32)(e[Po])), r
		}, 'de_AbortIncompleteMultipartUpload'),
		wye = d((e, t) => {
			let r = {}
			return e[ke] != null && (r[ke] = (0, a.expectString)(e[ke])), r
		}, 'de_AccessControlTranslation'),
		xye = d(
			(e, t) =>
				(e || []).filter((r) => r != null).map((r) => (0, a.expectString)(r)),
			'de_AllowedHeaders',
		),
		Pye = d(
			(e, t) =>
				(e || []).filter((r) => r != null).map((r) => (0, a.expectString)(r)),
			'de_AllowedMethods',
		),
		Aye = d(
			(e, t) =>
				(e || []).filter((r) => r != null).map((r) => (0, a.expectString)(r)),
			'de_AllowedOrigins',
		),
		Oye = d((e, t) => {
			let r = {}
			return (
				e[H] != null && (r[H] = (0, a.expectString)(e[H])),
				e.Tag === ''
					? (r[pr] = [])
					: e[Ee] != null &&
						(r[pr] = us((0, a.getArrayIfSingleItem)(e[Ee]), t)),
				r
			)
		}, 'de_AnalyticsAndOperator'),
		qj = d((e, t) => {
			let r = {}
			return (
				e[ce] != null && (r[ce] = (0, a.expectString)(e[ce])),
				e.Filter === '' ||
					(e[ae] != null && (r[ae] = Iye((0, a.expectUnion)(e[ae]), t))),
				e[ts] != null && (r[ts] = wCe(e[ts], t)),
				r
			)
		}, 'de_AnalyticsConfiguration'),
		Rye = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => qj(r, t)),
			'de_AnalyticsConfigurationList',
		),
		kye = d((e, t) => {
			let r = {}
			return e[Yr] != null && (r[Yr] = Tye(e[Yr], t)), r
		}, 'de_AnalyticsExportDestination'),
		Iye = d(
			(e, t) =>
				e[H] != null
					? { Prefix: (0, a.expectString)(e[H]) }
					: e[Ee] != null
						? { Tag: Ja(e[Ee], t) }
						: e[ft] != null
							? { And: Oye(e[ft], t) }
							: { $unknown: Object.entries(e)[0] },
			'de_AnalyticsFilter',
		),
		Tye = d((e, t) => {
			let r = {}
			return (
				e[$r] != null && (r[$r] = (0, a.expectString)(e[$r])),
				e[_a] != null && (r[_a] = (0, a.expectString)(e[_a])),
				e[Pe] != null && (r[Pe] = (0, a.expectString)(e[Pe])),
				e[H] != null && (r[H] = (0, a.expectString)(e[H])),
				r
			)
		}, 'de_AnalyticsS3BucketDestination'),
		Bye = d((e, t) => {
			let r = {}
			return (
				e[it] != null && (r[it] = (0, a.expectString)(e[it])),
				e[Fy] != null &&
					(r[Fy] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[Fy]),
					)),
				r
			)
		}, 'de_Bucket'),
		jj = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => Bye(r, t)),
			'de_Buckets',
		),
		Nye = d((e, t) => {
			let r = {}
			return (
				e[He] != null && (r[He] = (0, a.expectString)(e[He])),
				e[$e] != null && (r[$e] = (0, a.expectString)(e[$e])),
				e[Ve] != null && (r[Ve] = (0, a.expectString)(e[Ve])),
				e[Ke] != null && (r[Ke] = (0, a.expectString)(e[Ke])),
				r
			)
		}, 'de_Checksum'),
		Uj = d(
			(e, t) =>
				(e || []).filter((r) => r != null).map((r) => (0, a.expectString)(r)),
			'de_ChecksumAlgorithmList',
		),
		Dye = d((e, t) => {
			let r = {}
			return e[H] != null && (r[H] = (0, a.expectString)(e[H])), r
		}, 'de_CommonPrefix'),
		xp = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => Dye(r, t)),
			'de_CommonPrefixList',
		),
		Lye = d((e, t) => {
			let r = {}
			return (
				e[Nf] != null && (r[Nf] = (0, a.expectString)(e[Nf])),
				e[Lf] != null && (r[Lf] = (0, a.expectString)(e[Lf])),
				r
			)
		}, 'de_Condition'),
		Fye = d((e, t) => ({}), 'de_ContinuationEvent'),
		Mye = d((e, t) => {
			let r = {}
			return (
				e[We] != null && (r[We] = (0, a.expectString)(e[We])),
				e[dt] != null &&
					(r[dt] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[dt]),
					)),
				e[He] != null && (r[He] = (0, a.expectString)(e[He])),
				e[$e] != null && (r[$e] = (0, a.expectString)(e[$e])),
				e[Ve] != null && (r[Ve] = (0, a.expectString)(e[Ve])),
				e[Ke] != null && (r[Ke] = (0, a.expectString)(e[Ke])),
				r
			)
		}, 'de_CopyObjectResult'),
		qye = d((e, t) => {
			let r = {}
			return (
				e[We] != null && (r[We] = (0, a.expectString)(e[We])),
				e[dt] != null &&
					(r[dt] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[dt]),
					)),
				e[He] != null && (r[He] = (0, a.expectString)(e[He])),
				e[$e] != null && (r[$e] = (0, a.expectString)(e[$e])),
				e[Ve] != null && (r[Ve] = (0, a.expectString)(e[Ve])),
				e[Ke] != null && (r[Ke] = (0, a.expectString)(e[Ke])),
				r
			)
		}, 'de_CopyPartResult'),
		jye = d((e, t) => {
			let r = {}
			return (
				e[lt] != null && (r[lt] = (0, a.expectString)(e[lt])),
				e.AllowedHeader === ''
					? (r[lS] = [])
					: e[cS] != null &&
						(r[lS] = xye((0, a.getArrayIfSingleItem)(e[cS]), t)),
				e.AllowedMethod === ''
					? (r[uS] = [])
					: e[dS] != null &&
						(r[uS] = Pye((0, a.getArrayIfSingleItem)(e[dS]), t)),
				e.AllowedOrigin === ''
					? (r[fS] = [])
					: e[mS] != null &&
						(r[fS] = Aye((0, a.getArrayIfSingleItem)(e[mS]), t)),
				e.ExposeHeader === ''
					? (r[hS] = [])
					: e[_S] != null &&
						(r[hS] = rSe((0, a.getArrayIfSingleItem)(e[_S]), t)),
				e[Ro] != null && (r[Ro] = (0, a.strictParseInt32)(e[Ro])),
				r
			)
		}, 'de_CORSRule'),
		Uye = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => jye(r, t)),
			'de_CORSRules',
		),
		Gye = d((e, t) => {
			let r = {}
			return (
				e[Kr] != null && (r[Kr] = (0, a.expectString)(e[Kr])),
				e[Ie] != null && (r[Ie] = (0, a.strictParseInt32)(e[Ie])),
				e[To] != null && (r[To] = (0, a.strictParseInt32)(e[To])),
				r
			)
		}, 'de_DefaultRetention'),
		zye = d((e, t) => {
			let r = {}
			return (
				e[pe] != null && (r[pe] = (0, a.expectString)(e[pe])),
				e[Se] != null && (r[Se] = (0, a.expectString)(e[Se])),
				e[fn] != null && (r[fn] = (0, a.parseBoolean)(e[fn])),
				e[jy] != null && (r[jy] = (0, a.expectString)(e[jy])),
				r
			)
		}, 'de_DeletedObject'),
		Hye = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => zye(r, t)),
			'de_DeletedObjects',
		),
		$ye = d((e, t) => {
			let r = {}
			return (
				e[ke] != null && (r[ke] = eo(e[ke], t)),
				e[pe] != null && (r[pe] = (0, a.expectString)(e[pe])),
				e[Se] != null && (r[Se] = (0, a.expectString)(e[Se])),
				e[Oa] != null && (r[Oa] = (0, a.parseBoolean)(e[Oa])),
				e[dt] != null &&
					(r[dt] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[dt]),
					)),
				r
			)
		}, 'de_DeleteMarkerEntry'),
		Vye = d((e, t) => {
			let r = {}
			return e[J] != null && (r[J] = (0, a.expectString)(e[J])), r
		}, 'de_DeleteMarkerReplication'),
		Kye = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => $ye(r, t)),
			'de_DeleteMarkers',
		),
		Wye = d((e, t) => {
			let r = {}
			return (
				e[Pe] != null && (r[Pe] = (0, a.expectString)(e[Pe])),
				e[ha] != null && (r[ha] = (0, a.expectString)(e[ha])),
				e[_e] != null && (r[_e] = (0, a.expectString)(e[_e])),
				e[No] != null && (r[No] = wye(e[No], t)),
				e[jo] != null && (r[jo] = Xye(e[jo], t)),
				e[Zo] != null && (r[Zo] = lCe(e[Zo], t)),
				e[Ko] != null && (r[Ko] = PSe(e[Ko], t)),
				r
			)
		}, 'de_Destination'),
		Xye = d((e, t) => {
			let r = {}
			return e[Vf] != null && (r[Vf] = (0, a.expectString)(e[Vf])), r
		}, 'de_EncryptionConfiguration'),
		Yye = d((e, t) => ({}), 'de_EndEvent'),
		Jye = d((e, t) => {
			let r = {}
			return (
				e[pe] != null && (r[pe] = (0, a.expectString)(e[pe])),
				e[Se] != null && (r[Se] = (0, a.expectString)(e[Se])),
				e[qy] != null && (r[qy] = (0, a.expectString)(e[qy])),
				e[Wy] != null && (r[Wy] = (0, a.expectString)(e[Wy])),
				r
			)
		}, 'de__Error'),
		Qye = d((e, t) => {
			let r = {}
			return e[pe] != null && (r[pe] = (0, a.expectString)(e[pe])), r
		}, 'de_ErrorDocument'),
		Zye = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => Jye(r, t)),
			'de_Errors',
		),
		eSe = d((e, t) => ({}), 'de_EventBridgeConfiguration'),
		KS = d(
			(e, t) =>
				(e || []).filter((r) => r != null).map((r) => (0, a.expectString)(r)),
			'de_EventList',
		),
		tSe = d((e, t) => {
			let r = {}
			return e[J] != null && (r[J] = (0, a.expectString)(e[J])), r
		}, 'de_ExistingObjectReplication'),
		rSe = d(
			(e, t) =>
				(e || []).filter((r) => r != null).map((r) => (0, a.expectString)(r)),
			'de_ExposeHeaders',
		),
		nSe = d((e, t) => {
			let r = {}
			return (
				e[it] != null && (r[it] = (0, a.expectString)(e[it])),
				e[kr] != null && (r[kr] = (0, a.expectString)(e[kr])),
				r
			)
		}, 'de_FilterRule'),
		iSe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => nSe(r, t)),
			'de_FilterRuleList',
		),
		oSe = d((e, t) => {
			let r = {}
			return (
				e[Ka] != null && (r[JEe] = (0, a.strictParseInt32)(e[Ka])),
				e[Yi] != null && (r[Yi] = (0, a.expectString)(e[Yi])),
				e[Fa] != null && (r[Fa] = (0, a.expectString)(e[Fa])),
				e[si] != null && (r[si] = (0, a.strictParseInt32)(e[si])),
				e[Le] != null && (r[Le] = (0, a.parseBoolean)(e[Le])),
				e.Part === ''
					? (r[Il] = [])
					: e[vp] != null &&
						(r[Il] = XSe((0, a.getArrayIfSingleItem)(e[vp]), t)),
				r
			)
		}, 'de_GetObjectAttributesParts'),
		sSe = d((e, t) => {
			let r = {}
			return (
				e[Rr] != null && (r[Rr] = Gj(e[Rr], t)),
				e[qn] != null && (r[qn] = (0, a.expectString)(e[qn])),
				r
			)
		}, 'de_Grant'),
		Gj = d((e, t) => {
			let r = {}
			return (
				e[pn] != null && (r[pn] = (0, a.expectString)(e[pn])),
				e[Tf] != null && (r[Tf] = (0, a.expectString)(e[Tf])),
				e[lt] != null && (r[lt] = (0, a.expectString)(e[lt])),
				e[op] != null && (r[op] = (0, a.expectString)(e[op])),
				e[uq] != null && (r[Cr] = (0, a.expectString)(e[uq])),
				r
			)
		}, 'de_Grantee'),
		zj = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => sSe(r, t)),
			'de_Grants',
		),
		aSe = d((e, t) => {
			let r = {}
			return e[ep] != null && (r[ep] = (0, a.expectString)(e[ep])), r
		}, 'de_IndexDocument'),
		Hj = d((e, t) => {
			let r = {}
			return (
				e[lt] != null && (r[lt] = (0, a.expectString)(e[lt])),
				e[pn] != null && (r[pn] = (0, a.expectString)(e[pn])),
				r
			)
		}, 'de_Initiator'),
		cSe = d((e, t) => {
			let r = {}
			return (
				e[H] != null && (r[H] = (0, a.expectString)(e[H])),
				e.Tag === ''
					? (r[pr] = [])
					: e[Ee] != null &&
						(r[pr] = us((0, a.getArrayIfSingleItem)(e[Ee]), t)),
				r
			)
		}, 'de_IntelligentTieringAndOperator'),
		$j = d((e, t) => {
			let r = {}
			return (
				e[ce] != null && (r[ce] = (0, a.expectString)(e[ce])),
				e[ae] != null && (r[ae] = dSe(e[ae], t)),
				e[J] != null && (r[J] = (0, a.expectString)(e[J])),
				e.Tiering === ''
					? (r[MS] = [])
					: e[qS] != null &&
						(r[MS] = kCe((0, a.getArrayIfSingleItem)(e[qS]), t)),
				r
			)
		}, 'de_IntelligentTieringConfiguration'),
		lSe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => $j(r, t)),
			'de_IntelligentTieringConfigurationList',
		),
		dSe = d((e, t) => {
			let r = {}
			return (
				e[H] != null && (r[H] = (0, a.expectString)(e[H])),
				e[Ee] != null && (r[Ee] = Ja(e[Ee], t)),
				e[ft] != null && (r[ft] = cSe(e[ft], t)),
				r
			)
		}, 'de_IntelligentTieringFilter'),
		Vj = d((e, t) => {
			let r = {}
			return (
				e[wt] != null && (r[wt] = mSe(e[wt], t)),
				e[Oo] != null && (r[Oo] = (0, a.parseBoolean)(e[Oo])),
				e[ae] != null && (r[ae] = pSe(e[ae], t)),
				e[ce] != null && (r[ce] = (0, a.expectString)(e[ce])),
				e[Ra] != null && (r[Ra] = (0, a.expectString)(e[Ra])),
				e.OptionalFields === ''
					? (r[ma] = [])
					: e[ma] != null &&
						e[ma][CS] != null &&
						(r[ma] = gSe((0, a.getArrayIfSingleItem)(e[ma][CS]), t)),
				e[za] != null && (r[za] = hSe(e[za], t)),
				r
			)
		}, 'de_InventoryConfiguration'),
		uSe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => Vj(r, t)),
			'de_InventoryConfigurationList',
		),
		mSe = d((e, t) => {
			let r = {}
			return e[Yr] != null && (r[Yr] = vSe(e[Yr], t)), r
		}, 'de_InventoryDestination'),
		fSe = d((e, t) => {
			let r = {}
			return (
				e[yp] != null && (r[NS] = ECe(e[yp], t)),
				e[_p] != null && (r[BS] = SCe(e[_p], t)),
				r
			)
		}, 'de_InventoryEncryption'),
		pSe = d((e, t) => {
			let r = {}
			return e[H] != null && (r[H] = (0, a.expectString)(e[H])), r
		}, 'de_InventoryFilter'),
		gSe = d(
			(e, t) =>
				(e || []).filter((r) => r != null).map((r) => (0, a.expectString)(r)),
			'de_InventoryOptionalFields',
		),
		vSe = d((e, t) => {
			let r = {}
			return (
				e[ga] != null && (r[ga] = (0, a.expectString)(e[ga])),
				e[Pe] != null && (r[Pe] = (0, a.expectString)(e[Pe])),
				e[$r] != null && (r[$r] = (0, a.expectString)(e[$r])),
				e[H] != null && (r[H] = (0, a.expectString)(e[H])),
				e[Ln] != null && (r[Ln] = fSe(e[Ln], t)),
				r
			)
		}, 'de_InventoryS3BucketDestination'),
		hSe = d((e, t) => {
			let r = {}
			return e[Aa] != null && (r[Aa] = (0, a.expectString)(e[Aa])), r
		}, 'de_InventorySchedule'),
		_Se = d((e, t) => {
			let r = {}
			return (
				e[ce] != null && (r[ce] = (0, a.expectString)(e[ce])),
				e[pS] != null && (r[Ff] = (0, a.expectString)(e[pS])),
				e.Event === ''
					? (r[ai] = [])
					: e[as] != null &&
						(r[ai] = KS((0, a.getArrayIfSingleItem)(e[as]), t)),
				e[ae] != null && (r[ae] = WS(e[ae], t)),
				r
			)
		}, 'de_LambdaFunctionConfiguration'),
		ySe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => _Se(r, t)),
			'de_LambdaFunctionConfigurationList',
		),
		SSe = d((e, t) => {
			let r = {}
			return (
				e[ur] != null &&
					(r[ur] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[ur]),
					)),
				e[Ie] != null && (r[Ie] = (0, a.strictParseInt32)(e[Ie])),
				e[Ao] != null && (r[Ao] = (0, a.parseBoolean)(e[Ao])),
				r
			)
		}, 'de_LifecycleExpiration'),
		CSe = d((e, t) => {
			let r = {}
			return (
				e[mr] != null && (r[mr] = SSe(e[mr], t)),
				e[lt] != null && (r[lt] = (0, a.expectString)(e[lt])),
				e[H] != null && (r[H] = (0, a.expectString)(e[H])),
				e.Filter === '' ||
					(e[ae] != null && (r[ae] = bSe((0, a.expectUnion)(e[ae]), t))),
				e[J] != null && (r[J] = (0, a.expectString)(e[J])),
				e.Transition === ''
					? (r[US] = [])
					: e[GS] != null &&
						(r[US] = NCe((0, a.getArrayIfSingleItem)(e[GS]), t)),
				e.NoncurrentVersionTransition === ''
					? (r[AS] = [])
					: e[OS] != null &&
						(r[AS] = NSe((0, a.getArrayIfSingleItem)(e[OS]), t)),
				e[Wo] != null && (r[Wo] = TSe(e[Wo], t)),
				e[Do] != null && (r[Do] = bye(e[Do], t)),
				r
			)
		}, 'de_LifecycleRule'),
		ESe = d((e, t) => {
			let r = {}
			return (
				e[H] != null && (r[H] = (0, a.expectString)(e[H])),
				e.Tag === ''
					? (r[pr] = [])
					: e[Ee] != null &&
						(r[pr] = us((0, a.getArrayIfSingleItem)(e[Ee]), t)),
				e[Fn] != null && (r[Fn] = (0, a.strictParseLong)(e[Fn])),
				e[Mn] != null && (r[Mn] = (0, a.strictParseLong)(e[Mn])),
				r
			)
		}, 'de_LifecycleRuleAndOperator'),
		bSe = d(
			(e, t) =>
				e[H] != null
					? { Prefix: (0, a.expectString)(e[H]) }
					: e[Ee] != null
						? { Tag: Ja(e[Ee], t) }
						: e[Fn] != null
							? { ObjectSizeGreaterThan: (0, a.strictParseLong)(e[Fn]) }
							: e[Mn] != null
								? { ObjectSizeLessThan: (0, a.strictParseLong)(e[Mn]) }
								: e[ft] != null
									? { And: ESe(e[ft], t) }
									: { $unknown: Object.entries(e)[0] },
			'de_LifecycleRuleFilter',
		),
		wSe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => CSe(r, t)),
			'de_LifecycleRules',
		),
		xSe = d((e, t) => {
			let r = {}
			return (
				e[rp] != null && (r[rp] = (0, a.expectString)(e[rp])),
				e.TargetGrants === ''
					? (r[pa] = [])
					: e[pa] != null &&
						e[pa][ci] != null &&
						(r[pa] = ACe((0, a.getArrayIfSingleItem)(e[pa][ci]), t)),
				e[np] != null && (r[np] = (0, a.expectString)(e[np])),
				e[ss] != null && (r[ss] = OCe(e[ss], t)),
				r
			)
		}, 'de_LoggingEnabled'),
		PSe = d((e, t) => {
			let r = {}
			return (
				e[J] != null && (r[J] = (0, a.expectString)(e[J])),
				e[Pa] != null && (r[Pa] = Xj(e[Pa], t)),
				r
			)
		}, 'de_Metrics'),
		ASe = d((e, t) => {
			let r = {}
			return (
				e[H] != null && (r[H] = (0, a.expectString)(e[H])),
				e.Tag === ''
					? (r[pr] = [])
					: e[Ee] != null &&
						(r[pr] = us((0, a.getArrayIfSingleItem)(e[Ee]), t)),
				e[ii] != null && (r[ii] = (0, a.expectString)(e[ii])),
				r
			)
		}, 'de_MetricsAndOperator'),
		Kj = d((e, t) => {
			let r = {}
			return (
				e[ce] != null && (r[ce] = (0, a.expectString)(e[ce])),
				e.Filter === '' ||
					(e[ae] != null && (r[ae] = RSe((0, a.expectUnion)(e[ae]), t))),
				r
			)
		}, 'de_MetricsConfiguration'),
		OSe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => Kj(r, t)),
			'de_MetricsConfigurationList',
		),
		RSe = d(
			(e, t) =>
				e[H] != null
					? { Prefix: (0, a.expectString)(e[H]) }
					: e[Ee] != null
						? { Tag: Ja(e[Ee], t) }
						: e[ii] != null
							? { AccessPointArn: (0, a.expectString)(e[ii]) }
							: e[ft] != null
								? { And: ASe(e[ft], t) }
								: { $unknown: Object.entries(e)[0] },
			'de_MetricsFilter',
		),
		kSe = d((e, t) => {
			let r = {}
			return (
				e[Er] != null && (r[Er] = (0, a.expectString)(e[Er])),
				e[pe] != null && (r[pe] = (0, a.expectString)(e[pe])),
				e[$y] != null &&
					(r[$y] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[$y]),
					)),
				e[_e] != null && (r[_e] = (0, a.expectString)(e[_e])),
				e[ke] != null && (r[ke] = eo(e[ke], t)),
				e[Ia] != null && (r[Ia] = Hj(e[Ia], t)),
				e[Ce] != null && (r[Ce] = (0, a.expectString)(e[Ce])),
				r
			)
		}, 'de_MultipartUpload'),
		ISe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => kSe(r, t)),
			'de_MultipartUploadList',
		),
		TSe = d((e, t) => {
			let r = {}
			return (
				e[Wr] != null && (r[Wr] = (0, a.strictParseInt32)(e[Wr])),
				e[Xr] != null && (r[Xr] = (0, a.strictParseInt32)(e[Xr])),
				r
			)
		}, 'de_NoncurrentVersionExpiration'),
		BSe = d((e, t) => {
			let r = {}
			return (
				e[Wr] != null && (r[Wr] = (0, a.strictParseInt32)(e[Wr])),
				e[_e] != null && (r[_e] = (0, a.expectString)(e[_e])),
				e[Xr] != null && (r[Xr] = (0, a.strictParseInt32)(e[Xr])),
				r
			)
		}, 'de_NoncurrentVersionTransition'),
		NSe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => BSe(r, t)),
			'de_NoncurrentVersionTransitionList',
		),
		WS = d((e, t) => {
			let r = {}
			return e[TS] != null && (r[pe] = mCe(e[TS], t)), r
		}, 'de_NotificationConfigurationFilter'),
		DSe = d((e, t) => {
			let r = {}
			return (
				e[pe] != null && (r[pe] = (0, a.expectString)(e[pe])),
				e[dt] != null &&
					(r[dt] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[dt]),
					)),
				e[We] != null && (r[We] = (0, a.expectString)(e[We])),
				e.ChecksumAlgorithm === ''
					? (r[Ce] = [])
					: e[Ce] != null &&
						(r[Ce] = Uj((0, a.getArrayIfSingleItem)(e[Ce]), t)),
				e[Jr] != null && (r[Jr] = (0, a.strictParseLong)(e[Jr])),
				e[_e] != null && (r[_e] = (0, a.expectString)(e[_e])),
				e[ke] != null && (r[ke] = eo(e[ke], t)),
				e[ja] != null && (r[ja] = Yj(e[ja], t)),
				r
			)
		}, 'de__Object'),
		Wj = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => DSe(r, t)),
			'de_ObjectList',
		),
		LSe = d((e, t) => {
			let r = {}
			return (
				e[Gf] != null && (r[Gf] = (0, a.expectString)(e[Gf])),
				e[Sr] != null && (r[Sr] = qSe(e[Sr], t)),
				r
			)
		}, 'de_ObjectLockConfiguration'),
		FSe = d((e, t) => {
			let r = {}
			return e[J] != null && (r[J] = (0, a.expectString)(e[J])), r
		}, 'de_ObjectLockLegalHold'),
		MSe = d((e, t) => {
			let r = {}
			return (
				e[Kr] != null && (r[Kr] = (0, a.expectString)(e[Kr])),
				e[Ua] != null &&
					(r[Ua] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[Ua]),
					)),
				r
			)
		}, 'de_ObjectLockRetention'),
		qSe = d((e, t) => {
			let r = {}
			return e[Mo] != null && (r[Mo] = Gye(e[Mo], t)), r
		}, 'de_ObjectLockRule'),
		jSe = d((e, t) => {
			let r = {}
			return (
				e[yr] != null && (r[yr] = (0, a.strictParseInt32)(e[yr])),
				e[Jr] != null && (r[Jr] = (0, a.strictParseLong)(e[Jr])),
				e[He] != null && (r[He] = (0, a.expectString)(e[He])),
				e[$e] != null && (r[$e] = (0, a.expectString)(e[$e])),
				e[Ve] != null && (r[Ve] = (0, a.expectString)(e[Ve])),
				e[Ke] != null && (r[Ke] = (0, a.expectString)(e[Ke])),
				r
			)
		}, 'de_ObjectPart'),
		USe = d((e, t) => {
			let r = {}
			return (
				e[We] != null && (r[We] = (0, a.expectString)(e[We])),
				e.ChecksumAlgorithm === ''
					? (r[Ce] = [])
					: e[Ce] != null &&
						(r[Ce] = Uj((0, a.getArrayIfSingleItem)(e[Ce]), t)),
				e[Jr] != null && (r[Jr] = (0, a.strictParseLong)(e[Jr])),
				e[_e] != null && (r[_e] = (0, a.expectString)(e[_e])),
				e[pe] != null && (r[pe] = (0, a.expectString)(e[pe])),
				e[Se] != null && (r[Se] = (0, a.expectString)(e[Se])),
				e[Oa] != null && (r[Oa] = (0, a.parseBoolean)(e[Oa])),
				e[dt] != null &&
					(r[dt] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[dt]),
					)),
				e[ke] != null && (r[ke] = eo(e[ke], t)),
				e[ja] != null && (r[ja] = Yj(e[ja], t)),
				r
			)
		}, 'de_ObjectVersion'),
		GSe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => USe(r, t)),
			'de_ObjectVersionList',
		),
		eo = d((e, t) => {
			let r = {}
			return (
				e[pn] != null && (r[pn] = (0, a.expectString)(e[pn])),
				e[lt] != null && (r[lt] = (0, a.expectString)(e[lt])),
				r
			)
		}, 'de_Owner'),
		zSe = d((e, t) => {
			let r = {}
			return (
				e.Rule === ''
					? (r[Qr] = [])
					: e[Sr] != null &&
						(r[Qr] = $Se((0, a.getArrayIfSingleItem)(e[Sr]), t)),
				r
			)
		}, 'de_OwnershipControls'),
		HSe = d((e, t) => {
			let r = {}
			return e[Rl] != null && (r[Rl] = (0, a.expectString)(e[Rl])), r
		}, 'de_OwnershipControlsRule'),
		$Se = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => HSe(r, t)),
			'de_OwnershipControlsRules',
		),
		VSe = d((e, t) => {
			let r = {}
			return (
				e[yr] != null && (r[yr] = (0, a.strictParseInt32)(e[yr])),
				e[dt] != null &&
					(r[dt] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[dt]),
					)),
				e[We] != null && (r[We] = (0, a.expectString)(e[We])),
				e[Jr] != null && (r[Jr] = (0, a.strictParseLong)(e[Jr])),
				e[He] != null && (r[He] = (0, a.expectString)(e[He])),
				e[$e] != null && (r[$e] = (0, a.expectString)(e[$e])),
				e[Ve] != null && (r[Ve] = (0, a.expectString)(e[Ve])),
				e[Ke] != null && (r[Ke] = (0, a.expectString)(e[Ke])),
				r
			)
		}, 'de_Part'),
		KSe = d((e, t) => {
			let r = {}
			return e[zf] != null && (r[zf] = (0, a.expectString)(e[zf])), r
		}, 'de_PartitionedPrefix'),
		WSe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => VSe(r, t)),
			'de_Parts',
		),
		XSe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => jSe(r, t)),
			'de_PartsList',
		),
		YSe = d((e, t) => {
			let r = {}
			return e[zy] != null && (r[zy] = (0, a.parseBoolean)(e[zy])), r
		}, 'de_PolicyStatus'),
		JSe = d((e, t) => {
			let r = {}
			return (
				e[ba] != null && (r[ba] = (0, a.strictParseLong)(e[ba])),
				e[ya] != null && (r[ya] = (0, a.strictParseLong)(e[ya])),
				e[Ea] != null && (r[Ea] = (0, a.strictParseLong)(e[Ea])),
				r
			)
		}, 'de_Progress'),
		QSe = d((e, t) => {
			let r = {}
			return (
				e[Sa] != null && (r[Sa] = (0, a.parseBoolean)(e[Sa])),
				e[ka] != null && (r[ka] = (0, a.parseBoolean)(e[ka])),
				e[Ca] != null && (r[Ca] = (0, a.parseBoolean)(e[Ca])),
				e[qa] != null && (r[qa] = (0, a.parseBoolean)(e[qa])),
				r
			)
		}, 'de_PublicAccessBlockConfiguration'),
		ZSe = d((e, t) => {
			let r = {}
			return (
				e[ce] != null && (r[ce] = (0, a.expectString)(e[ce])),
				e[IS] != null && (r[$f] = (0, a.expectString)(e[IS])),
				e.Event === ''
					? (r[ai] = [])
					: e[as] != null &&
						(r[ai] = KS((0, a.getArrayIfSingleItem)(e[as]), t)),
				e[ae] != null && (r[ae] = WS(e[ae], t)),
				r
			)
		}, 'de_QueueConfiguration'),
		eCe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => ZSe(r, t)),
			'de_QueueConfigurationList',
		),
		tCe = d((e, t) => {
			let r = {}
			return (
				e[Wi] != null && (r[Wi] = (0, a.expectString)(e[Wi])),
				e[Df] != null && (r[Df] = (0, a.expectString)(e[Df])),
				e[Ji] != null && (r[Ji] = (0, a.expectString)(e[Ji])),
				e[Kf] != null && (r[Kf] = (0, a.expectString)(e[Kf])),
				e[Wf] != null && (r[Wf] = (0, a.expectString)(e[Wf])),
				r
			)
		}, 'de_Redirect'),
		rCe = d((e, t) => {
			let r = {}
			return (
				e[Wi] != null && (r[Wi] = (0, a.expectString)(e[Wi])),
				e[Ji] != null && (r[Ji] = (0, a.expectString)(e[Ji])),
				r
			)
		}, 'de_RedirectAllRequestsTo'),
		nCe = d((e, t) => {
			let r = {}
			return e[J] != null && (r[J] = (0, a.expectString)(e[J])), r
		}, 'de_ReplicaModifications'),
		iCe = d((e, t) => {
			let r = {}
			return (
				e[Yf] != null && (r[Yf] = (0, a.expectString)(e[Yf])),
				e.Rule === ''
					? (r[Qr] = [])
					: e[Sr] != null &&
						(r[Qr] = cCe((0, a.getArrayIfSingleItem)(e[Sr]), t)),
				r
			)
		}, 'de_ReplicationConfiguration'),
		oCe = d((e, t) => {
			let r = {}
			return (
				e[lt] != null && (r[lt] = (0, a.expectString)(e[lt])),
				e[Io] != null && (r[Io] = (0, a.strictParseInt32)(e[Io])),
				e[H] != null && (r[H] = (0, a.expectString)(e[H])),
				e.Filter === '' ||
					(e[ae] != null && (r[ae] = aCe((0, a.expectUnion)(e[ae]), t))),
				e[J] != null && (r[J] = (0, a.expectString)(e[J])),
				e[is] != null && (r[is] = yCe(e[is], t)),
				e[Go] != null && (r[Go] = tSe(e[Go], t)),
				e[wt] != null && (r[wt] = Wye(e[wt], t)),
				e[Fo] != null && (r[Fo] = Vye(e[Fo], t)),
				r
			)
		}, 'de_ReplicationRule'),
		sCe = d((e, t) => {
			let r = {}
			return (
				e[H] != null && (r[H] = (0, a.expectString)(e[H])),
				e.Tag === ''
					? (r[pr] = [])
					: e[Ee] != null &&
						(r[pr] = us((0, a.getArrayIfSingleItem)(e[Ee]), t)),
				r
			)
		}, 'de_ReplicationRuleAndOperator'),
		aCe = d(
			(e, t) =>
				e[H] != null
					? { Prefix: (0, a.expectString)(e[H]) }
					: e[Ee] != null
						? { Tag: Ja(e[Ee], t) }
						: e[ft] != null
							? { And: sCe(e[ft], t) }
							: { $unknown: Object.entries(e)[0] },
			'de_ReplicationRuleFilter',
		),
		cCe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => oCe(r, t)),
			'de_ReplicationRules',
		),
		lCe = d((e, t) => {
			let r = {}
			return (
				e[J] != null && (r[J] = (0, a.expectString)(e[J])),
				e[Ha] != null && (r[Ha] = Xj(e[Ha], t)),
				r
			)
		}, 'de_ReplicationTime'),
		Xj = d((e, t) => {
			let r = {}
			return e[ko] != null && (r[ko] = (0, a.strictParseInt32)(e[ko])), r
		}, 'de_ReplicationTimeValue'),
		Yj = d((e, t) => {
			let r = {}
			return (
				e[Hy] != null && (r[Hy] = (0, a.parseBoolean)(e[Hy])),
				e[tS] != null &&
					(r[tS] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[tS]),
					)),
				r
			)
		}, 'de_RestoreStatus'),
		dCe = d((e, t) => {
			let r = {}
			return (
				e[Lo] != null && (r[Lo] = Lye(e[Lo], t)),
				e[es] != null && (r[es] = tCe(e[es], t)),
				r
			)
		}, 'de_RoutingRule'),
		uCe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => dCe(r, t)),
			'de_RoutingRules',
		),
		mCe = d((e, t) => {
			let r = {}
			return (
				e.FilterRule === ''
					? (r[SS] = [])
					: e[yS] != null &&
						(r[SS] = iSe((0, a.getArrayIfSingleItem)(e[yS]), t)),
				r
			)
		}, 'de_S3KeyFilter'),
		fCe = d((e, t) => {
			let r = {}
			return (
				e[Ga] != null && (r[Ga] = (0, a.expectString)(e[Ga])),
				e[Na] != null && (r[Na] = (0, a.expectString)(e[Na])),
				r
			)
		}, 'de_ServerSideEncryptionByDefault'),
		pCe = d((e, t) => {
			let r = {}
			return (
				e.Rule === ''
					? (r[Qr] = [])
					: e[Sr] != null &&
						(r[Qr] = vCe((0, a.getArrayIfSingleItem)(e[Sr]), t)),
				r
			)
		}, 'de_ServerSideEncryptionConfiguration'),
		gCe = d((e, t) => {
			let r = {}
			return (
				e[va] != null && (r[va] = fCe(e[va], t)),
				e[ct] != null && (r[ct] = (0, a.parseBoolean)(e[ct])),
				r
			)
		}, 'de_ServerSideEncryptionRule'),
		vCe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => gCe(r, t)),
			'de_ServerSideEncryptionRules',
		),
		hCe = d((e, t) => {
			let r = {}
			return (
				e[Ny] != null && (r[Ny] = (0, a.expectString)(e[Ny])),
				e[rS] != null && (r[rS] = (0, a.expectString)(e[rS])),
				e[nS] != null && (r[nS] = (0, a.expectString)(e[nS])),
				e[mr] != null &&
					(r[mr] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[mr]),
					)),
				r
			)
		}, 'de_SessionCredentials'),
		_Ce = d((e, t) => ({}), 'de_SimplePrefix'),
		yCe = d((e, t) => {
			let r = {}
			return (
				e[rs] != null && (r[rs] = CCe(e[rs], t)),
				e[Qo] != null && (r[Qo] = nCe(e[Qo], t)),
				r
			)
		}, 'de_SourceSelectionCriteria'),
		SCe = d((e, t) => {
			let r = {}
			return e[Ba] != null && (r[Ba] = (0, a.expectString)(e[Ba])), r
		}, 'de_SSEKMS'),
		CCe = d((e, t) => {
			let r = {}
			return e[J] != null && (r[J] = (0, a.expectString)(e[J])), r
		}, 'de_SseKmsEncryptedObjects'),
		ECe = d((e, t) => ({}), 'de_SSES3'),
		bCe = d((e, t) => {
			let r = {}
			return (
				e[ba] != null && (r[ba] = (0, a.strictParseLong)(e[ba])),
				e[ya] != null && (r[ya] = (0, a.strictParseLong)(e[ya])),
				e[Ea] != null && (r[Ea] = (0, a.strictParseLong)(e[Ea])),
				r
			)
		}, 'de_Stats'),
		wCe = d((e, t) => {
			let r = {}
			return e[xa] != null && (r[xa] = xCe(e[xa], t)), r
		}, 'de_StorageClassAnalysis'),
		xCe = d((e, t) => {
			let r = {}
			return (
				e[Ma] != null && (r[Ma] = (0, a.expectString)(e[Ma])),
				e[wt] != null && (r[wt] = kye(e[wt], t)),
				r
			)
		}, 'de_StorageClassAnalysisDataExport'),
		Ja = d((e, t) => {
			let r = {}
			return (
				e[pe] != null && (r[pe] = (0, a.expectString)(e[pe])),
				e[kr] != null && (r[kr] = (0, a.expectString)(e[kr])),
				r
			)
		}, 'de_Tag'),
		us = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => Ja(r, t)),
			'de_TagSet',
		),
		PCe = d((e, t) => {
			let r = {}
			return (
				e[Rr] != null && (r[Rr] = Gj(e[Rr], t)),
				e[qn] != null && (r[qn] = (0, a.expectString)(e[qn])),
				r
			)
		}, 'de_TargetGrant'),
		ACe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => PCe(r, t)),
			'de_TargetGrants',
		),
		OCe = d((e, t) => {
			let r = {}
			return (
				e[ns] != null && (r[ns] = _Ce(e[ns], t)),
				e[Yo] != null && (r[Yo] = KSe(e[Yo], t)),
				r
			)
		}, 'de_TargetObjectKeyFormat'),
		RCe = d((e, t) => {
			let r = {}
			return (
				e[Ie] != null && (r[Ie] = (0, a.strictParseInt32)(e[Ie])),
				e[oi] != null && (r[oi] = (0, a.expectString)(e[oi])),
				r
			)
		}, 'de_Tiering'),
		kCe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => RCe(r, t)),
			'de_TieringList',
		),
		ICe = d((e, t) => {
			let r = {}
			return (
				e[ce] != null && (r[ce] = (0, a.expectString)(e[ce])),
				e[jS] != null && (r[tp] = (0, a.expectString)(e[jS])),
				e.Event === ''
					? (r[ai] = [])
					: e[as] != null &&
						(r[ai] = KS((0, a.getArrayIfSingleItem)(e[as]), t)),
				e[ae] != null && (r[ae] = WS(e[ae], t)),
				r
			)
		}, 'de_TopicConfiguration'),
		TCe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => ICe(r, t)),
			'de_TopicConfigurationList',
		),
		BCe = d((e, t) => {
			let r = {}
			return (
				e[ur] != null &&
					(r[ur] = (0, a.expectNonNull)(
						(0, a.parseRfc3339DateTimeWithOffset)(e[ur]),
					)),
				e[Ie] != null && (r[Ie] = (0, a.strictParseInt32)(e[Ie])),
				e[_e] != null && (r[_e] = (0, a.expectString)(e[_e])),
				r
			)
		}, 'de_Transition'),
		NCe = d(
			(e, t) => (e || []).filter((r) => r != null).map((r) => BCe(r, t)),
			'de_TransitionList',
		),
		D = d(
			(e) => ({
				httpStatusCode: e.statusCode,
				requestId:
					e.headers['x-amzn-requestid'] ??
					e.headers['x-amzn-request-id'] ??
					e.headers['x-amz-request-id'],
				extendedRequestId: e.headers['x-amz-id-2'],
				cfId: e.headers['x-amz-cf-id'],
			}),
			'deserializeMetadata',
		),
		DCe = d(
			(e, t) => (0, a.collectBody)(e, t).then((r) => t.utf8Encoder(r)),
			'collectBodyString',
		),
		I = d(
			(e) =>
				e != null &&
				e !== '' &&
				(!Object.getOwnPropertyNames(e).includes('length') || e.length != 0) &&
				(!Object.getOwnPropertyNames(e).includes('size') || e.size != 0),
			'isSerializableHeaderValue',
		),
		ft = 'And',
		LCe = 'AnalyticsAndOperator',
		aS = 'AnalyticsConfiguration',
		Qa = 'ACL',
		Bo = 'AccessControlList',
		W1 = 'AnalyticsConfigurationList',
		FCe = 'AccessControlPolicy',
		No = 'AccessControlTranslation',
		MCe = 'AccelerateConfiguration',
		Jj = 'AbortDate',
		qCe = 'AnalyticsExportDestination',
		jCe = 'AnalyticsFilter',
		cS = 'AllowedHeader',
		lS = 'AllowedHeaders',
		UCe = 'AnalyticsId',
		Do = 'AbortIncompleteMultipartUpload',
		ga = 'AccountId',
		Ny = 'AccessKeyId',
		dS = 'AllowedMethod',
		uS = 'AllowedMethods',
		mS = 'AllowedOrigin',
		fS = 'AllowedOrigins',
		GCe = 'AccessPointAlias',
		ii = 'AccessPointArn',
		xf = 'AllowQuotedRecordDelimiter',
		XS = 'AcceptRanges',
		Qj = 'AbortRuleId',
		zCe = 'ArchiveStatus',
		HCe = 'AnalyticsS3BucketDestination',
		$Ce = 'AnalyticsS3ExportFileFormat',
		va = 'ApplyServerSideEncryptionByDefault',
		oi = 'AccessTier',
		ha = 'Account',
		Pe = 'Bucket',
		_a = 'BucketAccountId',
		VCe = 'BucketAccelerateStatus',
		$a = 'BypassGovernanceRetention',
		KCe = 'BucketInfo',
		ct = 'BucketKeyEnabled',
		WCe = 'BucketLifecycleConfiguration',
		XCe = 'BucketLocationConstraint',
		YCe = 'BucketLocationName',
		JCe = 'BucketLogsPermission',
		QCe = 'BucketLoggingStatus',
		ZCe = 'BucketLocationType',
		Pp = 'BucketName',
		ya = 'BytesProcessed',
		Sa = 'BlockPublicAcls',
		Ca = 'BlockPublicPolicy',
		e0e = 'BucketRegion',
		Ea = 'BytesReturned',
		ba = 'BytesScanned',
		t0e = 'BucketType',
		r0e = 'BucketVersioningStatus',
		Dn = 'Buckets',
		Dy = 'Credentials',
		Ce = 'ChecksumAlgorithm',
		Ly = 'CannedACL',
		n0e = 'CreateBucketConfiguration',
		Za = 'CacheControl',
		He = 'ChecksumCRC32',
		$e = 'ChecksumCRC32C',
		ec = 'ContentDisposition',
		Fy = 'CreationDate',
		tc = 'ContentEncoding',
		pS = 'CloudFunction',
		X1 = 'CloudFunctionConfiguration',
		rc = 'ContentLanguage',
		Qi = 'ContentLength',
		Zj = 'ChecksumMode',
		Pt = 'ContentMD5',
		i0e = 'CompletedMultipartUpload',
		o0e = 'CORSConfiguration',
		gS = 'CORSRule',
		vS = 'CORSRules',
		Qt = 'CommonPrefixes',
		s0e = 'CompletedPart',
		eU = 'ContentRange',
		Y1 = 'ConfirmRemoveSelfBucketAccess',
		tU = 'CopySource',
		Ve = 'ChecksumSHA1',
		Ke = 'ChecksumSHA256',
		rU = 'CopySourceIfMatch',
		up = 'CopySourceIfModifiedSince',
		nU = 'CopySourceIfNoneMatch',
		mp = 'CopySourceIfUnmodifiedSince',
		a0e = 'CopySourceRange',
		iU = 'CopySourceSSECustomerAlgorithm',
		oU = 'CopySourceSSECustomerKey',
		sU = 'CopySourceSSECustomerKeyMD5',
		wa = 'CSV',
		aU = 'CopySourceVersionId',
		c0e = 'CSVInput',
		l0e = 'CSVOutput',
		nc = 'ContentType',
		je = 'ContinuationToken',
		d0e = 'CompressionType',
		My = 'Checksum',
		Ki = 'Contents',
		qy = 'Code',
		u0e = 'Comments',
		Lo = 'Condition',
		Zt = 'Delimiter',
		Po = 'DaysAfterInitiation',
		xa = 'DataExport',
		fn = 'DeleteMarker',
		Fo = 'DeleteMarkerReplication',
		m0e = 'DeleteMarkerReplicationStatus',
		jy = 'DeleteMarkerVersionId',
		J1 = 'DeleteMarkers',
		pn = 'DisplayName',
		f0e = 'DataRedundancy',
		Mo = 'DefaultRetention',
		Ie = 'Days',
		ur = 'Date',
		Pf = 'Deleted',
		p0e = 'Delete',
		wt = 'Destination',
		g0e = 'Description',
		jn = 'Expires',
		Tf = 'EmailAddress',
		qo = 'EventBridgeConfiguration',
		$ = 'ExpectedBucketOwner',
		v0e = 'ErrorCode',
		jo = 'EncryptionConfiguration',
		Uo = 'ErrorDocument',
		hS = 'ExposeHeaders',
		_S = 'ExposeHeader',
		h0e = 'ErrorMessage',
		Ao = 'ExpiredObjectDeleteMarker',
		Go = 'ExistingObjectReplication',
		_0e = 'ExistingObjectReplicationStatus',
		y0e = 'EnableRequestProgress',
		cU = 'ExpiresString',
		lU = 'ExpectedSourceBucketOwner',
		S0e = 'ExpirationStatus',
		er = 'EncodingType',
		We = 'ETag',
		Uy = 'EncryptionType',
		Pa = 'EventThreshold',
		dU = 'ExpressionType',
		Ln = 'Encryption',
		Gy = 'Enabled',
		Af = 'End',
		Q1 = 'Error',
		Z1 = 'Errors',
		as = 'Event',
		ai = 'Events',
		uU = 'Expression',
		mr = 'Expiration',
		ae = 'Filter',
		mU = 'FieldDelimiter',
		C0e = 'FileHeaderInfo',
		E0e = 'FetchOwner',
		yS = 'FilterRule',
		b0e = 'FilterRuleName',
		w0e = 'FilterRuleValue',
		SS = 'FilterRules',
		CS = 'Field',
		$r = 'Format',
		Aa = 'Frequency',
		ci = 'Grant',
		ic = 'GrantFullControl',
		Bf = 'GlacierJobParameters',
		oc = 'GrantRead',
		sc = 'GrantReadACP',
		YS = 'GrantWrite',
		ac = 'GrantWriteACP',
		kl = 'Grants',
		Rr = 'Grantee',
		Nf = 'HttpErrorCodeReturnedEquals',
		Wi = 'HostName',
		Df = 'HttpRedirectCode',
		ce = 'Id',
		ES = 'InventoryConfiguration',
		eq = 'InventoryConfigurationList',
		zo = 'IndexDocument',
		lt = 'ID',
		x0e = 'InventoryDestination',
		Oo = 'IsEnabled',
		P0e = 'InventoryEncryption',
		A0e = 'InventoryFilter',
		O0e = 'InventoryFormat',
		R0e = 'InventoryFrequency',
		k0e = 'InventoryId',
		I0e = 'InventoryIncludedObjectVersions',
		Oa = 'IsLatest',
		fU = 'IfMatch',
		fp = 'IfModifiedSince',
		Ap = 'IfNoneMatch',
		T0e = 'InventoryOptionalField',
		Ra = 'IncludedObjectVersions',
		zy = 'IsPublic',
		ka = 'IgnorePublicAcls',
		Hy = 'IsRestoreInProgress',
		Ho = 'InputSerialization',
		B0e = 'InventoryS3BucketDestination',
		N0e = 'InventorySchedule',
		Le = 'IsTruncated',
		D0e = 'IntelligentTieringAndOperator',
		L0e = 'IntelligentTieringAccessTier',
		bS = 'IntelligentTieringConfiguration',
		tq = 'IntelligentTieringConfigurationList',
		F0e = 'IntelligentTieringDays',
		M0e = 'IntelligentTieringFilter',
		q0e = 'IntelligentTieringId',
		j0e = 'IntelligentTieringStatus',
		pp = 'IfUnmodifiedSince',
		Ia = 'Initiator',
		$y = 'Initiated',
		Ta = 'JSON',
		U0e = 'JSONInput',
		G0e = 'JSONOutput',
		z0e = 'JSONType',
		pe = 'Key',
		Vy = 'KeyCount',
		Ba = 'KeyId',
		Xi = 'KeyMarker',
		H0e = 'KMSContext',
		Ky = 'KMSKeyId',
		Na = 'KMSMasterKeyID',
		Lf = 'KeyPrefixEquals',
		$o = 'Location',
		Da = 'LocationConstraint',
		Vo = 'LoggingEnabled',
		$0e = 'LifecycleExpiration',
		Ff = 'LambdaFunctionArn',
		wS = 'LambdaFunctionConfigurations',
		V0e = 'LambdaFunctionConfiguration',
		K0e = 'LocationInfo',
		dt = 'LastModified',
		W0e = 'LocationNameAsString',
		X0e = 'LocationPrefix',
		Y0e = 'LifecycleRule',
		J0e = 'LifecycleRuleAndOperator',
		Q0e = 'LifecycleRuleFilter',
		Z0e = 'LocationType',
		Mf = 'Marker',
		eEe = 'MetricsAndOperator',
		Ro = 'MaxAgeSeconds',
		tEe = 'MaxBuckets',
		xS = 'MetricsConfiguration',
		rq = 'MetricsConfigurationList',
		rEe = 'MetadataDirective',
		nEe = 'MaxDirectoryBuckets',
		PS = 'MfaDelete',
		pU = 'MetadataEntry',
		iEe = 'MetricsFilter',
		JS = 'MFA',
		qf = 'MFADelete',
		oEe = 'MetricsId',
		Vr = 'MaxKeys',
		sEe = 'MetadataKey',
		gp = 'MissingMeta',
		si = 'MaxParts',
		aEe = 'MetricsStatus',
		jf = 'MaxUploads',
		cEe = 'MetadataValue',
		Ko = 'Metrics',
		Wy = 'Message',
		ko = 'Minutes',
		Kr = 'Mode',
		it = 'Name',
		lEe = 'NotificationConfiguration',
		dEe = 'NotificationConfigurationFilter',
		fr = 'NextContinuationToken',
		Wr = 'NoncurrentDays',
		QS = 'NotificationId',
		La = 'NextKeyMarker',
		Xy = 'NextMarker',
		Xr = 'NewerNoncurrentVersions',
		Fa = 'NextPartNumberMarker',
		Yy = 'NextUploadIdMarker',
		Wo = 'NoncurrentVersionExpiration',
		Jy = 'NextVersionIdMarker',
		AS = 'NoncurrentVersionTransitions',
		OS = 'NoncurrentVersionTransition',
		ke = 'Owner',
		nq = 'ObjectAttributes',
		uEe = 'OwnershipControls',
		mEe = 'ObjectCannedACL',
		fEe = 'OwnershipControlsRule',
		ma = 'OptionalFields',
		pEe = 'ObjectIdentifier',
		ZS = 'ObjectKey',
		Uf = 'OutputLocation',
		gEe = 'ObjectLockConfiguration',
		Gf = 'ObjectLockEnabled',
		iq = 'ObjectLockEnabledForBucket',
		vEe = 'ObjectLockLegalHold',
		ms = 'ObjectLockLegalHoldStatus',
		cc = 'ObjectLockMode',
		hEe = 'ObjectLockRetention',
		gU = 'ObjectLockRetentionMode',
		Un = 'ObjectLockRetainUntilDate',
		_Ee = 'ObjectLockRule',
		Rl = 'ObjectOwnership',
		Va = 'OptionalObjectAttributes',
		yEe = 'OwnerOverride',
		Qy = 'ObjectParts',
		Xo = 'OutputSerialization',
		Fn = 'ObjectSizeGreaterThan',
		vU = 'ObjectSizeGreaterThanBytes',
		Mn = 'ObjectSizeLessThan',
		hU = 'ObjectSizeLessThanBytes',
		Ma = 'OutputSchemaVersion',
		Zy = 'ObjectSize',
		SEe = 'ObjectVersionId',
		CEe = 'Objects',
		H = 'Prefix',
		EEe = 'PublicAccessBlockConfiguration',
		Ka = 'PartsCount',
		zf = 'PartitionDateSource',
		bEe = 'ParquetInput',
		yr = 'PartNumber',
		Yi = 'PartNumberMarker',
		Yo = 'PartitionedPrefix',
		Hf = 'Payer',
		vp = 'Part',
		eS = 'Parquet',
		Il = 'Parts',
		qn = 'Permission',
		Ji = 'Protocol',
		Io = 'Priority',
		Of = 'Quiet',
		$f = 'QueueArn',
		RS = 'QueueConfiguration',
		kS = 'QueueConfigurations',
		_U = 'QuoteCharacter',
		yU = 'QuoteEscapeCharacter',
		wEe = 'QuoteFields',
		IS = 'Queue',
		SU = 'Range',
		Jo = 'RedirectAllRequestsTo',
		Ze = 'RequestCharged',
		CU = 'ResponseCacheControl',
		EU = 'ResponseContentDisposition',
		bU = 'ResponseContentEncoding',
		wU = 'ResponseContentLanguage',
		xU = 'ResponseContentType',
		xEe = 'ReplicationConfiguration',
		eC = 'RecordDelimiter',
		PU = 'ResponseExpires',
		tS = 'RestoreExpiryDate',
		Vf = 'ReplicaKmsKeyID',
		Kf = 'ReplaceKeyPrefixWith',
		Wf = 'ReplaceKeyWith',
		Qo = 'ReplicaModifications',
		PEe = 'ReplicaModificationsStatus',
		AEe = 'RestoreOutputPath',
		Fe = 'RequestPayer',
		qa = 'RestrictPublicBuckets',
		OEe = 'RequestPaymentConfiguration',
		Xf = 'RequestProgress',
		REe = 'RequestRoute',
		kEe = 'ReplicationRuleAndOperator',
		IEe = 'ReplicationRuleFilter',
		TEe = 'ReplicationRuleStatus',
		BEe = 'RestoreRequestType',
		NEe = 'ReplicationRule',
		DEe = 'RestoreRequest',
		fa = 'RoutingRules',
		hp = 'RoutingRule',
		tC = 'ReplicationStatus',
		ja = 'RestoreStatus',
		LEe = 'RequestToken',
		FEe = 'ReplicationTimeStatus',
		MEe = 'ReplicationTimeValue',
		Zo = 'ReplicationTime',
		Ua = 'RetainUntilDate',
		rC = 'Restore',
		es = 'Redirect',
		Yf = 'Role',
		Sr = 'Rule',
		Qr = 'Rules',
		J = 'Status',
		Jf = 'StartAfter',
		rS = 'SecretAccessKey',
		Yr = 'S3BucketDestination',
		_e = 'StorageClass',
		ts = 'StorageClassAnalysis',
		qEe = 'StorageClassAnalysisDataExport',
		jEe = 'StorageClassAnalysisSchemaVersion',
		oq = 'StatusCode',
		sq = 'SkipDestinationValidation',
		_p = 'SSE-KMS',
		rs = 'SseKmsEncryptedObjects',
		UEe = 'SseKmsEncryptedObjectsStatus',
		GEe = 'S3KeyFilter',
		TS = 'S3Key',
		zEe = 'S3Location',
		HEe = 'SessionMode',
		$Ee = 'SelectObjectContentRequest',
		Qf = 'SelectParameters',
		ns = 'SimplePrefix',
		Zf = 'ScanRange',
		yp = 'SSE-S3',
		is = 'SourceSelectionCriteria',
		br = 'ServerSideEncryption',
		Ga = 'SSEAlgorithm',
		VEe = 'ServerSideEncryptionByDefault',
		KEe = 'ServerSideEncryptionConfiguration',
		At = 'SSECustomerAlgorithm',
		vn = 'SSECustomerKey',
		Ot = 'SSECustomerKeyMD5',
		BS = 'SSEKMS',
		lc = 'SSEKMSEncryptionContext',
		gr = 'SSEKMSKeyId',
		WEe = 'ServerSideEncryptionRule',
		NS = 'SSES3',
		nS = 'SessionToken',
		iS = 'S3',
		za = 'Schedule',
		Rf = 'Setting',
		Jr = 'Size',
		kf = 'Start',
		ep = 'Suffix',
		os = 'Tagging',
		tp = 'TopicArn',
		rp = 'TargetBucket',
		DS = 'TagCount',
		LS = 'TopicConfiguration',
		FS = 'TopicConfigurations',
		XEe = 'TaggingDirective',
		pa = 'TargetGrants',
		YEe = 'TargetGrant',
		ss = 'TargetObjectKeyFormat',
		np = 'TargetPrefix',
		JEe = 'TotalPartsCount',
		mn = 'TagSet',
		AU = 'TransitionStorageClass',
		Ee = 'Tag',
		pr = 'Tags',
		OU = 'Tier',
		MS = 'Tierings',
		qS = 'Tiering',
		Ha = 'Time',
		RU = 'Token',
		jS = 'Topic',
		US = 'Transitions',
		GS = 'Transition',
		Cr = 'Type',
		aq = 'Upload',
		Er = 'UploadId',
		ip = 'UploadIdMarker',
		QEe = 'UserMetadata',
		op = 'URI',
		cq = 'Uploads',
		lq = 'Version',
		kU = 'VersionCount',
		ZEe = 'VersioningConfiguration',
		Se = 'VersionId',
		sp = 'VersionIdMarker',
		kr = 'Value',
		dq = 'Versions',
		ebe = 'WebsiteConfiguration',
		Tl = 'WebsiteRedirectLocation',
		To = 'Years',
		Op = 'analytics',
		IU = 'accelerate',
		Rp = 'acl',
		TU = 'accept-ranges',
		tbe = 'attributes',
		nC = 'cors',
		Bl = 'cache-control',
		Nl = 'content-disposition',
		Dl = 'content-encoding',
		Ll = 'content-language',
		cs = 'content-length',
		Rt = 'content-md5',
		rbe = 'content-range',
		Fl = 'content-type',
		fs = 'continuation-token',
		nbe = 'delete',
		kp = 'delimiter',
		ls = 'expires',
		iC = 'encryption',
		Ip = 'encoding-type',
		Tp = 'etag',
		BU = 'expiresstring',
		ibe = 'fetch-owner',
		Zr = 'id',
		NU = 'if-match',
		DU = 'if-modified-since',
		Bp = 'inventory',
		Np = 'if-none-match',
		Dp = 'intelligent-tiering',
		LU = 'if-unmodified-since',
		FU = 'key-marker',
		oC = 'lifecycle',
		MU = 'legal-hold',
		Wa = 'last-modified',
		qU = 'location',
		jU = 'logging',
		obe = 'list-type',
		Lp = 'metrics',
		sbe = 'marker',
		abe = 'max-buckets',
		cbe = 'max-directory-buckets',
		kt = 'member',
		sC = 'max-keys',
		lbe = 'max-parts',
		dbe = 'max-uploads',
		UU = 'notification',
		aC = 'ownershipControls',
		GU = 'object-lock',
		cC = 'policy',
		lC = 'publicAccessBlock',
		Fp = 'partNumber',
		ube = 'policyStatus',
		mbe = 'part-number-marker',
		Mp = 'prefix',
		dC = 'replication',
		zU = 'requestPayment',
		HU = 'range',
		$U = 'response-cache-control',
		VU = 'response-content-disposition',
		KU = 'response-content-encoding',
		WU = 'response-content-language',
		XU = 'response-content-type',
		YU = 'response-expires',
		fbe = 'restore',
		JU = 'retention',
		pbe = 'session',
		gbe = 'start-after',
		vbe = 'select',
		hbe = 'select-type',
		dc = 'tagging',
		_be = 'torrent',
		QU = 'uploads',
		Ml = 'uploadId',
		ybe = 'upload-id-marker',
		ZU = 'versioning',
		wr = 'versionId',
		Ue = '<?xml version="1.0" encoding="UTF-8"?>',
		Sbe = 'versions',
		Cbe = 'version-id-marker',
		uC = 'website',
		uq = 'xsi:type',
		uc = 'x-amz-acl',
		Sp = 'x-amz-abort-date',
		mq = 'x-amz-access-point-alias',
		e2 = 'x-amz-abort-rule-id',
		Ebe = 'x-amz-archive-status',
		mC = 'x-amz-bypass-governance-retention',
		bbe = 'x-amz-bucket-location-name',
		wbe = 'x-amz-bucket-location-type',
		xbe = 'x-amz-bucket-object-lock-enabled',
		t2 = 'x-amz-bucket-object-lock-token',
		Pbe = 'x-amz-bucket-region',
		fC = 'x-amz-checksum-algorithm',
		ps = 'x-amz-checksum-crc32',
		gs = 'x-amz-checksum-crc32c',
		r2 = 'x-amz-checksum-mode',
		Abe = 'x-amz-confirm-remove-self-bucket-access',
		vs = 'x-amz-checksum-sha1',
		hs = 'x-amz-checksum-sha256',
		n2 = 'x-amz-copy-source',
		i2 = 'x-amz-copy-source-if-match',
		o2 = 'x-amz-copy-source-if-modified-since',
		s2 = 'x-amz-copy-source-if-none-match',
		a2 = 'x-amz-copy-source-if-unmodified-since',
		Obe = 'x-amz-create-session-mode',
		Rbe = 'x-amz-copy-source-range',
		c2 = 'x-amz-copy-source-server-side-encryption-customer-algorithm',
		l2 = 'x-amz-copy-source-server-side-encryption-customer-key',
		d2 = 'x-amz-copy-source-server-side-encryption-customer-key-md5',
		u2 = 'x-amz-copy-source-version-id',
		Zi = 'x-amz-delete-marker',
		ql = 'x-amz-expiration',
		V = 'x-amz-expected-bucket-owner',
		kbe = 'x-amz-fwd-error-code',
		Ibe = 'x-amz-fwd-error-message',
		Tbe = 'x-amz-fwd-header-accept-ranges',
		Bbe = 'x-amz-fwd-header-cache-control',
		Nbe = 'x-amz-fwd-header-content-disposition',
		Dbe = 'x-amz-fwd-header-content-encoding',
		Lbe = 'x-amz-fwd-header-content-language',
		Fbe = 'x-amz-fwd-header-content-range',
		Mbe = 'x-amz-fwd-header-content-type',
		qbe = 'x-amz-fwd-header-etag',
		jbe = 'x-amz-fwd-header-expires',
		Ube = 'x-amz-fwd-header-last-modified',
		Gbe = 'x-amz-fwd-header-x-amz-checksum-crc32',
		zbe = 'x-amz-fwd-header-x-amz-checksum-crc32c',
		Hbe = 'x-amz-fwd-header-x-amz-checksum-sha1',
		$be = 'x-amz-fwd-header-x-amz-checksum-sha256',
		Vbe = 'x-amz-fwd-header-x-amz-delete-marker',
		Kbe = 'x-amz-fwd-header-x-amz-expiration',
		Wbe = 'x-amz-fwd-header-x-amz-missing-meta',
		Xbe = 'x-amz-fwd-header-x-amz-mp-parts-count',
		Ybe = 'x-amz-fwd-header-x-amz-object-lock-legal-hold',
		Jbe = 'x-amz-fwd-header-x-amz-object-lock-mode',
		Qbe = 'x-amz-fwd-header-x-amz-object-lock-retain-until-date',
		Zbe = 'x-amz-fwd-header-x-amz-restore',
		ewe = 'x-amz-fwd-header-x-amz-request-charged',
		twe = 'x-amz-fwd-header-x-amz-replication-status',
		rwe = 'x-amz-fwd-header-x-amz-storage-class',
		nwe = 'x-amz-fwd-header-x-amz-server-side-encryption',
		iwe = 'x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id',
		owe = 'x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled',
		swe = 'x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm',
		awe = 'x-amz-fwd-header-x-amz-server-side-encryption-customer-key-md5',
		cwe = 'x-amz-fwd-header-x-amz-tagging-count',
		lwe = 'x-amz-fwd-header-x-amz-version-id',
		dwe = 'x-amz-fwd-status',
		mc = 'x-amz-grant-full-control',
		fc = 'x-amz-grant-read',
		pc = 'x-amz-grant-read-acp',
		pC = 'x-amz-grant-write',
		gc = 'x-amz-grant-write-acp',
		gC = 'x-amz-mfa',
		uwe = 'x-amz-metadata-directive',
		Cp = 'x-amz-missing-meta',
		mwe = 'x-amz-max-parts',
		Ep = 'x-amz-mp-parts-count',
		fwe = 'x-amz-object-attributes',
		jl = 'x-amz-object-lock-legal-hold',
		Ul = 'x-amz-object-lock-mode',
		ds = 'x-amz-object-lock-retain-until-date',
		pwe = 'x-amz-object-ownership',
		vC = 'x-amz-optional-object-attributes',
		gwe = 'x-amz-part-number-marker',
		m2 = 'x-amz-restore',
		tt = 'x-amz-request-charged',
		vwe = 'x-amz-restore-output-path',
		Me = 'x-amz-request-payer',
		hwe = 'x-amz-request-route',
		f2 = 'x-amz-replication-status',
		_we = 'x-amz-request-token',
		Gl = 'x-amz-storage-class',
		gt = 'x-amz-sdk-checksum-algorithm',
		ywe = 'x-amz-skip-destination-validation',
		p2 = 'x-amz-source-expected-bucket-owner',
		hn = 'x-amz-server-side-encryption',
		_n = 'x-amz-server-side-encryption-aws-kms-key-id',
		xt = 'x-amz-server-side-encryption-bucket-key-enabled',
		vc = 'x-amz-server-side-encryption-context',
		Ft = 'x-amz-server-side-encryption-customer-algorithm',
		yn = 'x-amz-server-side-encryption-customer-key',
		Mt = 'x-amz-server-side-encryption-customer-key-md5',
		hC = 'x-amz-tagging',
		fq = 'x-amz-tagging-count',
		Swe = 'x-amz-tagging-directive',
		Gn = 'x-amz-version-id',
		zl = 'x-amz-website-redirect-location',
		qt = 'x-id',
		g2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				DisableS3ExpressSessionAuth: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, rme.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'CreateSession', {})
			.n('S3Client', 'CreateSessionCommand')
			.f(void 0, Jq)
			.ser(Sfe)
			.de(age)
			.build() {}
	d(g2, 'CreateSessionCommand')
	var _C = g2,
		Cwe = l1(),
		pq = dl(),
		Ewe = d((e) => {
			let t = e.httpAuthSchemes,
				r = e.httpAuthSchemeProvider,
				n = e.credentials
			return {
				setHttpAuthScheme(i) {
					let o = t.findIndex((s) => s.schemeId === i.schemeId)
					o === -1 ? t.push(i) : t.splice(o, 1, i)
				},
				httpAuthSchemes() {
					return t
				},
				setHttpAuthSchemeProvider(i) {
					r = i
				},
				httpAuthSchemeProvider() {
					return r
				},
				setCredentials(i) {
					n = i
				},
				credentials() {
					return n
				},
			}
		}, 'getHttpAuthExtensionConfiguration'),
		bwe = d(
			(e) => ({
				httpAuthSchemes: e.httpAuthSchemes(),
				httpAuthSchemeProvider: e.httpAuthSchemeProvider(),
				credentials: e.credentials(),
			}),
			'resolveHttpAuthRuntimeConfig',
		),
		If = d((e) => e, 'asPartial'),
		wwe = d((e, t) => {
			let r = {
				...If((0, pq.getAwsRegionExtensionConfiguration)(e)),
				...If((0, a.getDefaultExtensionConfiguration)(e)),
				...If((0, oS.getHttpHandlerExtensionConfiguration)(e)),
				...If(Ewe(e)),
			}
			return (
				t.forEach((n) => n.configure(r)),
				{
					...e,
					...(0, pq.resolveAwsRegionExtensionConfiguration)(r),
					...(0, a.resolveDefaultRuntimeConfig)(r),
					...(0, oS.resolveHttpHandlerRuntimeConfig)(r),
					...bwe(r),
				}
			)
		}, 'resolveRuntimeExtensions'),
		v2 = class extends a.Client {
			constructor(...[t]) {
				let r = (0, Cwe.getRuntimeConfig)(t || {}),
					n = nme(r),
					i = (0, $1.resolveUserAgentConfig)(n),
					o = (0, V1.resolveRetryConfig)(i),
					s = (0, Zue.resolveRegionConfig)(o),
					c = (0, H1.resolveHostHeaderConfig)(s),
					l = (0, q.resolveEndpointConfig)(c),
					u = (0, eme.resolveEventStreamSerdeConfig)(l),
					m = (0, K1.resolveHttpAuthSchemeConfig)(u),
					f = (0, Ol.resolveS3Config)(m, { session: [() => this, _C] }),
					p = wwe(f, t?.extensions || [])
				super(p),
					(this.config = p),
					this.middlewareStack.use((0, $1.getUserAgentPlugin)(this.config)),
					this.middlewareStack.use((0, V1.getRetryPlugin)(this.config)),
					this.middlewareStack.use(
						(0, tme.getContentLengthPlugin)(this.config),
					),
					this.middlewareStack.use((0, H1.getHostHeaderPlugin)(this.config)),
					this.middlewareStack.use((0, Jue.getLoggerPlugin)(this.config)),
					this.middlewareStack.use(
						(0, Que.getRecursionDetectionPlugin)(this.config),
					),
					this.middlewareStack.use(
						(0, By.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
							httpAuthSchemeParametersProvider:
								K1.defaultS3HttpAuthSchemeParametersProvider,
							identityProviderConfigProvider: async (g) =>
								new By.DefaultIdentityProviderConfig({
									'aws.auth#sigv4': g.credentials,
									'aws.auth#sigv4a': g.credentials,
								}),
						}),
					),
					this.middlewareStack.use((0, By.getHttpSigningPlugin)(this.config)),
					this.middlewareStack.use(
						(0, Ol.getValidateBucketNamePlugin)(this.config),
					),
					this.middlewareStack.use(
						(0, Yue.getAddExpectContinuePlugin)(this.config),
					),
					this.middlewareStack.use(
						(0, Ol.getRegionRedirectMiddlewarePlugin)(this.config),
					),
					this.middlewareStack.use((0, Ol.getS3ExpressPlugin)(this.config)),
					this.middlewareStack.use(
						(0, Ol.getS3ExpressHttpSigningPlugin)(this.config),
					)
			}
			destroy() {
				super.destroy()
			}
		}
	d(v2, 'S3Client')
	var hc = v2,
		xwe = re(),
		h2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, xwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'AbortMultipartUpload', {})
			.n('S3Client', 'AbortMultipartUploadCommand')
			.f(void 0, void 0)
			.ser(gfe)
			.de(rge)
			.build() {}
	d(h2, 'AbortMultipartUploadCommand')
	var _2 = h2,
		Pwe = re(),
		Sn = f1(),
		y2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Pwe.getThrow200ExceptionsPlugin)(n),
					(0, Sn.getSsecPlugin)(n),
				]
			})
			.s('AmazonS3', 'CompleteMultipartUpload', {})
			.n('S3Client', 'CompleteMultipartUploadCommand')
			.f($q, Hq)
			.ser(vfe)
			.de(nge)
			.build() {}
	d(y2, 'CompleteMultipartUploadCommand')
	var S2 = y2,
		Awe = re(),
		C2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				DisableS3ExpressSessionAuth: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
				CopySource: { type: 'contextParams', name: 'CopySource' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Awe.getThrow200ExceptionsPlugin)(n),
					(0, Sn.getSsecPlugin)(n),
				]
			})
			.s('AmazonS3', 'CopyObject', {})
			.n('S3Client', 'CopyObjectCommand')
			.f(Kq, Vq)
			.ser(hfe)
			.de(ige)
			.build() {}
	d(C2, 'CopyObjectCommand')
	var E2 = C2,
		Owe = _1(),
		Rwe = re(),
		b2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				DisableAccessPoints: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Rwe.getThrow200ExceptionsPlugin)(n),
					(0, Owe.getLocationConstraintPlugin)(n),
				]
			})
			.s('AmazonS3', 'CreateBucket', {})
			.n('S3Client', 'CreateBucketCommand')
			.f(void 0, void 0)
			.ser(_fe)
			.de(oge)
			.build() {}
	d(b2, 'CreateBucketCommand')
	var w2 = b2,
		kwe = re(),
		x2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, kwe.getThrow200ExceptionsPlugin)(n),
					(0, Sn.getSsecPlugin)(n),
				]
			})
			.s('AmazonS3', 'CreateMultipartUpload', {})
			.n('S3Client', 'CreateMultipartUploadCommand')
			.f(Xq, Wq)
			.ser(yfe)
			.de(sge)
			.build() {}
	d(x2, 'CreateMultipartUploadCommand')
	var P2 = x2,
		A2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketAnalyticsConfiguration', {})
			.n('S3Client', 'DeleteBucketAnalyticsConfigurationCommand')
			.f(void 0, void 0)
			.ser(Efe)
			.de(lge)
			.build() {}
	d(A2, 'DeleteBucketAnalyticsConfigurationCommand')
	var O2 = A2,
		R2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucket', {})
			.n('S3Client', 'DeleteBucketCommand')
			.f(void 0, void 0)
			.ser(Cfe)
			.de(cge)
			.build() {}
	d(R2, 'DeleteBucketCommand')
	var k2 = R2,
		I2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketCors', {})
			.n('S3Client', 'DeleteBucketCorsCommand')
			.f(void 0, void 0)
			.ser(bfe)
			.de(dge)
			.build() {}
	d(I2, 'DeleteBucketCorsCommand')
	var T2 = I2,
		B2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketEncryption', {})
			.n('S3Client', 'DeleteBucketEncryptionCommand')
			.f(void 0, void 0)
			.ser(wfe)
			.de(uge)
			.build() {}
	d(B2, 'DeleteBucketEncryptionCommand')
	var N2 = B2,
		D2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketIntelligentTieringConfiguration', {})
			.n('S3Client', 'DeleteBucketIntelligentTieringConfigurationCommand')
			.f(void 0, void 0)
			.ser(xfe)
			.de(mge)
			.build() {}
	d(D2, 'DeleteBucketIntelligentTieringConfigurationCommand')
	var L2 = D2,
		F2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketInventoryConfiguration', {})
			.n('S3Client', 'DeleteBucketInventoryConfigurationCommand')
			.f(void 0, void 0)
			.ser(Pfe)
			.de(fge)
			.build() {}
	d(F2, 'DeleteBucketInventoryConfigurationCommand')
	var M2 = F2,
		q2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketLifecycle', {})
			.n('S3Client', 'DeleteBucketLifecycleCommand')
			.f(void 0, void 0)
			.ser(Afe)
			.de(pge)
			.build() {}
	d(q2, 'DeleteBucketLifecycleCommand')
	var j2 = q2,
		U2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketMetricsConfiguration', {})
			.n('S3Client', 'DeleteBucketMetricsConfigurationCommand')
			.f(void 0, void 0)
			.ser(Ofe)
			.de(gge)
			.build() {}
	d(U2, 'DeleteBucketMetricsConfigurationCommand')
	var G2 = U2,
		z2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketOwnershipControls', {})
			.n('S3Client', 'DeleteBucketOwnershipControlsCommand')
			.f(void 0, void 0)
			.ser(Rfe)
			.de(vge)
			.build() {}
	d(z2, 'DeleteBucketOwnershipControlsCommand')
	var H2 = z2,
		$2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketPolicy', {})
			.n('S3Client', 'DeleteBucketPolicyCommand')
			.f(void 0, void 0)
			.ser(kfe)
			.de(hge)
			.build() {}
	d($2, 'DeleteBucketPolicyCommand')
	var V2 = $2,
		K2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketReplication', {})
			.n('S3Client', 'DeleteBucketReplicationCommand')
			.f(void 0, void 0)
			.ser(Ife)
			.de(_ge)
			.build() {}
	d(K2, 'DeleteBucketReplicationCommand')
	var W2 = K2,
		X2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketTagging', {})
			.n('S3Client', 'DeleteBucketTaggingCommand')
			.f(void 0, void 0)
			.ser(Tfe)
			.de(yge)
			.build() {}
	d(X2, 'DeleteBucketTaggingCommand')
	var Y2 = X2,
		J2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeleteBucketWebsite', {})
			.n('S3Client', 'DeleteBucketWebsiteCommand')
			.f(void 0, void 0)
			.ser(Bfe)
			.de(Sge)
			.build() {}
	d(J2, 'DeleteBucketWebsiteCommand')
	var Q2 = J2,
		Iwe = re(),
		Z2 = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Iwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'DeleteObject', {})
			.n('S3Client', 'DeleteObjectCommand')
			.f(void 0, void 0)
			.ser(Nfe)
			.de(Cge)
			.build() {}
	d(Z2, 'DeleteObjectCommand')
	var eG = Z2,
		ot = F1(),
		Twe = re(),
		tG = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
					(0, Twe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'DeleteObjects', {})
			.n('S3Client', 'DeleteObjectsCommand')
			.f(void 0, void 0)
			.ser(Dfe)
			.de(Ege)
			.build() {}
	d(tG, 'DeleteObjectsCommand')
	var rG = tG,
		Bwe = re(),
		nG = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Bwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'DeleteObjectTagging', {})
			.n('S3Client', 'DeleteObjectTaggingCommand')
			.f(void 0, void 0)
			.ser(Lfe)
			.de(bge)
			.build() {}
	d(nG, 'DeleteObjectTaggingCommand')
	var iG = nG,
		oG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'DeletePublicAccessBlock', {})
			.n('S3Client', 'DeletePublicAccessBlockCommand')
			.f(void 0, void 0)
			.ser(Ffe)
			.de(wge)
			.build() {}
	d(oG, 'DeletePublicAccessBlockCommand')
	var sG = oG,
		Nwe = re(),
		aG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Nwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketAccelerateConfiguration', {})
			.n('S3Client', 'GetBucketAccelerateConfigurationCommand')
			.f(void 0, void 0)
			.ser(Mfe)
			.de(xge)
			.build() {}
	d(aG, 'GetBucketAccelerateConfigurationCommand')
	var cG = aG,
		Dwe = re(),
		lG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Dwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketAcl', {})
			.n('S3Client', 'GetBucketAclCommand')
			.f(void 0, void 0)
			.ser(qfe)
			.de(Pge)
			.build() {}
	d(lG, 'GetBucketAclCommand')
	var dG = lG,
		Lwe = re(),
		uG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Lwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketAnalyticsConfiguration', {})
			.n('S3Client', 'GetBucketAnalyticsConfigurationCommand')
			.f(void 0, void 0)
			.ser(jfe)
			.de(Age)
			.build() {}
	d(uG, 'GetBucketAnalyticsConfigurationCommand')
	var mG = uG,
		Fwe = re(),
		fG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Fwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketCors', {})
			.n('S3Client', 'GetBucketCorsCommand')
			.f(void 0, void 0)
			.ser(Ufe)
			.de(Oge)
			.build() {}
	d(fG, 'GetBucketCorsCommand')
	var pG = fG,
		Mwe = re(),
		gG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Mwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketEncryption', {})
			.n('S3Client', 'GetBucketEncryptionCommand')
			.f(void 0, ej)
			.ser(Gfe)
			.de(Rge)
			.build() {}
	d(gG, 'GetBucketEncryptionCommand')
	var vG = gG,
		qwe = re(),
		hG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, qwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketIntelligentTieringConfiguration', {})
			.n('S3Client', 'GetBucketIntelligentTieringConfigurationCommand')
			.f(void 0, void 0)
			.ser(zfe)
			.de(kge)
			.build() {}
	d(hG, 'GetBucketIntelligentTieringConfigurationCommand')
	var _G = hG,
		jwe = re(),
		yG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, jwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketInventoryConfiguration', {})
			.n('S3Client', 'GetBucketInventoryConfigurationCommand')
			.f(void 0, oj)
			.ser(Hfe)
			.de(Ige)
			.build() {}
	d(yG, 'GetBucketInventoryConfigurationCommand')
	var SG = yG,
		Uwe = re(),
		CG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Uwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketLifecycleConfiguration', {})
			.n('S3Client', 'GetBucketLifecycleConfigurationCommand')
			.f(void 0, void 0)
			.ser($fe)
			.de(Tge)
			.build() {}
	d(CG, 'GetBucketLifecycleConfigurationCommand')
	var EG = CG,
		Gwe = re(),
		bG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Gwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketLocation', {})
			.n('S3Client', 'GetBucketLocationCommand')
			.f(void 0, void 0)
			.ser(Vfe)
			.de(Bge)
			.build() {}
	d(bG, 'GetBucketLocationCommand')
	var wG = bG,
		zwe = re(),
		xG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, zwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketLogging', {})
			.n('S3Client', 'GetBucketLoggingCommand')
			.f(void 0, void 0)
			.ser(Kfe)
			.de(Nge)
			.build() {}
	d(xG, 'GetBucketLoggingCommand')
	var PG = xG,
		Hwe = re(),
		AG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Hwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketMetricsConfiguration', {})
			.n('S3Client', 'GetBucketMetricsConfigurationCommand')
			.f(void 0, void 0)
			.ser(Wfe)
			.de(Dge)
			.build() {}
	d(AG, 'GetBucketMetricsConfigurationCommand')
	var OG = AG,
		$we = re(),
		RG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, $we.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketNotificationConfiguration', {})
			.n('S3Client', 'GetBucketNotificationConfigurationCommand')
			.f(void 0, void 0)
			.ser(Xfe)
			.de(Lge)
			.build() {}
	d(RG, 'GetBucketNotificationConfigurationCommand')
	var kG = RG,
		Vwe = re(),
		IG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Vwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketOwnershipControls', {})
			.n('S3Client', 'GetBucketOwnershipControlsCommand')
			.f(void 0, void 0)
			.ser(Yfe)
			.de(Fge)
			.build() {}
	d(IG, 'GetBucketOwnershipControlsCommand')
	var TG = IG,
		Kwe = re(),
		BG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Kwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketPolicy', {})
			.n('S3Client', 'GetBucketPolicyCommand')
			.f(void 0, void 0)
			.ser(Jfe)
			.de(Mge)
			.build() {}
	d(BG, 'GetBucketPolicyCommand')
	var NG = BG,
		Wwe = re(),
		DG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Wwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketPolicyStatus', {})
			.n('S3Client', 'GetBucketPolicyStatusCommand')
			.f(void 0, void 0)
			.ser(Qfe)
			.de(qge)
			.build() {}
	d(DG, 'GetBucketPolicyStatusCommand')
	var LG = DG,
		Xwe = re(),
		FG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Xwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketReplication', {})
			.n('S3Client', 'GetBucketReplicationCommand')
			.f(void 0, void 0)
			.ser(Zfe)
			.de(jge)
			.build() {}
	d(FG, 'GetBucketReplicationCommand')
	var MG = FG,
		Ywe = re(),
		qG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Ywe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketRequestPayment', {})
			.n('S3Client', 'GetBucketRequestPaymentCommand')
			.f(void 0, void 0)
			.ser(epe)
			.de(Uge)
			.build() {}
	d(qG, 'GetBucketRequestPaymentCommand')
	var jG = qG,
		Jwe = re(),
		UG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Jwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketTagging', {})
			.n('S3Client', 'GetBucketTaggingCommand')
			.f(void 0, void 0)
			.ser(tpe)
			.de(Gge)
			.build() {}
	d(UG, 'GetBucketTaggingCommand')
	var GG = UG,
		Qwe = re(),
		zG = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Qwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketVersioning', {})
			.n('S3Client', 'GetBucketVersioningCommand')
			.f(void 0, void 0)
			.ser(rpe)
			.de(zge)
			.build() {}
	d(zG, 'GetBucketVersioningCommand')
	var HG = zG,
		Zwe = re(),
		$G = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Zwe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetBucketWebsite', {})
			.n('S3Client', 'GetBucketWebsiteCommand')
			.f(void 0, void 0)
			.ser(npe)
			.de(Hge)
			.build() {}
	d($G, 'GetBucketWebsiteCommand')
	var VG = $G,
		exe = re(),
		KG = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, exe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetObjectAcl', {})
			.n('S3Client', 'GetObjectAclCommand')
			.f(void 0, void 0)
			.ser(ope)
			.de(Vge)
			.build() {}
	d(KG, 'GetObjectAclCommand')
	var WG = KG,
		txe = re(),
		XG = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, txe.getThrow200ExceptionsPlugin)(n),
					(0, Sn.getSsecPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetObjectAttributes', {})
			.n('S3Client', 'GetObjectAttributesCommand')
			.f(cj, void 0)
			.ser(spe)
			.de(Kge)
			.build() {}
	d(XG, 'GetObjectAttributesCommand')
	var YG = XG,
		rxe = re(),
		JG = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestChecksumRequired: !1,
						requestValidationModeMember: 'ChecksumMode',
						responseAlgorithms: ['CRC32', 'CRC32C', 'SHA256', 'SHA1'],
					}),
					(0, Sn.getSsecPlugin)(n),
					(0, rxe.getS3ExpiresMiddlewarePlugin)(n),
				]
			})
			.s('AmazonS3', 'GetObject', {})
			.n('S3Client', 'GetObjectCommand')
			.f(aj, sj)
			.ser(ipe)
			.de($ge)
			.build() {}
	d(JG, 'GetObjectCommand')
	var QG = JG,
		nxe = re(),
		ZG = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, nxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetObjectLegalHold', {})
			.n('S3Client', 'GetObjectLegalHoldCommand')
			.f(void 0, void 0)
			.ser(ape)
			.de(Wge)
			.build() {}
	d(ZG, 'GetObjectLegalHoldCommand')
	var ez = ZG,
		ixe = re(),
		tz = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ixe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetObjectLockConfiguration', {})
			.n('S3Client', 'GetObjectLockConfigurationCommand')
			.f(void 0, void 0)
			.ser(cpe)
			.de(Xge)
			.build() {}
	d(tz, 'GetObjectLockConfigurationCommand')
	var rz = tz,
		oxe = re(),
		nz = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, oxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetObjectRetention', {})
			.n('S3Client', 'GetObjectRetentionCommand')
			.f(void 0, void 0)
			.ser(lpe)
			.de(Yge)
			.build() {}
	d(nz, 'GetObjectRetentionCommand')
	var iz = nz,
		sxe = re(),
		oz = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, sxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetObjectTagging', {})
			.n('S3Client', 'GetObjectTaggingCommand')
			.f(void 0, void 0)
			.ser(dpe)
			.de(Jge)
			.build() {}
	d(oz, 'GetObjectTaggingCommand')
	var sz = oz,
		az = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'GetObjectTorrent', {})
			.n('S3Client', 'GetObjectTorrentCommand')
			.f(void 0, lj)
			.ser(upe)
			.de(Qge)
			.build() {}
	d(az, 'GetObjectTorrentCommand')
	var cz = az,
		axe = re(),
		lz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, axe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'GetPublicAccessBlock', {})
			.n('S3Client', 'GetPublicAccessBlockCommand')
			.f(void 0, void 0)
			.ser(mpe)
			.de(Zge)
			.build() {}
	d(lz, 'GetPublicAccessBlockCommand')
	var dz = lz,
		cxe = re(),
		uz = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, cxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'HeadBucket', {})
			.n('S3Client', 'HeadBucketCommand')
			.f(void 0, void 0)
			.ser(fpe)
			.de(eve)
			.build() {}
	d(uz, 'HeadBucketCommand')
	var qp = uz,
		gq = re(),
		mz = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, gq.getThrow200ExceptionsPlugin)(n),
					(0, Sn.getSsecPlugin)(n),
					(0, gq.getS3ExpiresMiddlewarePlugin)(n),
				]
			})
			.s('AmazonS3', 'HeadObject', {})
			.n('S3Client', 'HeadObjectCommand')
			.f(uj, dj)
			.ser(ppe)
			.de(tve)
			.build() {}
	d(mz, 'HeadObjectCommand')
	var jp = mz,
		lxe = re(),
		fz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, lxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'ListBucketAnalyticsConfigurations', {})
			.n('S3Client', 'ListBucketAnalyticsConfigurationsCommand')
			.f(void 0, void 0)
			.ser(gpe)
			.de(rve)
			.build() {}
	d(fz, 'ListBucketAnalyticsConfigurationsCommand')
	var pz = fz,
		dxe = re(),
		gz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, dxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'ListBucketIntelligentTieringConfigurations', {})
			.n('S3Client', 'ListBucketIntelligentTieringConfigurationsCommand')
			.f(void 0, void 0)
			.ser(vpe)
			.de(nve)
			.build() {}
	d(gz, 'ListBucketIntelligentTieringConfigurationsCommand')
	var vz = gz,
		uxe = re(),
		hz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, uxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'ListBucketInventoryConfigurations', {})
			.n('S3Client', 'ListBucketInventoryConfigurationsCommand')
			.f(void 0, mj)
			.ser(hpe)
			.de(ive)
			.build() {}
	d(hz, 'ListBucketInventoryConfigurationsCommand')
	var _z = hz,
		mxe = re(),
		yz = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, mxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'ListBucketMetricsConfigurations', {})
			.n('S3Client', 'ListBucketMetricsConfigurationsCommand')
			.f(void 0, void 0)
			.ser(_pe)
			.de(ove)
			.build() {}
	d(yz, 'ListBucketMetricsConfigurationsCommand')
	var Sz = yz,
		fxe = re(),
		Cz = class extends a.Command.classBuilder()
			.ep({ ...U })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, fxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'ListBuckets', {})
			.n('S3Client', 'ListBucketsCommand')
			.f(void 0, void 0)
			.ser(ype)
			.de(sve)
			.build() {}
	d(Cz, 'ListBucketsCommand')
	var yC = Cz,
		pxe = re(),
		Ez = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, pxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'ListDirectoryBuckets', {})
			.n('S3Client', 'ListDirectoryBucketsCommand')
			.f(void 0, void 0)
			.ser(Spe)
			.de(ave)
			.build() {}
	d(Ez, 'ListDirectoryBucketsCommand')
	var SC = Ez,
		gxe = re(),
		bz = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Prefix: { type: 'contextParams', name: 'Prefix' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, gxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'ListMultipartUploads', {})
			.n('S3Client', 'ListMultipartUploadsCommand')
			.f(void 0, void 0)
			.ser(Cpe)
			.de(cve)
			.build() {}
	d(bz, 'ListMultipartUploadsCommand')
	var wz = bz,
		vxe = re(),
		xz = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Prefix: { type: 'contextParams', name: 'Prefix' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, vxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'ListObjects', {})
			.n('S3Client', 'ListObjectsCommand')
			.f(void 0, void 0)
			.ser(Epe)
			.de(lve)
			.build() {}
	d(xz, 'ListObjectsCommand')
	var Pz = xz,
		hxe = re(),
		Az = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Prefix: { type: 'contextParams', name: 'Prefix' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, hxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'ListObjectsV2', {})
			.n('S3Client', 'ListObjectsV2Command')
			.f(void 0, void 0)
			.ser(bpe)
			.de(dve)
			.build() {}
	d(Az, 'ListObjectsV2Command')
	var CC = Az,
		_xe = re(),
		Oz = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Prefix: { type: 'contextParams', name: 'Prefix' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, _xe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'ListObjectVersions', {})
			.n('S3Client', 'ListObjectVersionsCommand')
			.f(void 0, void 0)
			.ser(wpe)
			.de(uve)
			.build() {}
	d(Oz, 'ListObjectVersionsCommand')
	var Rz = Oz,
		yxe = re(),
		kz = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, yxe.getThrow200ExceptionsPlugin)(n),
					(0, Sn.getSsecPlugin)(n),
				]
			})
			.s('AmazonS3', 'ListParts', {})
			.n('S3Client', 'ListPartsCommand')
			.f(fj, void 0)
			.ser(xpe)
			.de(mve)
			.build() {}
	d(kz, 'ListPartsCommand')
	var EC = kz,
		Iz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !1,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketAccelerateConfiguration', {})
			.n('S3Client', 'PutBucketAccelerateConfigurationCommand')
			.f(void 0, void 0)
			.ser(Ppe)
			.de(fve)
			.build() {}
	d(Iz, 'PutBucketAccelerateConfigurationCommand')
	var Tz = Iz,
		Bz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketAcl', {})
			.n('S3Client', 'PutBucketAclCommand')
			.f(void 0, void 0)
			.ser(Ape)
			.de(pve)
			.build() {}
	d(Bz, 'PutBucketAclCommand')
	var Nz = Bz,
		Dz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'PutBucketAnalyticsConfiguration', {})
			.n('S3Client', 'PutBucketAnalyticsConfigurationCommand')
			.f(void 0, void 0)
			.ser(Ope)
			.de(gve)
			.build() {}
	d(Dz, 'PutBucketAnalyticsConfigurationCommand')
	var Lz = Dz,
		Fz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketCors', {})
			.n('S3Client', 'PutBucketCorsCommand')
			.f(void 0, void 0)
			.ser(Rpe)
			.de(vve)
			.build() {}
	d(Fz, 'PutBucketCorsCommand')
	var Mz = Fz,
		qz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketEncryption', {})
			.n('S3Client', 'PutBucketEncryptionCommand')
			.f(pj, void 0)
			.ser(kpe)
			.de(hve)
			.build() {}
	d(qz, 'PutBucketEncryptionCommand')
	var jz = qz,
		Uz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'PutBucketIntelligentTieringConfiguration', {})
			.n('S3Client', 'PutBucketIntelligentTieringConfigurationCommand')
			.f(void 0, void 0)
			.ser(Ipe)
			.de(_ve)
			.build() {}
	d(Uz, 'PutBucketIntelligentTieringConfigurationCommand')
	var Gz = Uz,
		zz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'PutBucketInventoryConfiguration', {})
			.n('S3Client', 'PutBucketInventoryConfigurationCommand')
			.f(gj, void 0)
			.ser(Tpe)
			.de(yve)
			.build() {}
	d(zz, 'PutBucketInventoryConfigurationCommand')
	var Hz = zz,
		$z = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketLifecycleConfiguration', {})
			.n('S3Client', 'PutBucketLifecycleConfigurationCommand')
			.f(void 0, void 0)
			.ser(Bpe)
			.de(Sve)
			.build() {}
	d($z, 'PutBucketLifecycleConfigurationCommand')
	var Vz = $z,
		Kz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketLogging', {})
			.n('S3Client', 'PutBucketLoggingCommand')
			.f(void 0, void 0)
			.ser(Npe)
			.de(Cve)
			.build() {}
	d(Kz, 'PutBucketLoggingCommand')
	var Wz = Kz,
		Xz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'PutBucketMetricsConfiguration', {})
			.n('S3Client', 'PutBucketMetricsConfigurationCommand')
			.f(void 0, void 0)
			.ser(Dpe)
			.de(Eve)
			.build() {}
	d(Xz, 'PutBucketMetricsConfigurationCommand')
	var Yz = Xz,
		Jz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'PutBucketNotificationConfiguration', {})
			.n('S3Client', 'PutBucketNotificationConfigurationCommand')
			.f(void 0, void 0)
			.ser(Lpe)
			.de(bve)
			.build() {}
	d(Jz, 'PutBucketNotificationConfigurationCommand')
	var Qz = Jz,
		Zz = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketOwnershipControls', {})
			.n('S3Client', 'PutBucketOwnershipControlsCommand')
			.f(void 0, void 0)
			.ser(Fpe)
			.de(wve)
			.build() {}
	d(Zz, 'PutBucketOwnershipControlsCommand')
	var eH = Zz,
		tH = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketPolicy', {})
			.n('S3Client', 'PutBucketPolicyCommand')
			.f(void 0, void 0)
			.ser(Mpe)
			.de(xve)
			.build() {}
	d(tH, 'PutBucketPolicyCommand')
	var rH = tH,
		nH = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketReplication', {})
			.n('S3Client', 'PutBucketReplicationCommand')
			.f(void 0, void 0)
			.ser(qpe)
			.de(Pve)
			.build() {}
	d(nH, 'PutBucketReplicationCommand')
	var iH = nH,
		oH = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketRequestPayment', {})
			.n('S3Client', 'PutBucketRequestPaymentCommand')
			.f(void 0, void 0)
			.ser(jpe)
			.de(Ave)
			.build() {}
	d(oH, 'PutBucketRequestPaymentCommand')
	var sH = oH,
		aH = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketTagging', {})
			.n('S3Client', 'PutBucketTaggingCommand')
			.f(void 0, void 0)
			.ser(Upe)
			.de(Ove)
			.build() {}
	d(aH, 'PutBucketTaggingCommand')
	var cH = aH,
		lH = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketVersioning', {})
			.n('S3Client', 'PutBucketVersioningCommand')
			.f(void 0, void 0)
			.ser(Gpe)
			.de(Rve)
			.build() {}
	d(lH, 'PutBucketVersioningCommand')
	var dH = lH,
		uH = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutBucketWebsite', {})
			.n('S3Client', 'PutBucketWebsiteCommand')
			.f(void 0, void 0)
			.ser(zpe)
			.de(kve)
			.build() {}
	d(uH, 'PutBucketWebsiteCommand')
	var mH = uH,
		Sxe = re(),
		fH = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
					(0, Sxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'PutObjectAcl', {})
			.n('S3Client', 'PutObjectAclCommand')
			.f(void 0, void 0)
			.ser($pe)
			.de(Tve)
			.build() {}
	d(fH, 'PutObjectAclCommand')
	var pH = fH,
		vq = re(),
		gH = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !1,
					}),
					(0, vq.getCheckContentLengthHeaderPlugin)(n),
					(0, vq.getThrow200ExceptionsPlugin)(n),
					(0, Sn.getSsecPlugin)(n),
				]
			})
			.s('AmazonS3', 'PutObject', {})
			.n('S3Client', 'PutObjectCommand')
			.f(Sj, yj)
			.ser(Hpe)
			.de(Ive)
			.build() {}
	d(gH, 'PutObjectCommand')
	var vH = gH,
		Cxe = re(),
		hH = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
					(0, Cxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'PutObjectLegalHold', {})
			.n('S3Client', 'PutObjectLegalHoldCommand')
			.f(void 0, void 0)
			.ser(Vpe)
			.de(Bve)
			.build() {}
	d(hH, 'PutObjectLegalHoldCommand')
	var _H = hH,
		Exe = re(),
		yH = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
					(0, Exe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'PutObjectLockConfiguration', {})
			.n('S3Client', 'PutObjectLockConfigurationCommand')
			.f(void 0, void 0)
			.ser(Kpe)
			.de(Nve)
			.build() {}
	d(yH, 'PutObjectLockConfigurationCommand')
	var SH = yH,
		bxe = re(),
		CH = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
					(0, bxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'PutObjectRetention', {})
			.n('S3Client', 'PutObjectRetentionCommand')
			.f(void 0, void 0)
			.ser(Wpe)
			.de(Dve)
			.build() {}
	d(CH, 'PutObjectRetentionCommand')
	var EH = CH,
		wxe = re(),
		bH = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
					(0, wxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'PutObjectTagging', {})
			.n('S3Client', 'PutObjectTaggingCommand')
			.f(void 0, void 0)
			.ser(Xpe)
			.de(Lve)
			.build() {}
	d(bH, 'PutObjectTaggingCommand')
	var wH = bH,
		xH = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseS3ExpressControlEndpoint: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !0,
					}),
				]
			})
			.s('AmazonS3', 'PutPublicAccessBlock', {})
			.n('S3Client', 'PutPublicAccessBlockCommand')
			.f(void 0, void 0)
			.ser(Ype)
			.de(Fve)
			.build() {}
	d(xH, 'PutPublicAccessBlockCommand')
	var PH = xH,
		xxe = re(),
		AH = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !1,
					}),
					(0, xxe.getThrow200ExceptionsPlugin)(n),
				]
			})
			.s('AmazonS3', 'RestoreObject', {})
			.n('S3Client', 'RestoreObjectCommand')
			.f(xj, void 0)
			.ser(Jpe)
			.de(Mve)
			.build() {}
	d(AH, 'RestoreObjectCommand')
	var OH = AH,
		Pxe = re(),
		RH = class extends a.Command.classBuilder()
			.ep({ ...U, Bucket: { type: 'contextParams', name: 'Bucket' } })
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Pxe.getThrow200ExceptionsPlugin)(n),
					(0, Sn.getSsecPlugin)(n),
				]
			})
			.s('AmazonS3', 'SelectObjectContent', { eventStream: { output: !0 } })
			.n('S3Client', 'SelectObjectContentCommand')
			.f(Aj, Pj)
			.ser(Qpe)
			.de(qve)
			.build() {}
	d(RH, 'SelectObjectContentCommand')
	var kH = RH,
		Axe = re(),
		IH = class extends a.Command.classBuilder()
			.ep({
				...U,
				Bucket: { type: 'contextParams', name: 'Bucket' },
				Key: { type: 'contextParams', name: 'Key' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, ot.getFlexibleChecksumsPlugin)(n, {
						input: this.input,
						requestAlgorithmMember: 'ChecksumAlgorithm',
						requestChecksumRequired: !1,
					}),
					(0, Axe.getThrow200ExceptionsPlugin)(n),
					(0, Sn.getSsecPlugin)(n),
				]
			})
			.s('AmazonS3', 'UploadPart', {})
			.n('S3Client', 'UploadPartCommand')
			.f(Rj, Oj)
			.ser(Zpe)
			.de(jve)
			.build() {}
	d(IH, 'UploadPartCommand')
	var TH = IH,
		Oxe = re(),
		BH = class extends a.Command.classBuilder()
			.ep({
				...U,
				DisableS3ExpressSessionAuth: { type: 'staticContextParams', value: !0 },
				Bucket: { type: 'contextParams', name: 'Bucket' },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
					(0, Oxe.getThrow200ExceptionsPlugin)(n),
					(0, Sn.getSsecPlugin)(n),
				]
			})
			.s('AmazonS3', 'UploadPartCopy', {})
			.n('S3Client', 'UploadPartCopyCommand')
			.f(Ij, kj)
			.ser(ege)
			.de(Uve)
			.build() {}
	d(BH, 'UploadPartCopyCommand')
	var NH = BH,
		DH = class extends a.Command.classBuilder()
			.ep({
				...U,
				UseObjectLambdaEndpoint: { type: 'staticContextParams', value: !0 },
			})
			.m(function (t, r, n, i) {
				return [
					(0, j.getSerdePlugin)(n, this.serialize, this.deserialize),
					(0, q.getEndpointPlugin)(n, t.getEndpointParameterInstructions()),
				]
			})
			.s('AmazonS3', 'WriteGetObjectResponse', {})
			.n('S3Client', 'WriteGetObjectResponseCommand')
			.f(Tj, void 0)
			.ser(tge)
			.de(Gve)
			.build() {}
	d(DH, 'WriteGetObjectResponseCommand')
	var LH = DH,
		Rxe = {
			AbortMultipartUploadCommand: _2,
			CompleteMultipartUploadCommand: S2,
			CopyObjectCommand: E2,
			CreateBucketCommand: w2,
			CreateMultipartUploadCommand: P2,
			CreateSessionCommand: _C,
			DeleteBucketCommand: k2,
			DeleteBucketAnalyticsConfigurationCommand: O2,
			DeleteBucketCorsCommand: T2,
			DeleteBucketEncryptionCommand: N2,
			DeleteBucketIntelligentTieringConfigurationCommand: L2,
			DeleteBucketInventoryConfigurationCommand: M2,
			DeleteBucketLifecycleCommand: j2,
			DeleteBucketMetricsConfigurationCommand: G2,
			DeleteBucketOwnershipControlsCommand: H2,
			DeleteBucketPolicyCommand: V2,
			DeleteBucketReplicationCommand: W2,
			DeleteBucketTaggingCommand: Y2,
			DeleteBucketWebsiteCommand: Q2,
			DeleteObjectCommand: eG,
			DeleteObjectsCommand: rG,
			DeleteObjectTaggingCommand: iG,
			DeletePublicAccessBlockCommand: sG,
			GetBucketAccelerateConfigurationCommand: cG,
			GetBucketAclCommand: dG,
			GetBucketAnalyticsConfigurationCommand: mG,
			GetBucketCorsCommand: pG,
			GetBucketEncryptionCommand: vG,
			GetBucketIntelligentTieringConfigurationCommand: _G,
			GetBucketInventoryConfigurationCommand: SG,
			GetBucketLifecycleConfigurationCommand: EG,
			GetBucketLocationCommand: wG,
			GetBucketLoggingCommand: PG,
			GetBucketMetricsConfigurationCommand: OG,
			GetBucketNotificationConfigurationCommand: kG,
			GetBucketOwnershipControlsCommand: TG,
			GetBucketPolicyCommand: NG,
			GetBucketPolicyStatusCommand: LG,
			GetBucketReplicationCommand: MG,
			GetBucketRequestPaymentCommand: jG,
			GetBucketTaggingCommand: GG,
			GetBucketVersioningCommand: HG,
			GetBucketWebsiteCommand: VG,
			GetObjectCommand: QG,
			GetObjectAclCommand: WG,
			GetObjectAttributesCommand: YG,
			GetObjectLegalHoldCommand: ez,
			GetObjectLockConfigurationCommand: rz,
			GetObjectRetentionCommand: iz,
			GetObjectTaggingCommand: sz,
			GetObjectTorrentCommand: cz,
			GetPublicAccessBlockCommand: dz,
			HeadBucketCommand: qp,
			HeadObjectCommand: jp,
			ListBucketAnalyticsConfigurationsCommand: pz,
			ListBucketIntelligentTieringConfigurationsCommand: vz,
			ListBucketInventoryConfigurationsCommand: _z,
			ListBucketMetricsConfigurationsCommand: Sz,
			ListBucketsCommand: yC,
			ListDirectoryBucketsCommand: SC,
			ListMultipartUploadsCommand: wz,
			ListObjectsCommand: Pz,
			ListObjectsV2Command: CC,
			ListObjectVersionsCommand: Rz,
			ListPartsCommand: EC,
			PutBucketAccelerateConfigurationCommand: Tz,
			PutBucketAclCommand: Nz,
			PutBucketAnalyticsConfigurationCommand: Lz,
			PutBucketCorsCommand: Mz,
			PutBucketEncryptionCommand: jz,
			PutBucketIntelligentTieringConfigurationCommand: Gz,
			PutBucketInventoryConfigurationCommand: Hz,
			PutBucketLifecycleConfigurationCommand: Vz,
			PutBucketLoggingCommand: Wz,
			PutBucketMetricsConfigurationCommand: Yz,
			PutBucketNotificationConfigurationCommand: Qz,
			PutBucketOwnershipControlsCommand: eH,
			PutBucketPolicyCommand: rH,
			PutBucketReplicationCommand: iH,
			PutBucketRequestPaymentCommand: sH,
			PutBucketTaggingCommand: cH,
			PutBucketVersioningCommand: dH,
			PutBucketWebsiteCommand: mH,
			PutObjectCommand: vH,
			PutObjectAclCommand: pH,
			PutObjectLegalHoldCommand: _H,
			PutObjectLockConfigurationCommand: SH,
			PutObjectRetentionCommand: EH,
			PutObjectTaggingCommand: wH,
			PutPublicAccessBlockCommand: PH,
			RestoreObjectCommand: OH,
			SelectObjectContentCommand: kH,
			UploadPartCommand: TH,
			UploadPartCopyCommand: NH,
			WriteGetObjectResponseCommand: LH,
		},
		FH = class extends hc {}
	d(FH, 'S3')
	var MH = FH
	;(0, a.createAggregatedClient)(Rxe, MH)
	var kxe = (Ut(), ve(ir)),
		Ixe = (0, kxe.createPaginator)(
			hc,
			yC,
			'ContinuationToken',
			'ContinuationToken',
			'MaxBuckets',
		),
		Txe = (Ut(), ve(ir)),
		Bxe = (0, Txe.createPaginator)(
			hc,
			SC,
			'ContinuationToken',
			'ContinuationToken',
			'MaxDirectoryBuckets',
		),
		Nxe = (Ut(), ve(ir)),
		Dxe = (0, Nxe.createPaginator)(
			hc,
			CC,
			'ContinuationToken',
			'NextContinuationToken',
			'MaxKeys',
		),
		Lxe = (Ut(), ve(ir)),
		Fxe = (0, Lxe.createPaginator)(
			hc,
			EC,
			'PartNumberMarker',
			'NextPartNumberMarker',
			'MaxParts',
		),
		pt = z1(),
		qH = d(async (e, t) => {
			let r
			try {
				return (
					(r = await e.send(new qp(t))),
					{ state: pt.WaiterState.SUCCESS, reason: r }
				)
			} catch (n) {
				if (((r = n), n.name && n.name == 'NotFound'))
					return { state: pt.WaiterState.RETRY, reason: r }
			}
			return { state: pt.WaiterState.RETRY, reason: r }
		}, 'checkState'),
		Mxe = d(async (e, t) => {
			let r = { minDelay: 5, maxDelay: 120 }
			return (0, pt.createWaiter)({ ...r, ...e }, t, qH)
		}, 'waitForBucketExists'),
		qxe = d(async (e, t) => {
			let r = { minDelay: 5, maxDelay: 120 },
				n = await (0, pt.createWaiter)({ ...r, ...e }, t, qH)
			return (0, pt.checkExceptions)(n)
		}, 'waitUntilBucketExists'),
		jH = d(async (e, t) => {
			let r
			try {
				r = await e.send(new qp(t))
			} catch (n) {
				if (((r = n), n.name && n.name == 'NotFound'))
					return { state: pt.WaiterState.SUCCESS, reason: r }
			}
			return { state: pt.WaiterState.RETRY, reason: r }
		}, 'checkState'),
		jxe = d(async (e, t) => {
			let r = { minDelay: 5, maxDelay: 120 }
			return (0, pt.createWaiter)({ ...r, ...e }, t, jH)
		}, 'waitForBucketNotExists'),
		Uxe = d(async (e, t) => {
			let r = { minDelay: 5, maxDelay: 120 },
				n = await (0, pt.createWaiter)({ ...r, ...e }, t, jH)
			return (0, pt.checkExceptions)(n)
		}, 'waitUntilBucketNotExists'),
		UH = d(async (e, t) => {
			let r
			try {
				return (
					(r = await e.send(new jp(t))),
					{ state: pt.WaiterState.SUCCESS, reason: r }
				)
			} catch (n) {
				if (((r = n), n.name && n.name == 'NotFound'))
					return { state: pt.WaiterState.RETRY, reason: r }
			}
			return { state: pt.WaiterState.RETRY, reason: r }
		}, 'checkState'),
		Gxe = d(async (e, t) => {
			let r = { minDelay: 5, maxDelay: 120 }
			return (0, pt.createWaiter)({ ...r, ...e }, t, UH)
		}, 'waitForObjectExists'),
		zxe = d(async (e, t) => {
			let r = { minDelay: 5, maxDelay: 120 },
				n = await (0, pt.createWaiter)({ ...r, ...e }, t, UH)
			return (0, pt.checkExceptions)(n)
		}, 'waitUntilObjectExists'),
		GH = d(async (e, t) => {
			let r
			try {
				r = await e.send(new jp(t))
			} catch (n) {
				if (((r = n), n.name && n.name == 'NotFound'))
					return { state: pt.WaiterState.SUCCESS, reason: r }
			}
			return { state: pt.WaiterState.RETRY, reason: r }
		}, 'checkState'),
		Hxe = d(async (e, t) => {
			let r = { minDelay: 5, maxDelay: 120 }
			return (0, pt.createWaiter)({ ...r, ...e }, t, GH)
		}, 'waitForObjectNotExists'),
		$xe = d(async (e, t) => {
			let r = { minDelay: 5, maxDelay: 120 },
				n = await (0, pt.createWaiter)({ ...r, ...e }, t, GH)
			return (0, pt.checkExceptions)(n)
		}, 'waitUntilObjectNotExists')
})
var YH = E((mDe, XH) => {
	XH.exports = tr
	function tr(e) {
		if (!(this instanceof tr)) return new tr(e)
		this.value = e
	}
	tr.prototype.get = function (e) {
		for (var t = this.value, r = 0; r < e.length; r++) {
			var n = e[r]
			if (!Object.hasOwnProperty.call(t, n)) {
				t = void 0
				break
			}
			t = t[n]
		}
		return t
	}
	tr.prototype.set = function (e, t) {
		for (var r = this.value, n = 0; n < e.length - 1; n++) {
			var i = e[n]
			Object.hasOwnProperty.call(r, i) || (r[i] = {}), (r = r[i])
		}
		return (r[e[n]] = t), t
	}
	tr.prototype.map = function (e) {
		return KH(this.value, e, !0)
	}
	tr.prototype.forEach = function (e) {
		return (this.value = KH(this.value, e, !1)), this.value
	}
	tr.prototype.reduce = function (e, t) {
		var r = arguments.length === 1,
			n = r ? this.value : t
		return (
			this.forEach(function (i) {
				;(!this.isRoot || !r) && (n = e.call(this, n, i))
			}),
			n
		)
	}
	tr.prototype.deepEqual = function (e) {
		if (arguments.length !== 1)
			throw new Error(
				'deepEqual requires exactly one object to compare against',
			)
		var t = !0,
			r = e
		return (
			this.forEach(function (n) {
				var i = function () {
					t = !1
				}.bind(this)
				if (!this.isRoot) {
					if (typeof r != 'object') return i()
					r = r[this.key]
				}
				var o = r
				this.post(function () {
					r = o
				})
				var s = function (f) {
					return Object.prototype.toString.call(f)
				}
				if (this.circular) tr(e).get(this.circular.path) !== o && i()
				else if (typeof o != typeof n) i()
				else if (o === null || n === null || o === void 0 || n === void 0)
					o !== n && i()
				else if (o.__proto__ !== n.__proto__) i()
				else if (o !== n) {
					if (typeof o == 'function')
						o instanceof RegExp
							? o.toString() != n.toString() && i()
							: o !== n && i()
					else if (typeof o == 'object')
						if (s(n) === '[object Arguments]' || s(o) === '[object Arguments]')
							s(o) !== s(n) && i()
						else if (o instanceof Date || n instanceof Date)
							(!(o instanceof Date) ||
								!(n instanceof Date) ||
								o.getTime() !== n.getTime()) &&
								i()
						else {
							var c = Object.keys(o),
								l = Object.keys(n)
							if (c.length !== l.length) return i()
							for (var u = 0; u < c.length; u++) {
								var m = c[u]
								Object.hasOwnProperty.call(n, m) || i()
							}
						}
				}
			}),
			t
		)
	}
	tr.prototype.paths = function () {
		var e = []
		return (
			this.forEach(function (t) {
				e.push(this.path)
			}),
			e
		)
	}
	tr.prototype.nodes = function () {
		var e = []
		return (
			this.forEach(function (t) {
				e.push(this.node)
			}),
			e
		)
	}
	tr.prototype.clone = function () {
		var e = [],
			t = []
		return (function r(n) {
			for (var i = 0; i < e.length; i++) if (e[i] === n) return t[i]
			if (typeof n == 'object' && n !== null) {
				var o = WH(n)
				return (
					e.push(n),
					t.push(o),
					Object.keys(n).forEach(function (s) {
						o[s] = r(n[s])
					}),
					e.pop(),
					t.pop(),
					o
				)
			} else return n
		})(this.value)
	}
	function KH(e, t, r) {
		var n = [],
			i = [],
			o = !0
		return (function s(c) {
			var l = r ? WH(c) : c,
				u = {},
				m = {
					node: l,
					node_: c,
					path: [].concat(n),
					parent: i.slice(-1)[0],
					key: n.slice(-1)[0],
					isRoot: n.length === 0,
					level: n.length,
					circular: null,
					update: function (v) {
						m.isRoot || (m.parent.node[m.key] = v), (m.node = v)
					},
					delete: function () {
						delete m.parent.node[m.key]
					},
					remove: function () {
						Array.isArray(m.parent.node)
							? m.parent.node.splice(m.key, 1)
							: delete m.parent.node[m.key]
					},
					before: function (v) {
						u.before = v
					},
					after: function (v) {
						u.after = v
					},
					pre: function (v) {
						u.pre = v
					},
					post: function (v) {
						u.post = v
					},
					stop: function () {
						o = !1
					},
				}
			if (!o) return m
			if (typeof l == 'object' && l !== null) {
				m.isLeaf = Object.keys(l).length == 0
				for (var f = 0; f < i.length; f++)
					if (i[f].node_ === c) {
						m.circular = i[f]
						break
					}
			} else m.isLeaf = !0
			;(m.notLeaf = !m.isLeaf), (m.notRoot = !m.isRoot)
			var p = t.call(m, m.node)
			if (
				(p !== void 0 && m.update && m.update(p),
				u.before && u.before.call(m, m.node),
				typeof m.node == 'object' && m.node !== null && !m.circular)
			) {
				i.push(m)
				var g = Object.keys(m.node)
				g.forEach(function (v, _) {
					n.push(v), u.pre && u.pre.call(m, m.node[v], v)
					var y = s(m.node[v])
					r && Object.hasOwnProperty.call(m.node, v) && (m.node[v] = y.node),
						(y.isLast = _ == g.length - 1),
						(y.isFirst = _ == 0),
						u.post && u.post.call(m, y),
						n.pop()
				}),
					i.pop()
			}
			return u.after && u.after.call(m, m.node), m
		})(e).node
	}
	Object.keys(tr.prototype).forEach(function (e) {
		tr[e] = function (t) {
			var r = [].slice.call(arguments, 1),
				n = tr(t)
			return n[e].apply(n, r)
		}
	})
	function WH(e) {
		if (typeof e == 'object' && e !== null) {
			var t
			return (
				Array.isArray(e)
					? (t = [])
					: e instanceof Date
						? (t = new Date(e))
						: e instanceof Boolean
							? (t = new Boolean(e))
							: e instanceof Number
								? (t = new Number(e))
								: e instanceof String
									? (t = new String(e))
									: (t = Object.create(Object.getPrototypeOf(e))),
				Object.keys(e).forEach(function (r) {
					t[r] = e[r]
				}),
				t
			)
		} else return e
	}
})
var QH = E((fDe, JH) => {
	var Kxe = YH(),
		Wxe = require('events').EventEmitter
	JH.exports = _c
	function _c(e) {
		var t = _c.saw(e, {}),
			r = e.call(t.handlers, t)
		return r !== void 0 && (t.handlers = r), t.record(), t.chain()
	}
	_c.light = function (t) {
		var r = _c.saw(t, {}),
			n = t.call(r.handlers, r)
		return n !== void 0 && (r.handlers = n), r.chain()
	}
	_c.saw = function (e, t) {
		var r = new Wxe()
		return (
			(r.handlers = t),
			(r.actions = []),
			(r.chain = function () {
				var n = Kxe(r.handlers).map(function (i) {
					if (this.isRoot) return i
					var o = this.path
					typeof i == 'function' &&
						this.update(function () {
							return (
								r.actions.push({ path: o, args: [].slice.call(arguments) }), n
							)
						})
				})
				return (
					process.nextTick(function () {
						r.emit('begin'), r.next()
					}),
					n
				)
			}),
			(r.pop = function () {
				return r.actions.shift()
			}),
			(r.next = function () {
				var n = r.pop()
				if (!n) r.emit('end')
				else if (!n.trap) {
					var i = r.handlers
					n.path.forEach(function (o) {
						i = i[o]
					}),
						i.apply(r.handlers, n.args)
				}
			}),
			(r.nest = function (n) {
				var i = [].slice.call(arguments, 1),
					o = !0
				if (typeof n == 'boolean') {
					var o = n
					n = i.shift()
				}
				var s = _c.saw(e, {}),
					c = e.call(s.handlers, s)
				c !== void 0 && (s.handlers = c),
					typeof r.step < 'u' && s.record(),
					n.apply(s.chain(), i),
					o !== !1 && s.on('end', r.next)
			}),
			(r.record = function () {
				Xxe(r)
			}),
			['trap', 'down', 'jump'].forEach(function (n) {
				r[n] = function () {
					throw new Error(
						'To use the trap, down and jump features, please call record() first to start recording actions.',
					)
				}
			}),
			r
		)
	}
	function Xxe(e) {
		;(e.step = 0),
			(e.pop = function () {
				return e.actions[e.step++]
			}),
			(e.trap = function (t, r) {
				var n = Array.isArray(t) ? t : [t]
				e.actions.push({ path: n, step: e.step, cb: r, trap: !0 })
			}),
			(e.down = function (t) {
				var r = (Array.isArray(t) ? t : [t]).join('/'),
					n = e.actions
						.slice(e.step)
						.map(function (o) {
							return o.trap && o.step <= e.step ? !1 : o.path.join('/') == r
						})
						.indexOf(!0)
				n >= 0 ? (e.step += n) : (e.step = e.actions.length)
				var i = e.actions[e.step - 1]
				i && i.trap ? ((e.step = i.step), i.cb()) : e.next()
			}),
			(e.jump = function (t) {
				;(e.step = t), e.next()
			})
	}
})
var e$ = E((pDe, ZH) => {
	ZH.exports = vr
	function vr(e) {
		if (!(this instanceof vr)) return new vr(e)
		;(this.buffers = e || []),
			(this.length = this.buffers.reduce(function (t, r) {
				return t + r.length
			}, 0))
	}
	vr.prototype.push = function () {
		for (var e = 0; e < arguments.length; e++)
			if (!Buffer.isBuffer(arguments[e]))
				throw new TypeError('Tried to push a non-buffer')
		for (var e = 0; e < arguments.length; e++) {
			var t = arguments[e]
			this.buffers.push(t), (this.length += t.length)
		}
		return this.length
	}
	vr.prototype.unshift = function () {
		for (var e = 0; e < arguments.length; e++)
			if (!Buffer.isBuffer(arguments[e]))
				throw new TypeError('Tried to unshift a non-buffer')
		for (var e = 0; e < arguments.length; e++) {
			var t = arguments[e]
			this.buffers.unshift(t), (this.length += t.length)
		}
		return this.length
	}
	vr.prototype.copy = function (e, t, r, n) {
		return this.slice(r, n).copy(e, t, 0, n - r)
	}
	vr.prototype.splice = function (e, t) {
		var r = this.buffers,
			n = e >= 0 ? e : this.length - e,
			i = [].slice.call(arguments, 2)
		t === void 0
			? (t = this.length - n)
			: t > this.length - n && (t = this.length - n)
		for (var e = 0; e < i.length; e++) this.length += i[e].length
		for (
			var o = new vr(), s = 0, c = 0, l = 0;
			l < r.length && c + r[l].length < n;
			l++
		)
			c += r[l].length
		if (n - c > 0) {
			var u = n - c
			if (u + t < r[l].length) {
				o.push(r[l].slice(u, u + t))
				for (var m = r[l], f = new Buffer(u), e = 0; e < u; e++) f[e] = m[e]
				for (var p = new Buffer(m.length - u - t), e = u + t; e < m.length; e++)
					p[e - t - u] = m[e]
				if (i.length > 0) {
					var g = i.slice()
					g.unshift(f),
						g.push(p),
						r.splice.apply(r, [l, 1].concat(g)),
						(l += g.length),
						(i = [])
				} else r.splice(l, 1, f, p), (l += 2)
			} else o.push(r[l].slice(u)), (r[l] = r[l].slice(0, u)), l++
		}
		for (
			i.length > 0 && (r.splice.apply(r, [l, 0].concat(i)), (l += i.length));
			o.length < t;
		) {
			var v = r[l],
				_ = v.length,
				y = Math.min(_, t - o.length)
			y === _
				? (o.push(v), r.splice(l, 1))
				: (o.push(v.slice(0, y)), (r[l] = r[l].slice(y)))
		}
		return (this.length -= o.length), o
	}
	vr.prototype.slice = function (e, t) {
		var r = this.buffers
		t === void 0 && (t = this.length),
			e === void 0 && (e = 0),
			t > this.length && (t = this.length)
		for (var n = 0, i = 0; i < r.length && n + r[i].length <= e; i++)
			n += r[i].length
		for (
			var o = new Buffer(t - e), s = 0, c = i;
			s < t - e && c < r.length;
			c++
		) {
			var l = r[c].length,
				u = s === 0 ? e - n : 0,
				m = s + l >= t - e ? Math.min(u + (t - e) - s, l) : l
			r[c].copy(o, s, u, m), (s += m - u)
		}
		return o
	}
	vr.prototype.pos = function (e) {
		if (e < 0 || e >= this.length) throw new Error('oob')
		for (var t = e, r = 0, n = null; ; ) {
			if (((n = this.buffers[r]), t < n.length)) return { buf: r, offset: t }
			;(t -= n.length), r++
		}
	}
	vr.prototype.get = function (t) {
		var r = this.pos(t)
		return this.buffers[r.buf].get(r.offset)
	}
	vr.prototype.set = function (t, r) {
		var n = this.pos(t)
		return this.buffers[n.buf].set(n.offset, r)
	}
	vr.prototype.indexOf = function (e, t) {
		if (typeof e == 'string') e = new Buffer(e)
		else if (!(e instanceof Buffer))
			throw new Error('Invalid type for a search string')
		if (!e.length) return 0
		if (!this.length) return -1
		var r = 0,
			n = 0,
			i = 0,
			o,
			s = 0
		if (t) {
			var c = this.pos(t)
			;(r = c.buf), (n = c.offset), (s = t)
		}
		for (;;) {
			for (; n >= this.buffers[r].length; )
				if (((n = 0), r++, r >= this.buffers.length)) return -1
			var l = this.buffers[r][n]
			if (l == e[i]) {
				if ((i == 0 && (o = { i: r, j: n, pos: s }), i++, i == e.length))
					return o.pos
			} else i != 0 && ((r = o.i), (n = o.j), (s = o.pos), (i = 0))
			n++, s++
		}
	}
	vr.prototype.toBuffer = function () {
		return this.slice()
	}
	vr.prototype.toString = function (e, t, r) {
		return this.slice(t, r).toString(e)
	}
})
var r$ = E((gDe, t$) => {
	t$.exports = function (e) {
		function t(n, i) {
			var o = r.store,
				s = n.split('.')
			s.slice(0, -1).forEach(function (l) {
				o[l] === void 0 && (o[l] = {}), (o = o[l])
			})
			var c = s[s.length - 1]
			return arguments.length == 1 ? o[c] : (o[c] = i)
		}
		var r = {
			get: function (n) {
				return t(n)
			},
			set: function (n, i) {
				return t(n, i)
			},
			store: e || {},
		}
		return r
	}
})
var c$ = E((_s, a$) => {
	var Yxe = QH(),
		n$ = require('events').EventEmitter,
		Jxe = e$(),
		zp = r$(),
		Qxe = require('stream').Stream
	_s = a$.exports = function (e, t) {
		if (Buffer.isBuffer(e)) return _s.parse(e)
		var r = _s.stream()
		return (
			e && e.pipe
				? e.pipe(r)
				: e &&
					(e.on(t || 'data', function (n) {
						r.write(n)
					}),
					e.on('end', function () {
						r.end()
					})),
			r
		)
	}
	_s.stream = function (e) {
		if (e) return _s.apply(null, arguments)
		var t = null
		function r(f, p, g) {
			;(t = {
				bytes: f,
				skip: g,
				cb: function (v) {
					;(t = null), p(v)
				},
			}),
				i()
		}
		var n = null
		function i() {
			if (!t) {
				m && (u = !0)
				return
			}
			if (typeof t == 'function') t()
			else {
				var f = n + t.bytes
				if (c.length >= f) {
					var p
					n == null
						? ((p = c.splice(0, f)), t.skip || (p = p.slice()))
						: (t.skip || (p = c.slice(n, f)), (n = f)),
						t.skip ? t.cb() : t.cb(p)
				}
			}
		}
		function o(f) {
			function p() {
				u || f.next()
			}
			var g = s$(function (v, _) {
				return function (y) {
					r(v, function (P) {
						l.set(y, _(P)), p()
					})
				}
			})
			return (
				(g.tap = function (v) {
					f.nest(v, l.store)
				}),
				(g.into = function (v, _) {
					l.get(v) || l.set(v, {})
					var y = l
					;(l = zp(y.get(v))),
						f.nest(function () {
							_.apply(this, arguments),
								this.tap(function () {
									l = y
								})
						}, l.store)
				}),
				(g.flush = function () {
					;(l.store = {}), p()
				}),
				(g.loop = function (v) {
					var _ = !1
					f.nest(
						!1,
						function y() {
							;(this.vars = l.store),
								v.call(
									this,
									function () {
										;(_ = !0), p()
									},
									l.store,
								),
								this.tap(
									function () {
										_ ? f.next() : y.call(this)
									}.bind(this),
								)
						},
						l.store,
					)
				}),
				(g.buffer = function (v, _) {
					typeof _ == 'string' && (_ = l.get(_)),
						r(_, function (y) {
							l.set(v, y), p()
						})
				}),
				(g.skip = function (v) {
					typeof v == 'string' && (v = l.get(v)),
						r(v, function () {
							p()
						})
				}),
				(g.scan = function (_, y) {
					if (typeof y == 'string') y = new Buffer(y)
					else if (!Buffer.isBuffer(y))
						throw new Error('search must be a Buffer or a string')
					var P = 0
					;(t = function () {
						var x = c.indexOf(y, n + P),
							W = x - n - P
						x !== -1
							? ((t = null),
								n != null
									? (l.set(_, c.slice(n, n + P + W)), (n += P + W + y.length))
									: (l.set(_, c.slice(0, P + W)),
										c.splice(0, P + W + y.length)),
								p(),
								i())
							: (W = Math.max(c.length - y.length - n - P, 0)),
							(P += W)
					}),
						i()
				}),
				(g.peek = function (v) {
					;(n = 0),
						f.nest(function () {
							v.call(this, l.store),
								this.tap(function () {
									n = null
								})
						})
				}),
				g
			)
		}
		var s = Yxe.light(o)
		s.writable = !0
		var c = Jxe()
		s.write = function (f) {
			c.push(f), i()
		}
		var l = zp(),
			u = !1,
			m = !1
		return (
			(s.end = function () {
				m = !0
			}),
			(s.pipe = Qxe.prototype.pipe),
			Object.getOwnPropertyNames(n$.prototype).forEach(function (f) {
				s[f] = n$.prototype[f]
			}),
			s
		)
	}
	_s.parse = function (t) {
		var r = s$(function (o, s) {
				return function (c) {
					if (n + o <= t.length) {
						var l = t.slice(n, n + o)
						;(n += o), i.set(c, s(l))
					} else i.set(c, null)
					return r
				}
			}),
			n = 0,
			i = zp()
		return (
			(r.vars = i.store),
			(r.tap = function (o) {
				return o.call(r, i.store), r
			}),
			(r.into = function (o, s) {
				i.get(o) || i.set(o, {})
				var c = i
				return (i = zp(c.get(o))), s.call(r, i.store), (i = c), r
			}),
			(r.loop = function (o) {
				for (
					var s = !1,
						c = function () {
							s = !0
						};
					s === !1;
				)
					o.call(r, c, i.store)
				return r
			}),
			(r.buffer = function (o, s) {
				typeof s == 'string' && (s = i.get(s))
				var c = t.slice(n, Math.min(t.length, n + s))
				return (n += s), i.set(o, c), r
			}),
			(r.skip = function (o) {
				return typeof o == 'string' && (o = i.get(o)), (n += o), r
			}),
			(r.scan = function (o, s) {
				if (typeof s == 'string') s = new Buffer(s)
				else if (!Buffer.isBuffer(s))
					throw new Error('search must be a Buffer or a string')
				i.set(o, null)
				for (var c = 0; c + n <= t.length - s.length + 1; c++) {
					for (var l = 0; l < s.length && t[n + c + l] === s[l]; l++);
					if (l === s.length) break
				}
				return i.set(o, t.slice(n, n + c)), (n += c + s.length), r
			}),
			(r.peek = function (o) {
				var s = n
				return o.call(r, i.store), (n = s), r
			}),
			(r.flush = function () {
				return (i.store = {}), r
			}),
			(r.eof = function () {
				return n >= t.length
			}),
			r
		)
	}
	function i$(e) {
		for (var t = 0, r = 0; r < e.length; r++) t += Math.pow(256, r) * e[r]
		return t
	}
	function o$(e) {
		for (var t = 0, r = 0; r < e.length; r++)
			t += Math.pow(256, e.length - r - 1) * e[r]
		return t
	}
	function Zxe(e) {
		var t = o$(e)
		return (e[0] & 128) == 128 && (t -= Math.pow(256, e.length)), t
	}
	function ePe(e) {
		var t = i$(e)
		return (e[e.length - 1] & 128) == 128 && (t -= Math.pow(256, e.length)), t
	}
	function s$(e) {
		var t = {}
		return (
			[1, 2, 4, 8].forEach(function (r) {
				var n = r * 8
				;(t['word' + n + 'le'] = t['word' + n + 'lu'] = e(r, i$)),
					(t['word' + n + 'ls'] = e(r, ePe)),
					(t['word' + n + 'be'] = t['word' + n + 'bu'] = e(r, o$)),
					(t['word' + n + 'bs'] = e(r, Zxe))
			}),
			(t.word8 = t.word8u = t.word8be),
			(t.word8s = t.word8bs),
			t
		)
	}
})
var u$ = E((vDe, d$) => {
	var l$ = require('stream').Transform,
		tPe = require('util')
	function ys(e, t) {
		if (!(this instanceof ys)) return new ys()
		l$.call(this)
		var r = typeof e == 'object' ? e.pattern : e
		;(this.pattern = Buffer.isBuffer(r) ? r : Buffer.from(r)),
			(this.requiredLength = this.pattern.length),
			e.requiredExtraSize && (this.requiredLength += e.requiredExtraSize),
			(this.data = new Buffer('')),
			(this.bytesSoFar = 0),
			(this.matchFn = t)
	}
	tPe.inherits(ys, l$)
	ys.prototype.checkDataChunk = function (e) {
		var t = this.data.length >= this.requiredLength
		if (t) {
			var r = this.data.indexOf(this.pattern, e ? 1 : 0)
			if (r >= 0 && r + this.requiredLength > this.data.length) {
				if (r > 0) {
					var n = this.data.slice(0, r)
					this.push(n), (this.bytesSoFar += r), (this.data = this.data.slice(r))
				}
				return
			}
			if (r === -1) {
				var i = this.data.length - this.requiredLength + 1,
					n = this.data.slice(0, i)
				this.push(n), (this.bytesSoFar += i), (this.data = this.data.slice(i))
				return
			}
			if (r > 0) {
				var n = this.data.slice(0, r)
				;(this.data = this.data.slice(r)), this.push(n), (this.bytesSoFar += r)
			}
			var o = this.matchFn ? this.matchFn(this.data, this.bytesSoFar) : !0
			if (o) {
				this.data = new Buffer('')
				return
			}
			return !0
		}
	}
	ys.prototype._transform = function (e, t, r) {
		this.data = Buffer.concat([this.data, e])
		for (var n = !0; this.checkDataChunk(!n); ) n = !1
		r()
	}
	ys.prototype._flush = function (e) {
		if (this.data.length > 0) for (var t = !0; this.checkDataChunk(!t); ) t = !1
		this.data.length > 0 && (this.push(this.data), (this.data = null)), e()
	}
	d$.exports = ys
})
var f$ = E((hDe, m$) => {
	'use strict'
	var AC = require('stream'),
		rPe = require('util').inherits
	function Hl() {
		if (!(this instanceof Hl)) return new Hl()
		AC.PassThrough.call(this),
			(this.path = null),
			(this.type = null),
			(this.isDirectory = !1)
	}
	rPe(Hl, AC.PassThrough)
	Hl.prototype.autodrain = function () {
		return this.pipe(
			new AC.Transform({
				transform: function (e, t, r) {
					r()
				},
			}),
		)
	}
	m$.exports = Hl
})
var RC = E((_De, g$) => {
	'use strict'
	var to = c$(),
		OC = require('stream'),
		nPe = require('util'),
		iPe = require('zlib'),
		oPe = u$(),
		p$ = f$(),
		de = {
			STREAM_START: 0,
			START: 1,
			LOCAL_FILE_HEADER: 2,
			LOCAL_FILE_HEADER_SUFFIX: 3,
			FILE_DATA: 4,
			FILE_DATA_END: 5,
			DATA_DESCRIPTOR: 6,
			CENTRAL_DIRECTORY_FILE_HEADER: 7,
			CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX: 8,
			CDIR64_END: 9,
			CDIR64_END_DATA_SECTOR: 10,
			CDIR64_LOCATOR: 11,
			CENTRAL_DIRECTORY_END: 12,
			CENTRAL_DIRECTORY_END_COMMENT: 13,
			TRAILING_JUNK: 14,
			ERROR: 99,
		},
		$l = 4294967296,
		sPe = 67324752,
		aPe = 134695760,
		cPe = 33639248,
		lPe = 101075792,
		dPe = 117853008,
		uPe = 101010256
	function Kt(e) {
		if (!(this instanceof Kt)) return new Kt(e)
		OC.Transform.call(this),
			(this.options = e || {}),
			(this.data = new Buffer('')),
			(this.state = de.STREAM_START),
			(this.skippedBytes = 0),
			(this.parsedEntity = null),
			(this.outStreamInfo = {})
	}
	nPe.inherits(Kt, OC.Transform)
	Kt.prototype.processDataChunk = function (e) {
		var t
		switch (this.state) {
			case de.STREAM_START:
			case de.START:
				t = 4
				break
			case de.LOCAL_FILE_HEADER:
				t = 26
				break
			case de.LOCAL_FILE_HEADER_SUFFIX:
				t =
					this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength
				break
			case de.DATA_DESCRIPTOR:
				t = 12
				break
			case de.CENTRAL_DIRECTORY_FILE_HEADER:
				t = 42
				break
			case de.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
				t =
					this.parsedEntity.fileNameLength +
					this.parsedEntity.extraFieldLength +
					this.parsedEntity.fileCommentLength
				break
			case de.CDIR64_END:
				t = 52
				break
			case de.CDIR64_END_DATA_SECTOR:
				t = this.parsedEntity.centralDirectoryRecordSize - 44
				break
			case de.CDIR64_LOCATOR:
				t = 16
				break
			case de.CENTRAL_DIRECTORY_END:
				t = 18
				break
			case de.CENTRAL_DIRECTORY_END_COMMENT:
				t = this.parsedEntity.commentLength
				break
			case de.FILE_DATA:
				return 0
			case de.FILE_DATA_END:
				return 0
			case de.TRAILING_JUNK:
				return (
					this.options.debug &&
						console.log('found', e.length, 'bytes of TRAILING_JUNK'),
					e.length
				)
			default:
				return e.length
		}
		var r = e.length
		if (r < t) return 0
		switch (this.state) {
			case de.STREAM_START:
			case de.START:
				var n = e.readUInt32LE(0)
				switch (n) {
					case sPe:
						this.state = de.LOCAL_FILE_HEADER
						break
					case cPe:
						this.state = de.CENTRAL_DIRECTORY_FILE_HEADER
						break
					case lPe:
						this.state = de.CDIR64_END
						break
					case dPe:
						this.state = de.CDIR64_LOCATOR
						break
					case uPe:
						this.state = de.CENTRAL_DIRECTORY_END
						break
					default:
						var i = this.state === de.STREAM_START
						if (!i && (n & 65535) !== 19280 && this.skippedBytes < 26) {
							for (var o = n, s = 4, c = 1; c < 4 && o !== 0; c++)
								if (((o = o >>> 8), (o & 255) === 80)) {
									s = c
									break
								}
							return (
								(this.skippedBytes += s),
								this.options.debug &&
									console.log('Skipped', this.skippedBytes, 'bytes'),
								s
							)
						}
						this.state = de.ERROR
						var l = i ? 'Not a valid zip file' : 'Invalid signature in zip file'
						if (this.options.debug) {
							var u = e.readUInt32LE(0),
								m
							try {
								m = e.slice(0, 4).toString()
							} catch {}
							console.log(
								'Unexpected signature in zip file: 0x' + u.toString(16),
								'"' + m + '", skipped',
								this.skippedBytes,
								'bytes',
							)
						}
						return this.emit('error', new Error(l)), e.length
				}
				return (this.skippedBytes = 0), t
			case de.LOCAL_FILE_HEADER:
				return (
					(this.parsedEntity = this._readFile(e)),
					(this.state = de.LOCAL_FILE_HEADER_SUFFIX),
					t
				)
			case de.LOCAL_FILE_HEADER_SUFFIX:
				var f = new p$(),
					p = (this.parsedEntity.flags & 2048) !== 0
				f.path = this._decodeString(
					e.slice(0, this.parsedEntity.fileNameLength),
					p,
				)
				var v = e.slice(
						this.parsedEntity.fileNameLength,
						this.parsedEntity.fileNameLength +
							this.parsedEntity.extraFieldLength,
					),
					_ = this._readExtraFields(v)
				if (
					(_ &&
						_.parsed &&
						(_.parsed.path && !p && (f.path = _.parsed.path),
						Number.isFinite(_.parsed.uncompressedSize) &&
							this.parsedEntity.uncompressedSize === $l - 1 &&
							(this.parsedEntity.uncompressedSize = _.parsed.uncompressedSize),
						Number.isFinite(_.parsed.compressedSize) &&
							this.parsedEntity.compressedSize === $l - 1 &&
							(this.parsedEntity.compressedSize = _.parsed.compressedSize)),
					(this.parsedEntity.extra = _.parsed || {}),
					this.options.debug)
				) {
					let X = Object.assign({}, this.parsedEntity, {
						path: f.path,
						flags: '0x' + this.parsedEntity.flags.toString(16),
						extraFields: _ && _.debug,
					})
					console.log('decoded LOCAL_FILE_HEADER:', JSON.stringify(X, null, 2))
				}
				return (
					this._prepareOutStream(this.parsedEntity, f),
					this.emit('entry', f),
					(this.state = de.FILE_DATA),
					t
				)
			case de.CENTRAL_DIRECTORY_FILE_HEADER:
				return (
					(this.parsedEntity = this._readCentralDirectoryEntry(e)),
					(this.state = de.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX),
					t
				)
			case de.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
				var p = (this.parsedEntity.flags & 2048) !== 0,
					g = this._decodeString(
						e.slice(0, this.parsedEntity.fileNameLength),
						p,
					),
					v = e.slice(
						this.parsedEntity.fileNameLength,
						this.parsedEntity.fileNameLength +
							this.parsedEntity.extraFieldLength,
					),
					_ = this._readExtraFields(v)
				_ && _.parsed && _.parsed.path && !p && (g = _.parsed.path),
					(this.parsedEntity.extra = _.parsed)
				var y = (this.parsedEntity.versionMadeBy & 65280) >> 8 === 3,
					P,
					x
				if (y) {
					P = this.parsedEntity.externalFileAttributes >>> 16
					var W = P >>> 12
					x = (W & 10) === 10
				}
				if (this.options.debug) {
					let X = Object.assign({}, this.parsedEntity, {
						path: g,
						flags: '0x' + this.parsedEntity.flags.toString(16),
						unixAttrs: P && '0' + P.toString(8),
						isSymlink: x,
						extraFields: _.debug,
					})
					console.log(
						'decoded CENTRAL_DIRECTORY_FILE_HEADER:',
						JSON.stringify(X, null, 2),
					)
				}
				return (this.state = de.START), t
			case de.CDIR64_END:
				return (
					(this.parsedEntity = this._readEndOfCentralDirectory64(e)),
					this.options.debug &&
						console.log('decoded CDIR64_END_RECORD:', this.parsedEntity),
					(this.state = de.CDIR64_END_DATA_SECTOR),
					t
				)
			case de.CDIR64_END_DATA_SECTOR:
				return (this.state = de.START), t
			case de.CDIR64_LOCATOR:
				return (this.state = de.START), t
			case de.CENTRAL_DIRECTORY_END:
				return (
					(this.parsedEntity = this._readEndOfCentralDirectory(e)),
					this.options.debug &&
						console.log('decoded CENTRAL_DIRECTORY_END:', this.parsedEntity),
					(this.state = de.CENTRAL_DIRECTORY_END_COMMENT),
					t
				)
			case de.CENTRAL_DIRECTORY_END_COMMENT:
				return (
					this.options.debug &&
						console.log(
							'decoded CENTRAL_DIRECTORY_END_COMMENT:',
							e.slice(0, t).toString(),
						),
					(this.state = de.TRAILING_JUNK),
					t
				)
			case de.ERROR:
				return e.length
			default:
				return (
					console.log("didn't handle state #", this.state, 'discarding'),
					e.length
				)
		}
	}
	Kt.prototype._prepareOutStream = function (e, t) {
		var r = this,
			n = e.uncompressedSize === 0 && /[\/\\]$/.test(t.path)
		;(t.path = t.path.replace(/(?<=^|[/\\]+)[.][.]+(?=[/\\]+|$)/g, '.')),
			(t.type = n ? 'Directory' : 'File'),
			(t.isDirectory = n)
		var i = !(e.flags & 8)
		i && (t.size = e.uncompressedSize)
		var o = e.versionsNeededToExtract <= 45
		if (
			((this.outStreamInfo = {
				stream: null,
				limit: i ? e.compressedSize : -1,
				written: 0,
			}),
			i)
		)
			this.outStreamInfo.stream = new OC.PassThrough()
		else {
			var s = new Buffer(4)
			s.writeUInt32LE(aPe, 0)
			var c = e.extra.zip64Mode,
				l = c ? 20 : 12,
				u = { pattern: s, requiredExtraSize: l },
				m = new oPe(u, function (_, y) {
					var P = r._readDataDescriptor(_, c),
						x = P.compressedSize === y
					if (!c && !x && y >= $l)
						for (var W = y - $l; W >= 0 && ((x = P.compressedSize === W), !x); )
							W -= $l
					if (x) {
						r.state = de.FILE_DATA_END
						var X = c ? 24 : 16
						return (
							r.data.length > 0
								? (r.data = Buffer.concat([_.slice(X), r.data]))
								: (r.data = _.slice(X)),
							!0
						)
					}
				})
			this.outStreamInfo.stream = m
		}
		var f = e.flags & 1 || e.flags & 64
		if (f || !o) {
			var p = f
				? 'Encrypted files are not supported!'
				: 'Zip version ' +
					Math.floor(e.versionsNeededToExtract / 10) +
					'.' +
					(e.versionsNeededToExtract % 10) +
					' is not supported'
			;(t.skip = !0),
				setImmediate(() => {
					r.emit('error', new Error(p))
				}),
				this.outStreamInfo.stream.pipe(new p$().autodrain())
			return
		}
		var g = e.compressionMethod > 0
		if (g) {
			var v = iPe.createInflateRaw()
			v.on('error', function (_) {
				;(r.state = de.ERROR), r.emit('error', _)
			}),
				this.outStreamInfo.stream.pipe(v).pipe(t)
		} else this.outStreamInfo.stream.pipe(t)
		this._drainAllEntries && t.autodrain()
	}
	Kt.prototype._readFile = function (e) {
		var t = to
			.parse(e)
			.word16lu('versionsNeededToExtract')
			.word16lu('flags')
			.word16lu('compressionMethod')
			.word16lu('lastModifiedTime')
			.word16lu('lastModifiedDate')
			.word32lu('crc32')
			.word32lu('compressedSize')
			.word32lu('uncompressedSize')
			.word16lu('fileNameLength')
			.word16lu('extraFieldLength').vars
		return t
	}
	Kt.prototype._readExtraFields = function (e) {
		var t = {},
			r = { parsed: t }
		this.options.debug && (r.debug = [])
		for (var n = 0; n < e.length; ) {
			var i = to.parse(e).skip(n).word16lu('extraId').word16lu('extraSize').vars
			n += 4
			var o = void 0
			switch (i.extraId) {
				case 1:
					o = 'Zip64 extended information extra field'
					var s = to
						.parse(e.slice(n, n + i.extraSize))
						.word64lu('uncompressedSize')
						.word64lu('compressedSize')
						.word64lu('offsetToLocalHeader')
						.word32lu('diskStartNumber').vars
					s.uncompressedSize !== null &&
						(t.uncompressedSize = s.uncompressedSize),
						s.compressedSize !== null && (t.compressedSize = s.compressedSize),
						(t.zip64Mode = !0)
					break
				case 10:
					o = 'NTFS extra field'
					break
				case 21589:
					o = 'extended timestamp'
					var c = e.readUInt8(n),
						x = 1
					i.extraSize >= x + 4 &&
						c & 1 &&
						((t.mtime = new Date(e.readUInt32LE(n + x) * 1e3)), (x += 4)),
						i.extraSize >= x + 4 &&
							c & 2 &&
							((t.atime = new Date(e.readUInt32LE(n + x) * 1e3)), (x += 4)),
						i.extraSize >= x + 4 &&
							c & 4 &&
							(t.ctime = new Date(e.readUInt32LE(n + x) * 1e3))
					break
				case 28789:
					o = 'Info-ZIP Unicode Path Extra Field'
					var l = e.readUInt8(n)
					if (l === 1) {
						var x = 1,
							u = e.readUInt32LE(n + x)
						x += 4
						var m = e.slice(n + x)
						t.path = m.toString()
					}
					break
				case 13:
				case 22613:
					o = i.extraId === 13 ? 'PKWARE Unix' : 'Info-ZIP UNIX (type 1)'
					var x = 0
					if (i.extraSize >= 8) {
						var f = new Date(e.readUInt32LE(n + x) * 1e3)
						x += 4
						var p = new Date(e.readUInt32LE(n + x) * 1e3)
						if (((x += 4), (t.atime = f), (t.mtime = p), i.extraSize >= 12)) {
							var g = e.readUInt16LE(n + x)
							x += 2
							var v = e.readUInt16LE(n + x)
							;(x += 2), (t.uid = g), (t.gid = v)
						}
					}
					break
				case 30805:
					o = 'Info-ZIP UNIX (type 2)'
					var x = 0
					if (i.extraSize >= 4) {
						var g = e.readUInt16LE(n + x)
						x += 2
						var v = e.readUInt16LE(n + x)
						;(x += 2), (t.uid = g), (t.gid = v)
					}
					break
				case 30837:
					o = 'Info-ZIP New Unix'
					var x = 0,
						_ = e.readUInt8(n)
					if (((x += 1), _ === 1)) {
						var y = e.readUInt8(n + x)
						;(x += 1), y <= 6 && (t.uid = e.readUIntLE(n + x, y)), (x += y)
						var P = e.readUInt8(n + x)
						;(x += 1), P <= 6 && (t.gid = e.readUIntLE(n + x, P))
					}
					break
				case 30062:
					o = 'ASi Unix'
					var x = 0
					if (i.extraSize >= 14) {
						var W = e.readUInt32LE(n + x)
						x += 4
						var X = e.readUInt16LE(n + x)
						x += 2
						var w = e.readUInt32LE(n + x)
						x += 4
						var g = e.readUInt16LE(n + x)
						x += 2
						var v = e.readUInt16LE(n + x)
						if (
							((x += 2),
							(t.mode = X),
							(t.uid = g),
							(t.gid = v),
							i.extraSize > 14)
						) {
							var b = n + x,
								A = n + i.extraSize - 14,
								R = this._decodeString(e.slice(b, A))
							t.symlink = R
						}
					}
					break
			}
			this.options.debug &&
				r.debug.push({
					extraId: '0x' + i.extraId.toString(16),
					description: o,
					data: e.slice(n, n + i.extraSize).inspect(),
				}),
				(n += i.extraSize)
		}
		return r
	}
	Kt.prototype._readDataDescriptor = function (e, t) {
		if (t) {
			var r = to
				.parse(e)
				.word32lu('dataDescriptorSignature')
				.word32lu('crc32')
				.word64lu('compressedSize')
				.word64lu('uncompressedSize').vars
			return r
		}
		var r = to
			.parse(e)
			.word32lu('dataDescriptorSignature')
			.word32lu('crc32')
			.word32lu('compressedSize')
			.word32lu('uncompressedSize').vars
		return r
	}
	Kt.prototype._readCentralDirectoryEntry = function (e) {
		var t = to
			.parse(e)
			.word16lu('versionMadeBy')
			.word16lu('versionsNeededToExtract')
			.word16lu('flags')
			.word16lu('compressionMethod')
			.word16lu('lastModifiedTime')
			.word16lu('lastModifiedDate')
			.word32lu('crc32')
			.word32lu('compressedSize')
			.word32lu('uncompressedSize')
			.word16lu('fileNameLength')
			.word16lu('extraFieldLength')
			.word16lu('fileCommentLength')
			.word16lu('diskNumber')
			.word16lu('internalFileAttributes')
			.word32lu('externalFileAttributes')
			.word32lu('offsetToLocalFileHeader').vars
		return t
	}
	Kt.prototype._readEndOfCentralDirectory64 = function (e) {
		var t = to
			.parse(e)
			.word64lu('centralDirectoryRecordSize')
			.word16lu('versionMadeBy')
			.word16lu('versionsNeededToExtract')
			.word32lu('diskNumber')
			.word32lu('diskNumberWithCentralDirectoryStart')
			.word64lu('centralDirectoryEntries')
			.word64lu('totalCentralDirectoryEntries')
			.word64lu('sizeOfCentralDirectory')
			.word64lu('offsetToStartOfCentralDirectory').vars
		return t
	}
	Kt.prototype._readEndOfCentralDirectory = function (e) {
		var t = to
			.parse(e)
			.word16lu('diskNumber')
			.word16lu('diskStart')
			.word16lu('centralDirectoryEntries')
			.word16lu('totalCentralDirectoryEntries')
			.word32lu('sizeOfCentralDirectory')
			.word32lu('offsetToStartOfCentralDirectory')
			.word16lu('commentLength').vars
		return t
	}
	var mPe =
		'\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0 '
	Kt.prototype._decodeString = function (e, t) {
		if (t) return e.toString('utf8')
		if (this.options.decodeString) return this.options.decodeString(e)
		let r = ''
		for (var n = 0; n < e.length; n++) r += mPe[e[n]]
		return r
	}
	Kt.prototype._parseOrOutput = function (e, t) {
		for (
			var r;
			(r = this.processDataChunk(this.data)) > 0 &&
			((this.data = this.data.slice(r)), this.data.length !== 0);
		);
		if (this.state === de.FILE_DATA) {
			if (this.outStreamInfo.limit >= 0) {
				var n = this.outStreamInfo.limit - this.outStreamInfo.written,
					i
				n < this.data.length
					? ((i = this.data.slice(0, n)), (this.data = this.data.slice(n)))
					: ((i = this.data), (this.data = new Buffer(''))),
					(this.outStreamInfo.written += i.length),
					this.outStreamInfo.limit === this.outStreamInfo.written
						? ((this.state = de.START), this.outStreamInfo.stream.end(i, e, t))
						: this.outStreamInfo.stream.write(i, e, t)
			} else {
				var i = this.data
				;(this.data = new Buffer('')), (this.outStreamInfo.written += i.length)
				var o = this.outStreamInfo.stream
				o.write(i, e, () => {
					if (this.state === de.FILE_DATA_END)
						return (this.state = de.START), o.end(t)
					t()
				})
			}
			return
		}
		t()
	}
	Kt.prototype.drainAll = function () {
		this._drainAllEntries = !0
	}
	Kt.prototype._transform = function (e, t, r) {
		var n = this
		n.data.length > 0 ? (n.data = Buffer.concat([n.data, e])) : (n.data = e)
		var i = n.data.length,
			o = function () {
				if (n.data.length > 0 && n.data.length < i) {
					;(i = n.data.length), n._parseOrOutput(t, o)
					return
				}
				r()
			}
		n._parseOrOutput(t, o)
	}
	Kt.prototype._flush = function (e) {
		var t = this
		if (t.data.length > 0) {
			t._parseOrOutput('buffer', function () {
				if (t.data.length > 0)
					return setImmediate(function () {
						t._flush(e)
					})
				e()
			})
			return
		}
		if (t.state === de.FILE_DATA)
			return e(
				new Error('Stream finished in an invalid state, uncompression failed'),
			)
		setImmediate(e)
	}
	g$.exports = Kt
})
var h$ = E((yDe, v$) => {
	var Vl = require('stream').Transform,
		fPe = require('util'),
		pPe = RC()
	function ro(e) {
		if (!(this instanceof ro)) return new ro(e)
		var t = e || {}
		Vl.call(this, { readableObjectMode: !0 }),
			(this.opts = e || {}),
			(this.unzipStream = new pPe(this.opts))
		var r = this
		this.unzipStream.on('entry', function (n) {
			r.push(n)
		}),
			this.unzipStream.on('error', function (n) {
				r.emit('error', n)
			})
	}
	fPe.inherits(ro, Vl)
	ro.prototype._transform = function (e, t, r) {
		this.unzipStream.write(e, t, r)
	}
	ro.prototype._flush = function (e) {
		var t = this
		this.unzipStream.end(function () {
			process.nextTick(function () {
				t.emit('close')
			}),
				e()
		})
	}
	ro.prototype.on = function (e, t) {
		return e === 'entry'
			? Vl.prototype.on.call(this, 'data', t)
			: Vl.prototype.on.call(this, e, t)
	}
	ro.prototype.drainAll = function () {
		return (
			this.unzipStream.drainAll(),
			this.pipe(
				new Vl({
					objectMode: !0,
					transform: function (e, t, r) {
						r()
					},
				}),
			)
		)
	}
	v$.exports = ro
})
var C$ = E((SDe, S$) => {
	var Kl = require('path'),
		_$ = require('fs'),
		y$ = parseInt('0777', 8)
	S$.exports = yc.mkdirp = yc.mkdirP = yc
	function yc(e, t, r, n) {
		typeof t == 'function'
			? ((r = t), (t = {}))
			: (!t || typeof t != 'object') && (t = { mode: t })
		var i = t.mode,
			o = t.fs || _$
		i === void 0 && (i = y$), n || (n = null)
		var s = r || function () {}
		;(e = Kl.resolve(e)),
			o.mkdir(e, i, function (c) {
				if (!c) return (n = n || e), s(null, n)
				switch (c.code) {
					case 'ENOENT':
						if (Kl.dirname(e) === e) return s(c)
						yc(Kl.dirname(e), t, function (l, u) {
							l ? s(l, u) : yc(e, t, s, u)
						})
						break
					default:
						o.stat(e, function (l, u) {
							l || !u.isDirectory() ? s(c, n) : s(null, n)
						})
						break
				}
			})
	}
	yc.sync = function e(t, r, n) {
		;(!r || typeof r != 'object') && (r = { mode: r })
		var i = r.mode,
			o = r.fs || _$
		i === void 0 && (i = y$), n || (n = null), (t = Kl.resolve(t))
		try {
			o.mkdirSync(t, i), (n = n || t)
		} catch (c) {
			switch (c.code) {
				case 'ENOENT':
					;(n = e(Kl.dirname(t), r, n)), e(t, r, n)
					break
				default:
					var s
					try {
						s = o.statSync(t)
					} catch {
						throw c
					}
					if (!s.isDirectory()) throw c
					break
			}
		}
		return n
	}
})
var x$ = E((CDe, w$) => {
	var gPe = require('fs'),
		E$ = require('path'),
		vPe = require('util'),
		hPe = C$(),
		b$ = require('stream').Transform,
		_Pe = RC()
	function no(e) {
		if (!(this instanceof no)) return new no(e)
		b$.call(this),
			(this.opts = e || {}),
			(this.unzipStream = new _Pe(this.opts)),
			(this.unfinishedEntries = 0),
			(this.afterFlushWait = !1),
			(this.createdDirectories = {})
		var t = this
		this.unzipStream.on('entry', this._processEntry.bind(this)),
			this.unzipStream.on('error', function (r) {
				t.emit('error', r)
			})
	}
	vPe.inherits(no, b$)
	no.prototype._transform = function (e, t, r) {
		this.unzipStream.write(e, t, r)
	}
	no.prototype._flush = function (e) {
		var t = this,
			r = function () {
				process.nextTick(function () {
					t.emit('close')
				}),
					e()
			}
		this.unzipStream.end(function () {
			if (t.unfinishedEntries > 0)
				return (t.afterFlushWait = !0), t.on('await-finished', r)
			r()
		})
	}
	no.prototype._processEntry = function (e) {
		var t = this,
			r = E$.join(this.opts.path, e.path),
			n = e.isDirectory ? r : E$.dirname(r)
		this.unfinishedEntries++
		var i = function () {
			var o = gPe.createWriteStream(r)
			o.on('close', function () {
				t.unfinishedEntries--, t._notifyAwaiter()
			}),
				o.on('error', function (s) {
					t.emit('error', s)
				}),
				e.pipe(o)
		}
		if (this.createdDirectories[n] || n === '.') return i()
		hPe(n, function (o) {
			if (o) return t.emit('error', o)
			if (((t.createdDirectories[n] = !0), e.isDirectory)) {
				t.unfinishedEntries--, t._notifyAwaiter()
				return
			}
			i()
		})
	}
	no.prototype._notifyAwaiter = function () {
		this.afterFlushWait &&
			this.unfinishedEntries === 0 &&
			(this.emit('await-finished'), (this.afterFlushWait = !1))
	}
	w$.exports = no
})
var P$ = E((kC) => {
	'use strict'
	kC.Parse = h$()
	kC.Extract = x$()
})
var B$ = E((xDe, T$) => {
	var Hp = Object.defineProperty,
		yPe = Object.getOwnPropertyDescriptor,
		SPe = Object.getOwnPropertyNames,
		CPe = Object.prototype.hasOwnProperty,
		A$ = (e, t) => Hp(e, 'name', { value: t, configurable: !0 }),
		EPe = (e, t) => {
			for (var r in t) Hp(e, r, { get: t[r], enumerable: !0 })
		},
		bPe = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of SPe(t))
					!CPe.call(e, i) &&
						i !== r &&
						Hp(e, i, {
							get: () => t[i],
							enumerable: !(n = yPe(t, i)) || n.enumerable,
						})
			return e
		},
		wPe = (e) => bPe(Hp({}, '__esModule', { value: !0 }), e),
		O$ = {}
	EPe(O$, {
		AbortController: () => xPe,
		AbortHandler: () => IC.AbortHandler,
		AbortSignal: () => k$,
		IAbortController: () => IC.AbortController,
		IAbortSignal: () => IC.AbortSignal,
	})
	T$.exports = wPe(O$)
	var IC = en(),
		R$ = class {
			constructor() {
				;(this.onabort = null),
					(this._aborted = !1),
					Object.defineProperty(this, '_aborted', { value: !1, writable: !0 })
			}
			get aborted() {
				return this._aborted
			}
			abort() {
				;(this._aborted = !0),
					this.onabort && (this.onabort(this), (this.onabort = null))
			}
		}
	A$(R$, 'AbortSignal')
	var k$ = R$,
		I$ = class {
			constructor() {
				this.signal = new k$()
			}
			abort() {
				this.signal.abort()
			}
		}
	A$(I$, 'AbortController')
	var xPe = I$
})
var N$ = E(($p) => {
	'use strict'
	Object.defineProperty($p, '__esModule', { value: !0 })
	$p.ClientSharedValues = void 0
	$p.ClientSharedValues = { lstatSync: () => {} }
})
var D$ = E((Vp) => {
	'use strict'
	Object.defineProperty(Vp, '__esModule', { value: !0 })
	Vp.ClientDefaultValues = void 0
	var PPe = require('fs'),
		APe = N$()
	Vp.ClientDefaultValues = {
		...APe.ClientSharedValues,
		runtime: 'node',
		lstatSync: PPe.lstatSync,
	}
})
var G$ = E((RDe, U$) => {
	'use strict'
	var Wp = Object.defineProperty,
		OPe = Object.getOwnPropertyDescriptor,
		RPe = Object.getOwnPropertyNames,
		kPe = Object.prototype.hasOwnProperty,
		li = (e, t) => Wp(e, 'name', { value: t, configurable: !0 }),
		IPe = (e, t) => {
			for (var r in t) Wp(e, r, { get: t[r], enumerable: !0 })
		},
		TPe = (e, t, r, n) => {
			if ((t && typeof t == 'object') || typeof t == 'function')
				for (let i of RPe(t))
					!kPe.call(e, i) &&
						i !== r &&
						Wp(e, i, {
							get: () => t[i],
							enumerable: !(n = OPe(t, i)) || n.enumerable,
						})
			return e
		},
		BPe = (e) => TPe(Wp({}, '__esModule', { value: !0 }), e),
		M$ = {}
	IPe(M$, { Upload: () => MPe })
	U$.exports = BPe(M$)
	var Ss = bC(),
		NPe = B$(),
		L$ = $n(),
		F$ = ze(),
		TC = require('events'),
		io = require('buffer'),
		DPe = D$(),
		BC = li((e) => {
			if (e == null) return 0
			if (typeof e == 'string') return io.Buffer.byteLength(e)
			if (typeof e.byteLength == 'number') return e.byteLength
			if (typeof e.length == 'number') return e.length
			if (typeof e.size == 'number') return e.size
			if (typeof e.path == 'string')
				try {
					return DPe.ClientDefaultValues.lstatSync(e.path).size
				} catch {
					return
				}
		}, 'byteLength'),
		LPe = require('stream')
	async function* Kp(e, t, r) {
		let n = 1,
			i = { chunks: [], length: 0 }
		for await (let o of r(e))
			for (i.chunks.push(o), i.length += o.byteLength; i.length > t; ) {
				let s = i.chunks.length > 1 ? io.Buffer.concat(i.chunks) : i.chunks[0]
				yield { partNumber: n, data: s.subarray(0, t) },
					(i.chunks = [s.subarray(t)]),
					(i.length = i.chunks[0].byteLength),
					(n += 1)
			}
		yield {
			partNumber: n,
			data: i.chunks.length !== 1 ? io.Buffer.concat(i.chunks) : i.chunks[0],
			lastPart: !0,
		}
	}
	li(Kp, 'getChunkStream')
	async function* DC(e, t) {
		let r = 1,
			n = 0,
			i = t
		for (; i < e.byteLength; )
			yield { partNumber: r, data: e.subarray(n, i) },
				(r += 1),
				(n = i),
				(i = n + t)
		yield { partNumber: r, data: e.subarray(n), lastPart: !0 }
	}
	li(DC, 'getChunkUint8Array')
	async function* q$(e) {
		for await (let t of e)
			io.Buffer.isBuffer(t) || t instanceof Uint8Array
				? yield t
				: yield io.Buffer.from(t)
	}
	li(q$, 'getDataReadable')
	async function* LC(e) {
		let t = e.getReader()
		try {
			for (;;) {
				let { done: r, value: n } = await t.read()
				if (r) return
				io.Buffer.isBuffer(n) || n instanceof Uint8Array
					? yield n
					: yield io.Buffer.from(n)
			}
		} catch (r) {
			throw r
		} finally {
			t.releaseLock()
		}
	}
	li(LC, 'getDataReadableStream')
	var FPe = li((e, t) => {
			if (e instanceof Uint8Array) return DC(e, t)
			if (e instanceof LPe.Readable) return Kp(e, t, q$)
			if (e instanceof String || typeof e == 'string')
				return DC(io.Buffer.from(e), t)
			if (typeof e.stream == 'function') return Kp(e.stream(), t, LC)
			if (e instanceof ReadableStream) return Kp(e, t, LC)
			throw new Error(
				'Body Data is unsupported format, expected data to be one of: string | Uint8Array | Buffer | Readable | ReadableStream | Blob;.',
			)
		}, 'getChunk'),
		NC = 1024 * 1024 * 5,
		j$ = class extends TC.EventEmitter {
			constructor(t) {
				super(),
					(this.MAX_PARTS = 1e4),
					(this.queueSize = 4),
					(this.partSize = NC),
					(this.leavePartsOnError = !1),
					(this.tags = []),
					(this.concurrentUploaders = []),
					(this.abortMultipartUploadCommand = null),
					(this.uploadedParts = []),
					(this.uploadEnqueuedPartsCount = 0),
					(this.isMultiPart = !0),
					(this.sent = !1),
					(this.queueSize = t.queueSize || this.queueSize),
					(this.partSize = t.partSize || this.partSize),
					(this.leavePartsOnError =
						t.leavePartsOnError || this.leavePartsOnError),
					(this.tags = t.tags || this.tags),
					(this.client = t.client),
					(this.params = t.params),
					this.__validateInput(),
					(this.totalBytes = BC(this.params.Body)),
					(this.bytesUploadedSoFar = 0),
					(this.abortController =
						t.abortController ?? new NPe.AbortController())
			}
			async abort() {
				this.abortController.abort()
			}
			async done() {
				if (this.sent)
					throw new Error(
						'@aws-sdk/lib-storage: this instance of Upload has already executed .done(). Create a new instance.',
					)
				return (
					(this.sent = !0),
					await Promise.race([
						this.__doMultipartUpload(),
						this.__abortTimeout(this.abortController.signal),
					])
				)
			}
			on(t, r) {
				return (this.uploadEvent = t), super.on(t, r)
			}
			async __uploadUsingPut(t) {
				var r
				this.isMultiPart = !1
				let n = { ...this.params, Body: t.data },
					i = this.client.config,
					o = i.requestHandler,
					s = o instanceof TC.EventEmitter ? o : null,
					c = li((_) => {
						;(this.bytesUploadedSoFar = _.loaded),
							(this.totalBytes = _.total),
							this.__notifyProgress({
								loaded: this.bytesUploadedSoFar,
								total: this.totalBytes,
								part: t.partNumber,
								Key: this.params.Key,
								Bucket: this.params.Bucket,
							})
					}, 'uploadEventListener')
				s !== null && s.on('xhr.upload.progress', c)
				let l = await Promise.all([
						this.client.send(new Ss.PutObjectCommand(n)),
						(r = i?.endpoint) == null ? void 0 : r.call(i),
					]),
					u = l[0],
					m = l[1]
				if (
					(m ||
						(m = (0, L$.toEndpointV1)(
							await (0, L$.getEndpointFromInstructions)(
								n,
								Ss.PutObjectCommand,
								{ ...i },
							),
						)),
					!m)
				)
					throw new Error(
						'Could not resolve endpoint from S3 "client.config.endpoint()" nor EndpointsV2.',
					)
				s !== null && s.off('xhr.upload.progress', c)
				let f = this.params.Key.split('/')
						.map((_) => (0, F$.extendedEncodeURIComponent)(_))
						.join('/'),
					p = (0, F$.extendedEncodeURIComponent)(this.params.Bucket),
					g = (() => {
						let _ = m.hostname.startsWith(`${p}.`),
							y = this.client.config.forcePathStyle,
							P = m.port ? `:${m.port}` : ''
						return y
							? `${m.protocol}//${m.hostname}${P}/${p}/${f}`
							: _
								? `${m.protocol}//${m.hostname}${P}/${f}`
								: `${m.protocol}//${p}.${m.hostname}${P}/${f}`
					})()
				this.singleUploadResult = {
					...u,
					Bucket: this.params.Bucket,
					Key: this.params.Key,
					Location: g,
				}
				let v = BC(t.data)
				this.__notifyProgress({
					loaded: v,
					total: v,
					part: 1,
					Key: this.params.Key,
					Bucket: this.params.Bucket,
				})
			}
			async __createMultipartUpload() {
				if (!this.createMultiPartPromise) {
					let t = { ...this.params, Body: void 0 }
					this.createMultiPartPromise = this.client
						.send(new Ss.CreateMultipartUploadCommand(t))
						.then(
							(r) => (
								(this.abortMultipartUploadCommand =
									new Ss.AbortMultipartUploadCommand({
										Bucket: this.params.Bucket,
										Key: this.params.Key,
										UploadId: r.UploadId,
									})),
								r
							),
						)
				}
				return this.createMultiPartPromise
			}
			async __doConcurrentUpload(t) {
				for await (let r of t) {
					if (this.uploadEnqueuedPartsCount > this.MAX_PARTS)
						throw new Error(
							`Exceeded ${this.MAX_PARTS} parts in multipart upload to Bucket: ${this.params.Bucket} Key: ${this.params.Key}.`,
						)
					if (this.abortController.signal.aborted) return
					if (r.partNumber === 1 && r.lastPart)
						return await this.__uploadUsingPut(r)
					if (!this.uploadId) {
						let { UploadId: u } = await this.__createMultipartUpload()
						if (((this.uploadId = u), this.abortController.signal.aborted))
							return
					}
					let n = BC(r.data) || 0,
						i = this.client.config.requestHandler,
						o = i instanceof TC.EventEmitter ? i : null,
						s = 0,
						c = li((u, m) => {
							;(Number(m.query.partNumber) || -1) === r.partNumber &&
								(u.total &&
									n &&
									((this.bytesUploadedSoFar += u.loaded - s), (s = u.loaded)),
								this.__notifyProgress({
									loaded: this.bytesUploadedSoFar,
									total: this.totalBytes,
									part: r.partNumber,
									Key: this.params.Key,
									Bucket: this.params.Bucket,
								}))
						}, 'uploadEventListener')
					o !== null && o.on('xhr.upload.progress', c),
						(this.uploadEnqueuedPartsCount += 1)
					let l = await this.client.send(
						new Ss.UploadPartCommand({
							...this.params,
							ContentLength: void 0,
							UploadId: this.uploadId,
							Body: r.data,
							PartNumber: r.partNumber,
						}),
					)
					if (
						(o !== null && o.off('xhr.upload.progress', c),
						this.abortController.signal.aborted)
					)
						return
					if (!l.ETag)
						throw new Error(
							`Part ${r.partNumber} is missing ETag in UploadPart response. Missing Bucket CORS configuration for ETag header?`,
						)
					this.uploadedParts.push({
						PartNumber: r.partNumber,
						ETag: l.ETag,
						...(l.ChecksumCRC32 && { ChecksumCRC32: l.ChecksumCRC32 }),
						...(l.ChecksumCRC32C && { ChecksumCRC32C: l.ChecksumCRC32C }),
						...(l.ChecksumSHA1 && { ChecksumSHA1: l.ChecksumSHA1 }),
						...(l.ChecksumSHA256 && { ChecksumSHA256: l.ChecksumSHA256 }),
					}),
						o === null && (this.bytesUploadedSoFar += n),
						this.__notifyProgress({
							loaded: this.bytesUploadedSoFar,
							total: this.totalBytes,
							part: r.partNumber,
							Key: this.params.Key,
							Bucket: this.params.Bucket,
						})
				}
			}
			async __doMultipartUpload() {
				let t = FPe(this.params.Body, this.partSize),
					r = []
				for (let i = 0; i < this.queueSize; i++) {
					let o = this.__doConcurrentUpload(t).catch((s) => {
						r.push(s)
					})
					this.concurrentUploaders.push(o)
				}
				if ((await Promise.all(this.concurrentUploaders), r.length >= 1))
					throw (await this.markUploadAsAborted(), r[0])
				if (this.abortController.signal.aborted)
					throw (
						(await this.markUploadAsAborted(),
						Object.assign(new Error('Upload aborted.'), { name: 'AbortError' }))
					)
				let n
				if (this.isMultiPart) {
					this.uploadedParts.sort((o, s) => o.PartNumber - s.PartNumber)
					let i = {
						...this.params,
						Body: void 0,
						UploadId: this.uploadId,
						MultipartUpload: { Parts: this.uploadedParts },
					}
					;(n = await this.client.send(
						new Ss.CompleteMultipartUploadCommand(i),
					)),
						typeof n?.Location == 'string' &&
							n.Location.includes('%2F') &&
							(n.Location = n.Location.replace(/%2F/g, '/'))
				} else n = this.singleUploadResult
				return (
					(this.abortMultipartUploadCommand = null),
					this.tags.length &&
						(await this.client.send(
							new Ss.PutObjectTaggingCommand({
								...this.params,
								Tagging: { TagSet: this.tags },
							}),
						)),
					n
				)
			}
			async markUploadAsAborted() {
				this.uploadId &&
					!this.leavePartsOnError &&
					this.abortMultipartUploadCommand !== null &&
					(await this.client.send(this.abortMultipartUploadCommand),
					(this.abortMultipartUploadCommand = null))
			}
			__notifyProgress(t) {
				this.uploadEvent && this.emit(this.uploadEvent, t)
			}
			async __abortTimeout(t) {
				return new Promise((r, n) => {
					t.onabort = () => {
						let i = new Error('Upload aborted.')
						;(i.name = 'AbortError'), n(i)
					}
				})
			}
			__validateInput() {
				if (!this.params)
					throw new Error(
						'InputError: Upload requires params to be passed to upload.',
					)
				if (!this.client)
					throw new Error(
						'InputError: Upload requires a AWS client to do uploads with.',
					)
				if (this.partSize < NC)
					throw new Error(
						`EntityTooSmall: Your proposed upload partsize [${this.partSize}] is smaller than the minimum allowed size [${NC}] (5MB)`,
					)
				if (this.queueSize < 1)
					throw new Error('Queue size: Must have at least one uploading queue.')
			}
		}
	li(j$, 'Upload')
	var MPe = j$
})
var jPe = {}
Sc(jPe, { handler: () => qPe })
module.exports = ve(jPe)
var H0 = Oe(z0(), 1),
	$0 = Oe(require('node:fs'), 1),
	V0 = async ({ audioPath: e, imagePath: t, outputPath: r }) => {
		let n = [],
			i = $0.default.createWriteStream(r)
		try {
			await new Promise((o, s) => {
				;(0, H0.default)()
					.input(t)
					.loop()
					.input(e)
					.audioCodec('aac')
					.audioBitrate(320)
					.videoCodec('libx264')
					.outputOption('-pix_fmt', 'yuv420p')
					.outputOption('-shortest')
					.outputFormat('mp4')
					.outputOption('-movflags frag_keyframe+empty_moov')
					.on('start', (c) =>
						console.log(`Started making video using command: ${c}`),
					)
					.on('end', () => {
						console.log('Finished making video'), o()
					})
					.on('progress', ({ timemark: c }) =>
						console.log(`Current timestamp: ${c}`),
					)
					.on('error', ({ message: c }) => {
						console.error(c), n.push(c), s()
					})
					.pipe(i, { end: !0 })
			})
		} catch (o) {
			o instanceof Error
				? n.push(o.message)
				: n.push('An unknown error occurred')
		}
		return { errors: n }
	}
var Yp = Oe(bC(), 1)
var Vt = []
for (let e = 0; e < 256; ++e) Vt.push((e + 256).toString(16).slice(1))
function HH(e, t = 0) {
	return (
		Vt[e[t + 0]] +
		Vt[e[t + 1]] +
		Vt[e[t + 2]] +
		Vt[e[t + 3]] +
		'-' +
		Vt[e[t + 4]] +
		Vt[e[t + 5]] +
		'-' +
		Vt[e[t + 6]] +
		Vt[e[t + 7]] +
		'-' +
		Vt[e[t + 8]] +
		Vt[e[t + 9]] +
		'-' +
		Vt[e[t + 10]] +
		Vt[e[t + 11]] +
		Vt[e[t + 12]] +
		Vt[e[t + 13]] +
		Vt[e[t + 14]] +
		Vt[e[t + 15]]
	).toLowerCase()
}
var $H = Oe(require('node:crypto')),
	Gp = new Uint8Array(256),
	Up = Gp.length
function wC() {
	return (
		Up > Gp.length - 16 && ($H.default.randomFillSync(Gp), (Up = 0)),
		Gp.slice(Up, (Up += 16))
	)
}
var VH = Oe(require('node:crypto')),
	xC = { randomUUID: VH.default.randomUUID }
function Vxe(e, t, r) {
	if (xC.randomUUID && !t && !e) return xC.randomUUID()
	e = e || {}
	let n = e.random || (e.rng || wC)()
	if (((n[6] = (n[6] & 15) | 64), (n[8] = (n[8] & 63) | 128), t)) {
		r = r || 0
		for (let i = 0; i < 16; ++i) t[r + i] = n[i]
		return t
	}
	return HH(n)
}
var PC = Vxe
var H$ = require('node:stream'),
	$$ = Oe(P$(), 1),
	V$ = Oe(require('node:path'), 1),
	Xp = Oe(require('node:fs'), 1),
	K$ = Oe(G$(), 1),
	z$ = new Yp.S3Client({ region: 'ap-southeast-2' }),
	qPe = async (e) => {
		let t = e.Records[0]
		if (!t) {
			console.error('First S3 record is undefined.')
			return
		}
		let r = t.s3.bucket.name,
			n = t.s3.object.key,
			o = (await z$.send(new Yp.GetObjectCommand({ Bucket: r, Key: n }))).Body
		if (!(o instanceof H$.Readable)) {
			console.error('Response body is not a readable stream')
			return
		}
		let s = null,
			c = null
		if (
			(o.pipe($$.default.Parse()).on('entry', (m) => {
				let f = m.path
				if (typeof f == 'string') {
					let p = V$.default.parse(f).name
					if (p === 'img') {
						;(c = '/tmp/img.jpg'), m.pipe(Xp.default.createWriteStream(c))
						return
					}
					if (p === 'audio') {
						;(s = '/tmp/audio.mp3'), m.pipe(Xp.default.createWriteStream(s))
						return
					}
				}
				m.autodrain()
			}),
			await new Promise((m) => o.on('close', m)),
			!s || !c)
		) {
			console.error('Audio path and image path are not both defined')
			return
		}
		let l = `/tmp/${PC()}.mp4`
		await V0({ audioPath: s, imagePath: c, outputPath: l })
		let u = Xp.default.createReadStream(l)
		try {
			let m = new K$.Upload({
				client: z$,
				params: { Bucket: process.env.OUTPUT_BUCKET_NAME, Key: l, Body: u },
			})
			m.on('httpUploadProgress', (f) =>
				console.log(`Uploading video, current progress: ${f.total}`),
			),
				await m.done()
		} catch (m) {
			m instanceof Error
				? console.error(
						`Failed to upload video, the following error occurred ${m.message}`,
					)
				: console.error('Failed to upload video, an unknown error occurred.')
		}
	}
0 && (module.exports = { handler })
//# sourceMappingURL=index.js.map
